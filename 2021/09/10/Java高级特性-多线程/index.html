<!DOCTYPE html><html lang="CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://img10.360buyimg.com/ddimg/jfs/t1/210672/22/780/14721/614304cbE6ed71481/b30794e20af29208.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="Java高级特性-多线程                           认识线程       计算机的操作系统大多采用多任务和分时设计，多任务是指在一个操作系统中可以同时运行多个程序，例如，可以在使用QQ聊天的同时听音乐，即有多个独立运行的任务，每个任务对应一个进程，每个进程又可以产生多个线程。                     进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级特性-多线程">
<meta property="og:url" content="http://example.com/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java高级特性-多线程                           认识线程       计算机的操作系统大多采用多任务和分时设计，多任务是指在一个操作系统中可以同时运行多个程序，例如，可以在使用QQ聊天的同时听音乐，即有多个独立运行的任务，每个任务对应一个进程，每个进程又可以产生多个线程。                     进程">
<meta property="og:locale">
<meta property="og:image" content="https://img12.360buyimg.com/ddimg/jfs/t1/200081/4/4690/69697/6125b7faE700d9518/fc6dfd9e5e7e1628.png">
<meta property="og:image" content="https://img11.360buyimg.com/ddimg/jfs/t1/187341/8/20161/34640/6125fd0aE6185e8ff/dfd7ac0b29c59f47.png">
<meta property="og:image" content="https://img14.360buyimg.com/ddimg/jfs/t1/183464/37/21110/49458/61289636E8adc1742/b5bc607210dcd084.png">
<meta property="og:image" content="https://img11.360buyimg.com/ddimg/jfs/t1/193025/36/20236/23306/6128a1c3E33467735/c7a86e826bcb48b9.png">
<meta property="og:image" content="https://img13.360buyimg.com/ddimg/jfs/t1/187442/1/20318/235874/6128a4b5Eb10f8fa5/52c3666bac40cca9.png">
<meta property="og:image" content="https://img13.360buyimg.com/ddimg/jfs/t1/190267/36/20836/34381/612da62dEc0ca894e/eb3feb77db150468.png">
<meta property="og:image" content="https://img11.360buyimg.com/ddimg/jfs/t1/203240/17/3969/34896/612dc8b0Ed9da6a2b/6d419307572bbae2.png">
<meta property="og:image" content="https://img10.360buyimg.com/ddimg/jfs/t1/192269/39/20949/35547/612dcae4Ecdf41bcf/f9568675b32affb0.png">
<meta property="article:published_time" content="2021-09-10T06:41:30.430Z">
<meta property="article:modified_time" content="2021-08-31T07:47:02.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java高级特性">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img12.360buyimg.com/ddimg/jfs/t1/200081/4/4690/69697/6125b7faE700d9518/fc6dfd9e5e7e1628.png"><title>Java高级特性-多线程 | Hexo</title><link ref="canonical" href="http://example.com/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hexo</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Java高级特性-多线程</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-09-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2021-08-31</span></span></div></header><div class="post-body">
        <h2 id="Java高级特性-多线程"   >
          <a href="#Java高级特性-多线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java高级特性-多线程" class="headerlink" title="Java高级特性-多线程"></a>Java高级特性-多线程</h2>
      
        <h3 id="认识线程"   >
          <a href="#认识线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#认识线程" class="headerlink" title="认识线程"></a>认识线程</h3>
      <p>计算机的操作系统大多采用多任务和分时设计，多任务是指在一个操作系统中可以同时运行多个程序，例如，可以在使用QQ聊天的同时听音乐，即有多个独立运行的任务，每个任务对应一个进程，每个进程又可以产生多个线程。</p>

        <h4 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程" class="headerlink" title="进程"></a>进程</h4>
      <p>认识进程先从程序开始。程序(Program)是对数据描述与操作的代码的集合，如Office中的Word、暴风影音等应用程序</p>
<p><strong>进程是应用程序的执行实例，有独立的内存空间和系统资源</strong></p>
<p>进程(Process)是程序的一次动态执行过程，他对应了从代码加载、执行至执行完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。操作系统同时管理一个计算机系统中的多个进程，让计算机系统中的多个进程轮流使用CPU资源，或共享操作系统的其他资源。</p>
<p>进程的特点：</p>
<blockquote>
<p>进程是系统运行程序的基本单位<br>每一个进程都有自己独立的一块内存空间、一组系统资源<br>每一个进程的内部数据和状态都是完全独立的</p>
</blockquote>
<p>当一个应用程序运行的时候会产生一个进程，如下如图所示</p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/200081/4/4690/69697/6125b7faE700d9518/fc6dfd9e5e7e1628.png" alt="20210825112416.png"></p>

        <h4 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h4>
      <p>线程是CPU调度和分配的基本单位，一个进程在其执行过程中可以产生多个线程，而线程必须在某个进程内执行。</p>
<p>线程是进程内部的一个执行单元，是进程中执行运算的最小单位，是可完成一个独立任务的顺序控制流程，如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为多线程。</p>
<p>线程按处理级别可以分为<font color="#4cb8e7">核心线程</font>和<font color="#4cb8e7">用户级线程</font></p>

        <h5 id="核心级线程"   >
          <a href="#核心级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h5>
      <p>核心级线程是系统任务相关的线程，它负责处理不同进程之间的多个线程。允许不同进程中的线程按照同一相对优先调度方法对线程进行调度，使他们有条不紊地工作，可以发挥多处理器的并发优势，以充分利用计算机的软/硬件资源。</p>

        <h5 id="用户级线程"   >
          <a href="#用户级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5>
      <p>在开发程序时，由于程序的需要而编写的线程即用户级线程，这些线程的创建、执行和消亡都是在编写应用程序时进行控制的。对于用户级线程的切换，通常发生在一个应用程序的诸多线程之间，如迅雷中的多线程下载就属于用户线程。</p>
<p>多线程可以改善用户体验。具有多个线程的进程能更好的表达和解决现实世界的具体问题，多线程是计算机应用开发和程序设计的一项重要的实用技术。</p>
<p><strong>线程和进程既有联系又有区别，具体如下:</strong></p>
<blockquote>
<p>一个进程中至少要有一个线程<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源<br>处理机分配给线程，即真正在处理机上运行的是线程</p>
</blockquote>

        <h4 id="什么是多线程"   >
          <a href="#什么是多线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h4>
      <p>如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为“多线程”</p>
<p><font color="#4cb8e7">多个线程交替占用CPU资源，而非真正的并行执行</font>(程序执行太快，用户无法直观的感受到线程的交替占用CPU资源)</p>
<p><strong>多线程的优势</strong></p>
<p>多线程有着广泛的应用法，下载工具“迅雷”是一款经典的多线程应用程序，在这个下载工具汇中，可以同时执行多个下载任务。这样不但能够加快下载的速度，减少等待的时间，而且还能充分利用网络和系统资源。</p>
<p>多线程的好处如下：</p>
<blockquote>
<p>多线程程序可以带来更好的用户体验，避免因程序执行过慢而导致出现计算机死机或白屏的情况<br>多线程程序可以最大限度地提高计算机系统的利用效率，如迅雷的多线程下载</p>
</blockquote>

        <h3 id="编写线程类"   >
          <a href="#编写线程类" class="heading-link"><i class="fas fa-link"></i></a><a href="#编写线程类" class="headerlink" title="编写线程类"></a>编写线程类</h3>
      <p>每个程序至少自动拥有一个线程，称为主线程。当程序加载到内存时启用主线程。Java程序中的 public static void main(String[] args) 方法是主线程的入口，运行 Java 程序时，会先执行这个方法。</p>
<p>开发中，用户编写的线程一般都是指除了主线程之外的其他线程。</p>
<p><strong>使用一个线程的步骤：</strong></p>
<blockquote>
<p>1.定义一个线程，同时指明这个线程所要执行的代码，即期望完成的功能<br>2.创建线程对象<br>3.启动线程<br>4.终止线程</p>
</blockquote>
<p>定义一个线程类通常有两种方法，分别是继承 java.lang.Thread 类和实现 java.lang.Runnable 接口</p>

        <h4 id="使用Thread类创建线程"   >
          <a href="#使用Thread类创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Thread类创建线程" class="headerlink" title="使用Thread类创建线程"></a>使用Thread类创建线程</h4>
      <p>Java提供了 java.lang.Thread 类支持多线程编程，该类提供了大量的方法来控制和操作线程，常用方法如下</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void run()</td>
<td align="center">执行任务操作的方法</td>
</tr>
<tr>
<td align="center">void start()</td>
<td align="center">使该线程开始执行</td>
</tr>
<tr>
<td align="center">void sleep(long millis)</td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)</td>
</tr>
<tr>
<td align="center">String getName()</td>
<td align="center">返回该线程的名称</td>
</tr>
<tr>
<td align="center">int getPriority()</td>
<td align="center">返回线程的优先级</td>
</tr>
<tr>
<td align="center">void setPriority(int newPriority)</td>
<td align="center">更新线程的优先级</td>
</tr>
<tr>
<td align="center">Thread.State getState()</td>
<td align="center">返回该线程的状态</td>
</tr>
<tr>
<td align="center">boolean isAlive()</td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center">void interrupt()</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">void yieid()</td>
<td align="center">暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
</tbody></table></div>
<p>创建线程时继承 Thread 类并重写 Thread 类的 run( )方法。Thread类的run( )方法是线程要执行操作任务的方法，所以线程要执行的代码都要写在run( )方法中，并通过调用start( )方法来启动线程。</p>
<p><strong>示例：使用继承Thread类的方式创建线程，在线程中输出1~100的整数</strong></p>
<p><strong>创建线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//创建并启动线程</span><br><span class="line">//继承Thread</span><br><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i=1;i&lt;=100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>创建测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class TestMyThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程对象并启动</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        MyThread thread2 = new MyThread();</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>运行结果图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/187341/8/20161/34640/6125fd0aE6185e8ff/dfd7ac0b29c59f47.png" alt="20210825161905.png"></p>
<p> 从图中可以发现，如果有两个及以上的线程，他们就在互相替换者占用线程，线程每次执行时长由分配的CPU时间片长度决定</p>
<p>注意：不可以使用run( )来启动线程，run()方法被当做main()中的一个普通方法执行 ，失去了线程的意义，要用start( )启动线程</p>

        <h4 id="使用Runnable接口创建线程"   >
          <a href="#使用Runnable接口创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Runnable接口创建线程" class="headerlink" title="使用Runnable接口创建线程"></a>使用Runnable接口创建线程</h4>
      <p>使用继承Thread类的方式创建线程简单明了，符合大家的习惯，但它也有一个缺点，如果定义的类已经继承了其他类则无法在继承Thread类。这时就可以使用Runnable接口创建线程的方式可以解决上述问题</p>
<p>Runnable接口中声明了一个run( )方法，即 public void run( )。一个类可以通过实现 Runnable接口并实现其 run( )方法完成线程的所有活动，已实现的run( )方法称为该对象的线程体。任何实现 Runnable 接口的对象都可以作为一个线程的目标对象。</p>
<p><strong>示例：使用实现Runnable接口的方式创建线程，在线程中输出1~100的整数</strong></p>
<p><strong>创建线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadRunnable implements Runnable&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i&lt;=100; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>创建测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class TestMyThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程对象并启动</span><br><span class="line">        Runnable runnable = new MyThreadRunnable();</span><br><span class="line">        Thread thread = new Thread(runnable,&quot;MyThread1&quot;);</span><br><span class="line">        Thread thread2 = new Thread(runnable,&quot;MyThread2&quot;);</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Theard类和Runnable接口的区别"   >
          <a href="#Theard类和Runnable接口的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Theard类和Runnable接口的区别" class="headerlink" title="Theard类和Runnable接口的区别"></a>Theard类和Runnable接口的区别</h4>
      <p>用一个售票的线程来了解两种方法有什么不同</p>

        <h5 id="使用Theard类"   >
          <a href="#使用Theard类" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Theard类" class="headerlink" title="使用Theard类"></a>使用Theard类</h5>
      <p><strong>编写线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建线程，模拟售票过程</span><br><span class="line">public class MyThread1 extends Thread&#123;</span><br><span class="line">    private int ticket =10;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i &lt;=10 ; i++) &#123;</span><br><span class="line">            if(this.ticket&gt;0)&#123;            System.out.println(Thread.currentThread().getName()+&quot;买票&quot;+this.ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test1Thread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread1 thread = new MyThread1();</span><br><span class="line">        MyThread1 thread2 = new MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试结果图</strong></p>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/183464/37/21110/49458/61289636E8adc1742/b5bc607210dcd084.png" alt="20210827153659.png"></p>
<p> 从测试结果中可以看出，使用Thread类在售票时两个售票窗口都售出了10张，但发行的只有10张，Thread不会共享数据，它们在分别完成自己的任务</p>

        <h5 id="实现Runnable接口"   >
          <a href="#实现Runnable接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5>
      <p><strong>编写线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建线程，模拟售票过程</span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">    private int ticket =10;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i &lt;=10 ; i++) &#123;</span><br><span class="line">            if(this.ticket&gt;0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;买票--&quot;+this.ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><strong>测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TestRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;窗口1&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;窗口2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><strong>测试结果图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/193025/36/20236/23306/6128a1c3E33467735/c7a86e826bcb48b9.png" alt="20210827153659.png"></p>
<p>可以看出，使用Runnable接口实现的买票的方法，只卖出了10张票<br>使用Runnable的优点是便于共享资源，共同完成一个任务</p>

        <h3 id="线程的状态"   >
          <a href="#线程的状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3>
      <p>线程的生命周期可以分为4个状态，分别为新生状态、可运行状态、阻塞状态和死亡状态。一个具有生命的线程，总是处于这4种状态之一。</p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/187442/1/20318/235874/6128a4b5Eb10f8fa5/52c3666bac40cca9.png" alt="20210827153659.png"></p>

        <h4 id="1-新生状态-New-Thread"   >
          <a href="#1-新生状态-New-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-新生状态-New-Thread" class="headerlink" title="1.新生状态(New Thread)"></a>1.新生状态(New Thread)</h4>
      <p>创建线程对象之后，尚未调用其 start( ) 方法之前，这个线程就有了生命，此时线程仅仅是一个空对象，系统没有为其分配资源。此时只能启动和终止线程，任何其他操作都会引发异常。</p>

        <h4 id="2-可运行状态-Runnable"   >
          <a href="#2-可运行状态-Runnable" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-可运行状态-Runnable" class="headerlink" title="2.可运行状态(Runnable)"></a>2.可运行状态(Runnable)</h4>
      <p>当调用 start( ) 方法启动线程之后，系统为该线程分配除 CPU 外的所需资源，这个线程就有了运行的机会，线程处于可运行状态，在这个状态中，该线程对象可能正在运行，也可能尚未运行。对于一个 CPU 的机器而言，任何时刻只能有一个处于可运行状态的线程占用处理机，获取 CPU 资源，此时系统真正运行线程的 run( ) 方法。</p>

        <h4 id="3-阻塞状态"   >
          <a href="#3-阻塞状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-阻塞状态" class="headerlink" title="3.阻塞状态"></a>3.阻塞状态</h4>
      <p>一个正在运行的线程因某些原因不能继续运行时，进入阻塞状态。阻塞状态是一种“不可运行”的状态，而处于这种状态的线程在得到一个特定的事件之后会转回可运行状态</p>
<p>导致一个线程被阻塞有以下原因:</p>
<blockquote>
<p>调用了Thread类的静态方法sleep( )，sleep( )里面可以放参数，参数为毫秒。<br>一个线程执行的执行需要得到一个对象的锁，而这个对象的锁正在被别的线程占用，那么此线程会被阻塞。<br>线程的suspend( )方法被调用而使线程被挂起时，线程进入阻塞状态。但suspend( )容易导致死锁，已经被JDK列为过期方法，基本不再使用。</p>
</blockquote>
<p>处于阻塞状态的线程可以转回可运行状态，例如，在调用sleep( )方法之后，这个线程的睡眠时间已经达到了指定的间隔，那么它就有可能重新回到可运行状态。或当一个线程等待的锁变得可用的时候，那么这个线程也会从阻塞状态转入可运行状态。</p>

        <h4 id="4-死亡状态-Dead"   >
          <a href="#4-死亡状态-Dead" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-死亡状态-Dead" class="headerlink" title="4.死亡状态(Dead)"></a>4.死亡状态(Dead)</h4>
      <p>一个线程的 run( ) 方法运行完毕、stop( ) 方法被调用或者在运行过程中出现未捕获的异常时，线程进入死亡状态。</p>

        <h3 id="线程调度"   >
          <a href="#线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3>
      <p>当同一时刻有多个线程处于可运行状态，它们需要排队等待CPU资源，每个线程会自动获取一个线程的优先级(Priority)，优先级的高低反映线程的重要或紧急程度。<br>可运行状态的线程按优先级排队，线程调度依据建立在优先级的基础上的“先到先服务”原则。</p>
<p>线程调度管理器负责线程排队和在线分配CPU，并按线程调度算法进行调度。当线程调度管理器选中某个线程时，该线程获得CPU资源进入运行状态。</p>
<p>线程调度是抢占式调度，即在当前线程执行过程中如果有一个更高优先级的线程进入可运行状态，则这个更高优先级的线程立即被调度执行。</p>
<p><strong>线程的方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void setPriority(int newPriority)</td>
<td align="center">更改线程的优先级</td>
</tr>
<tr>
<td align="center">static void sleep(long millis)</td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center">static void yield)()</td>
<td align="center">暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
<tr>
<td align="center">void interrput()</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">boolean isAlive()</td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
</tbody></table></div>

        <h4 id="优先级和休眠"   >
          <a href="#优先级和休眠" class="heading-link"><i class="fas fa-link"></i></a><a href="#优先级和休眠" class="headerlink" title="优先级和休眠"></a>优先级和休眠</h4>
      <p>线程的有优先级用 1~10 表示，10表示最高优先级，默认是值5，每个优先级对应一个Thread类的公用静态常量。例如</p>
<blockquote>
<p>public static final int NORM_PRIORITY=5;<br>public static final int MIN_PRIORITY=1;<br>public static final int MAX_PRIORITY=10;</p>
</blockquote>
<p>每个线程的优先级都介于 Thread.MIN_PRIORITY 和 Thread.MAX_PROPRIORITY 之间。</p>
<p>线程的优先级可以通过 setPriority(int grade) 方法更改，此方法的参数表示要设置的优先级，它必须是一个 1~10 的整数</p>
<p><strong>优先级案例</strong></p>
<p>Thread方法类</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadRunnable implements Runnable&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i&lt;=10; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class TestMyThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程对象并启动</span><br><span class="line">        Runnable runnable = new MyThreadRunnable();</span><br><span class="line">        Thread thread = new Thread(runnable,&quot;MyThread1&quot;);</span><br><span class="line">        Thread thread2 = new Thread(runnable,&quot;MyThread2&quot;);</span><br><span class="line">        //线程调度：设置线程优先级</span><br><span class="line">        thread2.setPriority(10);</span><br><span class="line">        thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>休眠案例</strong></p>
<p>测试类</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//模拟线程休眠</span><br><span class="line">public class Wait &#123;</span><br><span class="line">    public static void bySec(long s) throws InterruptedException &#123;</span><br><span class="line">        // s:线程休眠的秒数</span><br><span class="line">        for (int i = 0; i&lt;=s; i++) &#123;</span><br><span class="line">            System.out.println(i+&quot;秒&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;-----------------线程开始休眠-----------------&quot;);</span><br><span class="line">        Wait.bySec(10);</span><br><span class="line">        System.out.println(&quot;-----------------线程结束休眠-----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h4 id="join-方法"   >
          <a href="#join-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#join-方法" class="headerlink" title="join( ) 方法"></a>join( ) 方法</h4>
      <p>join( ) 方法使当前线程暂停执行，等待调用该方法的线程结束后再继续执行本线程。<br>它有三种重载形式</p>
<blockquote>
<p>public final void join( )<br>public final void join(long mills)<br>public final void join(long mills,int nanos)</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestThread &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //创建子线程对象</span><br><span class="line">        Runnable runnable = new MyThread();</span><br><span class="line">        Thread t = new Thread(runnable,&quot;MyThread&quot;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        //主线程</span><br><span class="line">        for (int i = 0; i &lt;=20 ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">            //当i=5的时候，强制把 t 线程加入执行</span><br><span class="line">            //线程调度：join() --等待线程终止：等待 t 线程执行结束后，main主线程在继续执行</span><br><span class="line">            if(i==5)&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="yield-方法"   >
          <a href="#yield-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield-方法" class="headerlink" title="yield( ) 方法"></a>yield( ) 方法</h4>
      <p>yield( ) 方法可以让当前线程暂停执行，允许其他线程执行，但该线程仍处于可运行状态，并不变为阻塞状态。此时，系统选择其他相同或更高级线程执行，若无其他相同或更高优先级线程，则该线程继续执行。</p>
<p><strong>案例：使用yield( ) 方法暂停线程</strong></p>
<p>yield( ) 方法的语法格式如下</p>
<blockquote>
<p>public static void yield( )</p>
</blockquote>
<p>yield( ) 方法可以让当前线程暂停执行，允许其他线程执行，但该线程仍处于可运行状态，并不变为阻塞状态 。此时，系统选择其他相同或更高优先级线程执行，若无其他想同或更高优先级线程，则该线程继续执行。</p>
<p>案例：</p>
<p><strong>方法</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestYield implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;= 4;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">            if (i==3)&#123;</span><br><span class="line">                //礼让，线程调度：yield</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建两个线程对象</span><br><span class="line">        Runnable r = new TestYield();</span><br><span class="line">        Thread t1= new Thread(r,&quot;线程A&quot;);</span><br><span class="line">        Thread t2= new Thread(r,&quot;线程B&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>注意：线程礼让只是提供一种可能性，不能保证一定实现礼让</strong></p>

        <h4 id="yield-方法和join-方法的区别"   >
          <a href="#yield-方法和join-方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield-方法和join-方法的区别" class="headerlink" title="yield( ) 方法和join( )方法的区别"></a>yield( ) 方法和join( )方法的区别</h4>
      <p><strong>yield( ):</strong> </p>
<blockquote>
<p>暂停当前正在执行的线程对象，并执行其他线程，线程礼让<br>只是提供一种可能，但那是不能保证一定会实现礼让</p>
</blockquote>
<p><strong>join( ):</strong></p>
<blockquote>
<p>join( ) : 阻塞当前线程，直到其他线程执行完毕，当前线程才进入就绪状态</p>
</blockquote>

        <h4 id="yield-方法和-sleep-方法的区别"   >
          <a href="#yield-方法和-sleep-方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield-方法和-sleep-方法的区别" class="headerlink" title="yield( ) 方法和 sleep( )方法的区别"></a>yield( ) 方法和 sleep( )方法的区别</h4>
      <p>sleep( ) 方法 ：</p>
<blockquote>
<p>使当前线程进入被阻塞的状态<br>即使没有其他等待运行的线程，当前线程也会等待指定的时间<br>其他等待执行的线程的机会是均等的</p>
</blockquote>
<p>yield( ) 方法 ：</p>
<blockquote>
<p>当前线程转入暂停执行的装态<br>如果没有其他等待执行的线程，当前线程就会马上恢复执行<br>会运行优先级相同或更高的线程</p>
</blockquote>

        <h4 id="练习：模拟多人爬山"   >
          <a href="#练习：模拟多人爬山" class="heading-link"><i class="fas fa-link"></i></a><a href="#练习：模拟多人爬山" class="headerlink" title="练习：模拟多人爬山"></a>练习：模拟多人爬山</h4>
      <p>需求说明 ：每个线程代表一个人，可设置每人爬山速度，每爬完100米显示信息 ，爬到终点给出相应提示。</p>
<p><strong>业务类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//模拟爬山</span><br><span class="line">public class ClimbThread extends Thread &#123;</span><br><span class="line">    //爬100米的时长(线程休眠的时长)</span><br><span class="line">    private int time;</span><br><span class="line">    //爬多少个100米</span><br><span class="line">    private  int num;</span><br><span class="line"></span><br><span class="line">    //name:年轻人/老年人  time：爬100米的时长，kilometer山的高度(千米)</span><br><span class="line">    public ClimbThread(String name,int time ,int kilometer)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.time=time;</span><br><span class="line">        this.num = kilometer*1000/100;//根据山的高度计算有多少个100米</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟爬山的过程</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(num&gt;0) &#123;</span><br><span class="line">            //模拟爬100米的过程</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;爬完了100米&quot;);</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;爬到了终点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClimbThread young  = new ClimbThread(&quot;年轻人&quot;,150,1);</span><br><span class="line">        ClimbThread old  = new ClimbThread(&quot;老年人&quot;,350,1);</span><br><span class="line">        System.out.println(&quot;****************开始爬山****************&quot;);</span><br><span class="line">        young.start();</span><br><span class="line">        old.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="多线程共享数据问题"   >
          <a href="#多线程共享数据问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程共享数据问题" class="headerlink" title="多线程共享数据问题"></a>多线程共享数据问题</h3>
      <p><strong>抢票案例</strong></p>
<p><strong>抢票类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//模拟用户购票</span><br><span class="line">public class TicketThread implements Runnable&#123;</span><br><span class="line">    private int ticket = 10;//记录车票总数</span><br><span class="line">    private int num = 0;//记录用户抢到了第几张票</span><br><span class="line"></span><br><span class="line">    //用户抢票的过程</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //没有余票，跳出循环</span><br><span class="line">            if(ticket&lt;=0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //有余票，则抢票</span><br><span class="line">            ticket--;</span><br><span class="line">            num++;</span><br><span class="line">            //模拟网络延迟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //第二步：显示出票反馈给用户</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;抢到了第&quot;+num+&quot;剩余&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//用户网络抢票</span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new TicketThread();</span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;桃票票&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;快手张&quot;);</span><br><span class="line">        Thread t3 = new Thread(runnable,&quot;黄牛党&quot;);</span><br><span class="line">        System.out.println(&quot;开始抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> <strong>效果图</strong></p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/190267/36/20836/34381/612da62dEc0ca894e/eb3feb77db150468.png" alt="20210831114628.png"></p>
<p>可以从中发现一些问题</p>
<p>1.不是从第1张票开始<br>2.存在多人抢到一张票的情况<br>3.有些票号乜有抢到<br>。。。。。。</p>
<p>这些问题可以说明：当多线程操作同一共享资源时，将引发数据不安全问题</p>

        <h3 id="线程同步"   >
          <a href="#线程同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3>
      <p>前面介绍的线程都是独立的，而且异步执行，也就是说每个线程都包含了运行时所需要的数据或方法，而不需要外部资源或方法，也不必关心其他线程的状态或行为。但是经常有一些同时运行的线程需要共享数据，此时就需要考虑其他线程的状态和行为，否则就不能保证程序运行结果的正确性。</p>
<p> 当两个或多个线程访问同一资源时，需要以某种顺序来确保该资源在某一时刻只能被一个线程使用的方式称为线程同步</p>
<p>采用同步来控制线程的执行有两种方式，即同步方法和同步代码块。这两种方式都使用 synchronized 关键字实现</p>

        <h4 id="使用-synchronized-方法"   >
          <a href="#使用-synchronized-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-synchronized-方法" class="headerlink" title="使用 synchronized 方法"></a>使用 synchronized 方法</h4>
      <p>使用 synchronized 修饰的方法控制对类成员变量的访问。每个类实例对应一把锁，方法一旦执行，就独占该锁，知道方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对应每一个实例，其所有声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。</p>
<p><strong>同步方法的语法格式如下：</strong></p>
<blockquote>
<p>访问修饰符 synchronized 返回类型 方法名{}<br>或者<br>sychronized 访问修饰符 返回类型 方法名{}</p>
</blockquote>
<p><strong>使用 synchronized 方法来解决上面的买票功能</strong></p>
<p><strong>把需要同步的代码提取出来，这里需要同步的就是买票的代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//模拟用户购票--使用 synchronized 同步方法</span><br><span class="line">public class TicketThread1 implements Runnable&#123;</span><br><span class="line">    private int ticket = 10;//记录车票总数</span><br><span class="line">    private int num = 0;//记录用户抢到了第几张票</span><br><span class="line">    boolean flag= false;//记录票是否买完</span><br><span class="line">    //用户抢票的过程</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(!flag)&#123;</span><br><span class="line">            sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sale()&#123;</span><br><span class="line">        //没有余票，跳出循环</span><br><span class="line">        if(ticket&lt;=0)&#123;</span><br><span class="line">            flag=true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //有余票，则抢票</span><br><span class="line">        ticket--;</span><br><span class="line">        num++;</span><br><span class="line">        //模拟网络延迟</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二步：显示出票反馈给用户</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;抢到了第&quot;+num+&quot;剩余&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//用户网络抢票</span><br><span class="line">public class TestThread1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new TicketThread1();</span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;桃票票&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;快手张&quot;);</span><br><span class="line">        Thread t3 = new Thread(runnable,&quot;黄牛党&quot;);</span><br><span class="line">        System.out.println(&quot;开始抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>效果图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/203240/17/3969/34896/612dc8b0Ed9da6a2b/6d419307572bbae2.png" alt="20210831141337.png"></p>

        <h4 id="使用-synchronized-代码块"   >
          <a href="#使用-synchronized-代码块" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-synchronized-代码块" class="headerlink" title="使用 synchronized 代码块"></a>使用 synchronized 代码块</h4>
      <p>代码块和方法的作用一样，语法格式如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(syncObject)&#123;</span><br><span class="line">	//需要同步访问控制的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>synchronized 块中的代码必须获得对象 syncObject 的锁才能执行，具体实现机制与同步方法一样。由于可以针对任意代码块，且可任意指定上锁对象，故灵活性较高。</p>
<p><strong>使用 synchronized 代码块修改抢票代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//模拟用户购票--使用 synchronized 同步代码块</span><br><span class="line">public class TicketThread2 implements Runnable&#123;</span><br><span class="line">    private int ticket = 10;//记录车票总数</span><br><span class="line">    private int num = 0;//记录用户抢到了第几张票</span><br><span class="line"></span><br><span class="line">    //用户抢票的过程</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (this)&#123;</span><br><span class="line">                //没有余票，跳出循环</span><br><span class="line">                if(ticket&lt;=0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //有余票，则抢票</span><br><span class="line">                ticket--;</span><br><span class="line">                num++;</span><br><span class="line">                //模拟网络延迟</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //第二步：显示出票反馈给用户</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;抢到了第&quot;+num+&quot;剩余&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//用户网络抢票</span><br><span class="line">public class TestThread2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new TicketThread2();</span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;桃票票&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;快手张&quot;);</span><br><span class="line">        Thread t3 = new Thread(runnable,&quot;黄牛党&quot;);</span><br><span class="line">        System.out.println(&quot;开始抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>效果图</strong></p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/192269/39/20949/35547/612dcae4Ecdf41bcf/f9568675b32affb0.png" alt="20210831114628.png"></p>

        <h3 id="死锁"   >
          <a href="#死锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3>
      <p>多线程在使用同步机制时，存在“死锁”的潜在危险。如果多个线程都处于等待装态而无法唤醒时，就构成了死锁（Deadlock） ，此时处于等待装态的多个线程占用系统资源，但无法运行，因此不会释放自身的资源。</p>
<p>在编程时应注意死锁问题，避免死锁的有效方法是：线程因某个条件未满足<br>而受阻，不能让其继续占有资源；如果多个对象需要互斥访问，应确定线程获得锁的顺序，并保证整个程序以相反的顺序释放锁。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://example.com">John Doe</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://example.com/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">http://example.com/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://example.com/tags/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">Java高级特性</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%97%A5%E6%9C%9F%E7%B1%BB/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Java高级特性-日期类</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8C%85%E8%A3%85%E7%B1%BB/"><span class="paginator-prev__text">Java高级特性—包装类</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">
          Java高级特性-多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">
          认识线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">
          核心级线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">
          用户级线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">
          什么是多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">
          编写线程类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          使用Thread类创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Runnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          使用Runnable接口创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Theard%E7%B1%BB%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          Theard类和Runnable接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Theard%E7%B1%BB"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">
          使用Theard类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">
          实现Runnable接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">
          线程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B0%E7%94%9F%E7%8A%B6%E6%80%81-New-Thread"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          1.新生状态(New Thread)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81-Runnable"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          2.可运行状态(Runnable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          3.阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%AD%BB%E4%BA%A1%E7%8A%B6%E6%80%81-Dead"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          4.死亡状态(Dead)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.</span> <span class="toc-text">
          线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E4%BC%91%E7%9C%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          优先级和休眠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          join( ) 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          yield( ) 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-%E6%96%B9%E6%B3%95%E5%92%8Cjoin-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.</span> <span class="toc-text">
          yield( ) 方法和join( )方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield-%E6%96%B9%E6%B3%95%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.5.</span> <span class="toc-text">
          yield( ) 方法和 sleep( )方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%A8%A1%E6%8B%9F%E5%A4%9A%E4%BA%BA%E7%88%AC%E5%B1%B1"><span class="toc-number">1.4.6.</span> <span class="toc-text">
          练习：模拟多人爬山</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">
          多线程共享数据问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.6.</span> <span class="toc-text">
          线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-synchronized-%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">
          使用 synchronized 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-synchronized-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.6.2.</span> <span class="toc-text">
          使用 synchronized 代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">
          死锁</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://img10.360buyimg.com/ddimg/jfs/t1/210672/22/780/14721/614304cbE6ed71481/b30794e20af29208.png" alt="avatar"></div><p class="sidebar-ov-author__text">生活如此美好</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">31</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>John Doe</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>