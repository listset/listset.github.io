<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayList与LinkedList的区别</title>
    <url>/2021/09/10/ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>ArrayList与LinkedList 相同点∶</strong><br>同为List实现类，元素有序、不唯一、长度可变共有Collection及List的通用方法</p>
<p><strong>ArrayList与LinkedList 不同点∶</strong><br>ArrayList实现了长度可变的数组，在内存中分配连续的空间，遍历元素和随机访问元素的效率比较高<br>LinkedList采用链表存储方式，插入、删除元素时效率比较高</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>ArrayList</tag>
        <tag>LinkedList</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS笔记(2)</title>
    <url>/2021/09/16/CSS(2)/</url>
    <content><![CDATA[
        <h2 id="CSS"   >
          <a href="#CSS" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2>
      
        <h3 id="1-超连接伪类"   >
          <a href="#1-超连接伪类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-超连接伪类" class="headerlink" title="1.超连接伪类"></a>1.超连接伪类</h3>
      <p>语法</p>
<blockquote>
<p>标签名:伪类名{声明;}</p>
</blockquote>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;超连接伪类&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</span><br><span class="line">        &lt;link href=&quot;5.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        /*访问时为橙色，访问后为紫色*/</span><br><span class="line">        p,a&#123;</span><br><span class="line">            font-size:50px;</span><br><span class="line">        &#125;</span><br><span class="line">        .ha&#123;</span><br><span class="line">	        color:violet;</span><br><span class="line">        &#125;   </span><br><span class="line">        .ha:hover&#123;</span><br><span class="line">            color:orange;</span><br><span class="line">        &#125;</span><br><span class="line">        .h2&#123;</span><br><span class="line">            color:palegoldenrod;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 未单击访问时超链接样式 */</span><br><span class="line">        .h2:link&#123;</span><br><span class="line">            color: royalblue;</span><br><span class="line">        &#125; </span><br><span class="line">        /* 单击访问后超链接样式  */</span><br><span class="line">        .h2:visited&#123;</span><br><span class="line">            color:violet;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 鼠标悬浮其上的超链接样式 */</span><br><span class="line">        .h2:hover&#123;</span><br><span class="line">            color:violet;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 鼠标单击未释放的超链接样式  */</span><br><span class="line">        .h2:active&#123;</span><br><span class="line">            color: salmon;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p class=&quot;ha&quot;&gt;这是字体演示&lt;/p&gt;</span><br><span class="line">        &lt;a href=&quot;#&quot; class=&quot;h2&quot;&gt;</span><br><span class="line">            字体演示二</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>

<p>伪类的所有属性</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">伪类名称</th>
<th align="center">含义</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a:link</td>
<td align="center">未单击访问时超链接样式</td>
<td align="center">a:link{color:#9EF5F9;}</td>
</tr>
<tr>
<td align="center">a:visited</td>
<td align="center">单击访问后超链接样式</td>
<td align="center">a:visited{color:#333;}</td>
</tr>
<tr>
<td align="center">a:hover</td>
<td align="center">鼠标悬浮其上的超链接样式</td>
<td align="center">a:hover{color:#FF7300;}</td>
</tr>
<tr>
<td align="center">a:active</td>
<td align="center">鼠标单击未释放的超链接样式</td>
<td align="center">a:active{color:#999;}</td>
</tr>
</tbody></table></div>
<p><strong>设置伪类的顺序 ：a:link -&gt; a:visited -&gt; a:hover -&gt; a:active</strong></p>

        <h3 id="2-列表样式"   >
          <a href="#2-列表样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-列表样式" class="headerlink" title="2.列表样式"></a>2.列表样式</h3>
      <p>掌握如何通过CSS设置列表样式</p>
<ul>
<li>list-style-type</li>
<li>list-style-image</li>
<li>list-style-position</li>
<li>list-style</li>
</ul>

        <h4 id="2-1-list-style-type-重点"   >
          <a href="#2-1-list-style-type-重点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-list-style-type-重点" class="headerlink" title="2.1 list-style-type 重点"></a>2.1 list-style-type 重点</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
<th align="center">语法示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">无标记符号</td>
<td align="center">list-style-type:none;</td>
</tr>
<tr>
<td align="center">disc</td>
<td align="center">实心圆，默认类型</td>
<td align="center">list-style-type:disc;</td>
</tr>
<tr>
<td align="center">circle</td>
<td align="center">空心圆</td>
<td align="center">list-style-type:circle;</td>
</tr>
<tr>
<td align="center">square</td>
<td align="center">实行正方形</td>
<td align="center">list-style-type:square;</td>
</tr>
<tr>
<td align="center">decimal</td>
<td align="center">数字</td>
<td align="center">list-style-type:decimal;</td>
</tr>
</tbody></table></div>

        <h4 id="2-2-list-style-image"   >
          <a href="#2-2-list-style-image" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-list-style-image" class="headerlink" title="2.2 list-style-image"></a>2.2 list-style-image</h4>
      <p>设置图片</p>
<p>语法</p>
<blockquote>
<p>list-style-image:url(图片地址);</p>
</blockquote>

        <h4 id="2-3-list-style-position"   >
          <a href="#2-3-list-style-position" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-list-style-position" class="headerlink" title="2.3 list-style-position"></a>2.3 list-style-position</h4>
      <p>有两个属性</p>
<blockquote>
<p>list-style-positiopn:inside：位于列表项的内侧<br>list-style-position:outside：位于列表项的外侧</p>
</blockquote>

        <h4 id="2-4-list-style"   >
          <a href="#2-4-list-style" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4-list-style" class="headerlink" title="2.4 list-style"></a>2.4 list-style</h4>
      <p>list-style-type可以简写为 list-style</p>
<p>示例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">li&#123;</span><br><span class="line">	list-style:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h3 id="3-背景样式"   >
          <a href="#3-背景样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-背景样式" class="headerlink" title="3.背景样式"></a>3.背景样式</h3>
      <ul>
<li>background-color</li>
<li>background-image</li>
<li>background-repeat</li>
<li>background-position</li>
<li>background</li>
</ul>
<p> background-color 设置背景颜色</p>
<p> background-image:url(图片路径);  设置背景图片</p>
<ul>
<li>背景重复方式<ul>
<li>background-repeat属性<ul>
<li>repeat ：沿水平线和垂直两个方向平铺</li>
<li>no-repeat ：bupingpu，只显示一次</li>
<li>repeat-x ：只沿水平方向平铺</li>
<li>repeat-y ：只沿垂直方向平铺</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>背景定位<br>background-position属性</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Xpos Ypos</td>
<td align="center">单位:px;Xpos表示水平位置，Ypos表示垂直位置</td>
</tr>
<tr>
<td align="center">X% Y%</td>
<td align="center">使用百分比表示背景的位置</td>
</tr>
<tr>
<td align="center">X、Y方向关键字</td>
<td align="center">水平方向的关键词：left、center、right ; 垂直方向的关键词 : top、center、bottom</td>
</tr>
</tbody></table></div>
<p><strong>综合案例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;超连接伪类&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</span><br><span class="line">        &lt;link href=&quot;5.style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #nav&#123;</span><br><span class="line">            width: 230px;</span><br><span class="line">            background-color: #D7D7D7;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        .title&#123;</span><br><span class="line">            font-size: 18px;</span><br><span class="line">            font-weight: bold;</span><br><span class="line">            text-indent: 1em;</span><br><span class="line">            line-height: 35px;</span><br><span class="line">          </span><br><span class="line">            color: #FFF;</span><br><span class="line">            /* </span><br><span class="line">            两种写法</span><br><span class="line">            background-color: #C00;</span><br><span class="line">            background-image: url(image/arrow-down.gif);</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">            background-position: right,center; </span><br><span class="line">            */</span><br><span class="line">            background: #C00 url(image/arrow-down.gif) right center no-repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        ul li&#123;</span><br><span class="line">            height: 30px;</span><br><span class="line">            line-height: 25px;</span><br><span class="line">            text-indent: 1em;</span><br><span class="line">            list-style: none;</span><br><span class="line">            background: url(image/arrow-right.gif) right center no-repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        a&#123;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">        color: #000;</span><br><span class="line">        &#125;</span><br><span class="line">        a:hover&#123;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        color: darkcyan;</span><br><span class="line">        text-decoration: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">            &lt;h2 class=&quot;title&quot;&gt;全部商品分类&lt;/h2&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;图书&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;音响&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;数字商品&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;家用电器&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;手机&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;数码&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;电脑&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;办公&lt;/a&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;家具&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;家装&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;厨具&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服饰鞋帽&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;个护化妆&lt;/a&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;礼品箱包&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;钟表&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;珠宝&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;彩票&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;旅行&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#&quot;&gt;充值&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>



        <h3 id="4-盒子模型"   >
          <a href="#4-盒子模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-盒子模型" class="headerlink" title="4.盒子模型"></a>4.盒子模型</h3>
      <p>盒模型本质上是一个盒子，封装周围的HTML元素</p>
<p>它包括：外边距，边框，填充，和实际内容</p>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/59364/40/17518/58351/61415b44E3a888988/37f94bf05efcbe10.png" alt="20210915103220.png"></p>

        <h4 id="4-1-边框颜色-—-border-color"   >
          <a href="#4-1-边框颜色-—-border-color" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-边框颜色-—-border-color" class="headerlink" title="4.1 边框颜色 — border-color"></a>4.1 边框颜色 — border-color</h4>
      <p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/89641/7/18719/100685/614165b7Ec6492cd2/934e8312c50fc04f.png" alt="QQ浏览器截图20210915111655.png"></p>

        <h4 id="4-2-边框粗细-—-border-with"   >
          <a href="#4-2-边框粗细-—-border-with" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-边框粗细-—-border-with" class="headerlink" title="4.2 边框粗细 — border-with"></a>4.2 边框粗细 — border-with</h4>
      <p>border-width：取值</p>
<ul>
<li>thin</li>
<li>medium</li>
<li>thick</li>
<li><font color="red">像素值</font></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">border-top-width:5px;</span><br><span class="line">border-right-width:10px;</span><br><span class="line">border-bottom-width:8px;</span><br><span class="line">border-left-width:22px;</span><br><span class="line">border-width:22px;</span><br><span class="line">border-width:22px 2px;</span><br><span class="line">border-width:22px 6px 23px;</span><br><span class="line">border-width:2px 2px 4px 5px;</span><br></pre></td></tr></table></div></figure>

<p>同时设置边框的颜色、粗细和样式</p>
<blockquote>
<p>border:1px solid #3A6587;</p>
</blockquote>

        <h4 id="4-3-边框样式-—-border-style"   >
          <a href="#4-3-边框样式-—-border-style" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3-边框样式-—-border-style" class="headerlink" title="4.3 边框样式 — border-style"></a>4.3 边框样式 — border-style</h4>
      <ul>
<li>none</li>
<li>dotted 点线</li>
<li><font color="red">dashed 虚线</font></li>
<li><font color="red">solid 实线</font></li>
<li>double 两个边框</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">#name&#123;</span><br><span class="line">    border:3px solid black;</span><br><span class="line"> &#125;</span><br><span class="line">#email&#123;</span><br><span class="line">    border:1px dashed red;</span><br><span class="line">&#125;</span><br><span class="line">#tel&#123;</span><br><span class="line">    border:1px dotted blue; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="4-3-外边距—-margin"   >
          <a href="#4-3-外边距—-margin" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3-外边距—-margin" class="headerlink" title="4.3 外边距— margin"></a>4.3 外边距— margin</h4>
      <p>margin</p>
<ul>
<li>margin-top</li>
<li>margin-right</li>
<li>margin-bottom</li>
<li>margin-left</li>
<li>margin</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">margin-top:1px;</span><br><span class="line">margin-right:2px;</span><br><span class="line">margin-bottom:2px</span><br><span class="line">margin-left:1px</span><br><span class="line">margin:3px 5px 5px 7px;</span><br><span class="line">margin:3px 5px;</span><br><span class="line">margin:3px 4px 7px;</span><br><span class="line">margin:9px;</span><br></pre></td></tr></table></div></figure>



        <h4 id="4-4-内边距—-pading"   >
          <a href="#4-4-内边距—-pading" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-4-内边距—-pading" class="headerlink" title="4.4 内边距— pading"></a>4.4 内边距— pading</h4>
      <p>pading</p>
<ul>
<li>pading-top</li>
<li>pading-right</li>
<li>pading-bottom</li>
<li>pading-left</li>
<li>pading</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">pading-top:1px;</span><br><span class="line">pading-right:2px;</span><br><span class="line">pading-bottom:2px</span><br><span class="line">pading-left:1px</span><br><span class="line">pading:3px 5px 5px 7px;</span><br><span class="line">pading:3px 5px;</span><br><span class="line">pading:3px 4px 7px;</span><br><span class="line">pading:9px;</span><br></pre></td></tr></table></div></figure>



        <h4 id="4-5-网页布局结构"   >
          <a href="#4-5-网页布局结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-5-网页布局结构" class="headerlink" title="4.5 网页布局结构"></a>4.5 网页布局结构</h4>
      <ul>
<li>上下结构</li>
<li>上中下结构</li>
<li>上左右下结构：1-2-1结构</li>
<li>上左中右下结构：1-3-1结构</li>
</ul>
<p><strong>上下结构示意图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/199788/40/8475/17759/61416eadEc21bbf92/3cbbd96260920e22.png" alt="20210915115508.png"></p>
<p><strong>上中下结构示意图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/89805/12/17334/8159/61416fd8E1830e4a2/8bfb4a9f953f2ccf.png" alt="20210915120012.png"></p>
<p><strong>上左右下结构：1-2-1结构</strong></p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/70814/38/17057/8163/6141928aE630ddaaf/42b719ff7c517326.png" alt="20210915142522.png"></p>
<p><strong>上左中右下结构：1-3-1结构</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/92874/16/19316/9004/6141930dEdc9d55ac/84fc1bc48e4c9ef3.png" alt="20210915142950.png"></p>

        <h3 id="5-浮动"   >
          <a href="#5-浮动" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-浮动" class="headerlink" title="5. 浮动"></a>5. 浮动</h3>
      <p><code>&lt;div&gt;</code>为块级元素，独占一行，那怎么实现上中下（1-2-1）结构和（1-3-1）结构</p>
<p>这时就用到了浮动</p>
<p>float- 浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次</p>
<p>一个浮动元素会尽量想做或向右动，直到它的边缘碰到包含框或了另一个浮动框的边框为止</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">left</td>
<td align="center">元素向左浮动</td>
</tr>
<tr>
<td align="center">right</td>
<td align="center">元素向右浮动</td>
</tr>
<tr>
<td align="center">none</td>
<td align="center">默认值，元素不浮动</td>
</tr>
</tbody></table></div>
<p>添加浮动元素后，浮动元素周围的元素重新排列，如何避免？</p>
<ul>
<li>浮动元素之后的元素将围绕它(文本围绕div)</li>
<li>使用clear ：clear属性可以清除浮动对其元素造成的影响</li>
</ul>
<p>clear属性</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">left</td>
<td align="center">在左侧不允许浮动元素</td>
</tr>
<tr>
<td align="center">right</td>
<td align="center">在右侧不允许浮动元素</td>
</tr>
<tr>
<td align="center">both</td>
<td align="center">在左、右侧不允许浮动元素</td>
</tr>
<tr>
<td align="center">none</td>
<td align="center">默认值，允许浮动元素出现在两侧</td>
</tr>
</tbody></table></div>

        <h3 id="6-父级边框塌陷解决"   >
          <a href="#6-父级边框塌陷解决" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-父级边框塌陷解决" class="headerlink" title="6. 父级边框塌陷解决"></a>6. 父级边框塌陷解决</h3>
      <ul>
<li>解决父元素的高度</li>
<li>浮动元素后添加空白 div ,给div设置clear属性</li>
<li>父级添加位列after</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">.clear:after&#123;</span><br><span class="line">	content:&quot;&quot;; /*在clear类后面添加内容为空*/</span><br><span class="line">	display:block; /*把添加的内容转化为块元素*/</span><br><span class="line">	clear:both; /*清除这个元素两边的浮动*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>父级添加 overflow 属性 hidden</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">visible</td>
<td align="center">默认值。内容不会被修剪，会呈现在盒子之外</td>
</tr>
<tr>
<td align="center">hidden</td>
<td align="center">内容会被修剪，并且其余内容是不可见的</td>
</tr>
<tr>
<td align="center">scroll</td>
<td align="center">内容会被修剪，但是浏览器会显示滚动条以便查看其余内容</td>
</tr>
<tr>
<td align="center">auto</td>
<td align="center">如果内容被修改，则浏览器会显示滚动条以便查看其余的内容</td>
</tr>
</tbody></table></div>

        <h3 id="7-定位"   >
          <a href="#7-定位" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-定位" class="headerlink" title="7. 定位"></a>7. 定位</h3>
      <p>position属性</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static</td>
<td align="center">默认值，没有定位</td>
</tr>
<tr>
<td align="center">relative</td>
<td align="center">相对定位</td>
</tr>
<tr>
<td align="center">absolute</td>
<td align="center">绝对定位</td>
</tr>
<tr>
<td align="center">fixed</td>
<td align="center">固定定位</td>
</tr>
</tbody></table></div>

        <h4 id="7-1-默认定位—-position-static"   >
          <a href="#7-1-默认定位—-position-static" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-默认定位—-position-static" class="headerlink" title="7.1 默认定位—-position:static"></a>7.1 默认定位—-position:static</h4>
      <p>默认定位不会对元素进行改变</p>

        <h4 id="7-2-相对定位—-position-relative"   >
          <a href="#7-2-相对定位—-position-relative" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-相对定位—-position-relative" class="headerlink" title="7.2 相对定位—-position:relative"></a>7.2 相对定位—-position:relative</h4>
      <p>相对于自身原来的位置进行偏移<br>偏移设置：top、left、right、bottom</p>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">#third&#123;</span><br><span class="line">	background-color:#C5DECC;</span><br><span class="line">	border:1px dashed #395E4F;</span><br><span class="line">	position:relative;</span><br><span class="line">	left:20px;</span><br><span class="line">	top:30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>left和top取值</strong></p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/109177/16/16529/78460/6142b00eE87a2d335/5ca36c0af7b1d12e.png" alt="20210916104622.png"></p>
<p>相对定位特性</p>
<ul>
<li>相对于自己的初始位置来定位</li>
<li>元素位置发生偏移后，他原来的位置会别保留下来</li>
<li>层级提高，可以把标准文档流中的元素及浮动元素盖在下边</li>
</ul>
<p>相对定位使用场景</p>
<ul>
<li>相对定位一般情况下很少自己单独使用，都是配合绝对定位使用，为绝对定位创建造定位父级而又不设置偏移量</li>
</ul>

        <h4 id="7-3-绝对定位—-position-absolute"   >
          <a href="#7-3-绝对定位—-position-absolute" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-绝对定位—-position-absolute" class="headerlink" title="7.3 绝对定位—-position:absolute"></a>7.3 绝对定位—-position:absolute</h4>
      <p>设置了绝对定位但没有设置为偏移量的元素将保持在原来的位置<br>在网页制作中可以用于需要使某个有元素脱离标准流，而仍然希望它保持在原来的位置的情况</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">#third&#123;</span><br><span class="line">	background-color:#C5DECC;</span><br><span class="line">	border:1px dashed #395E4F;</span><br><span class="line">	position:absolute;</span><br><span class="line">	left:20px;</span><br><span class="line">	top:30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>absolute和relative的偏移量设置一样</strong></p>
<p>绝对定位是相对于绝对定位元素的定位父级的位置来定位，如果没有定义父级，那么绝对定位会浏览器窗口为父类 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">#father&#123;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    padding: 0;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">#first&#123;</span><br><span class="line">    background-color: #F2BB6F;</span><br><span class="line">    border: 1px dashed #4CB8E7;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50px;</span><br><span class="line">    top:30px;          </span><br></pre></td></tr></table></div></figure>

<p><strong>绝对定位特性</strong></p>
<ul>
<li>绝对定位是相对于它的定位父级的位置来定位，如果没有设置定位父级，则相对浏览器窗口来定位</li>
<li>元素位置发生偏移后，原来的位置不会被保留</li>
<li>层次提高，可以把标准文档流中的元素及浮动元素盖在下边</li>
<li>设置绝对定位的元素脱离文档流</li>
</ul>
<p><strong>绝对定位的使用场景</strong></p>
<ul>
<li>一般情况下，绝对定位用在下拉菜单、焦点图轮播、弹出数据气泡、特别花边等场景</li>
</ul>

        <h4 id="7-4-固定定位—-position-fixed"   >
          <a href="#7-4-固定定位—-position-fixed" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-4-固定定位—-position-fixed" class="headerlink" title="7.4 固定定位—-position:fixed"></a>7.4 固定定位—-position:fixed</h4>
      <p><strong>fixed和relative的偏移量设置一样</strong>，类似绝对定位，不过区别在于定位的基准不是祖先元素，而是浏览器窗口</p>
<p>固定定位特性</p>
<ul>
<li>相对浏览器窗口来定位</li>
<li>偏移量不会随滚动条的移动而移动</li>
</ul>
<p>固定定位的使用场景</p>
<ul>
<li>一般在网页中被用在窗口左右两边的固定广告、返回顶部图标、吸顶导航栏等</li>
</ul>

        <h3 id="8-z-index属性"   >
          <a href="#8-z-index属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-z-index属性" class="headerlink" title="8. z-index属性"></a>8. z-index属性</h3>
      <ul>
<li>调整元素定位时重叠层的上下位置<ul>
<li>设置了position属性时，z-index属性可以设置个元素之间的重叠高低关系</li>
<li>z-index 属性值：增整数，默认值为 0 </li>
<li>z-index 值大的层位于其值小的层上方</li>
</ul>
</li>
</ul>

        <h3 id="9-制作带按钮的轮播广告"   >
          <a href="#9-制作带按钮的轮播广告" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-制作带按钮的轮播广告" class="headerlink" title="9. 制作带按钮的轮播广告"></a>9. 制作带按钮的轮播广告</h3>
      <p>需求说明：综合使用CSS字体、文本、列表、背景、浮动、定位等样式实现有图带按钮的轮播广告效果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;轮播广告&lt;/title&gt;</span><br><span class="line">  &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    #content&#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 1px solid orange;</span><br><span class="line">        margin: auto;</span><br><span class="line">        background-image: url(image/scenery.jpg) ;</span><br><span class="line">        background-size: 100% 100%;</span><br><span class="line">        background-repeat: no-repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&#123;</span><br><span class="line">        list-style: none;      </span><br><span class="line">        margin-left:190px;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    li&#123;</span><br><span class="line">        display: block;</span><br><span class="line">        width: 20px;</span><br><span class="line">        height: 20px;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">        margin-top: 150px;</span><br><span class="line">        margin-left: 10px;</span><br><span class="line">        float: left;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: 1px solid rgba(207, 47, 47, 0.5);</span><br><span class="line">        background-color: rgba(207, 47, 47, 0.5);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS(1)</title>
    <url>/2021/09/14/CSS(1)/</url>
    <content><![CDATA[
        <h2 id="CSS"   >
          <a href="#CSS" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2>
      
        <h3 id="1-认识CSS"   >
          <a href="#1-认识CSS" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-认识CSS" class="headerlink" title="1.认识CSS"></a>1.认识CSS</h3>
      
        <h4 id="1-1了解-span-和-div-标签"   >
          <a href="#1-1了解-span-和-div-标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1了解-span-和-div-标签" class="headerlink" title="1.1了解 span 和 div 标签"></a>1.1了解 span 和 div 标签</h4>
      <p>span和div都可以作为容器</p>
<p><strong>span 标签</strong></p>
<p>使用举例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;span&gt;提示:&lt;/span&gt;请注意操作合法性。&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>

<p>作用：可用作文本的容器，能让某几个文字或者某某个词语凸显出来。是行内元素</p>
<p><strong>div 标签</strong></p>
<p>使用举例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;网页内容......&lt;/div&gt;</span><br></pre></td></tr></table></div></figure>

<p>作用：可以把文档分割为独立的、不同的部分，排版网页内容，网页布局。是块级元素</p>

        <h4 id="1-2-CSS的概念"   >
          <a href="#1-2-CSS的概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-CSS的概念" class="headerlink" title="1.2 CSS的概念"></a>1.2 CSS的概念</h4>
      <ul>
<li><font color="red">C</font>ascading <font color="red">S</font>tyle <font color="red">S</font>heet  级联样式表</li>
<li>表现HTML文件样式的计算机语言<ul>
<li> 样式定义如何显示HTML元素</li>
<li> 包括对字体、颜色、边距、高度、宽度、背景图片、网页定位等设定</li>
</ul>
</li>
</ul>

        <h4 id="1-3-CSS的优势"   >
          <a href="#1-3-CSS的优势" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-CSS的优势" class="headerlink" title="1.3 CSS的优势"></a>1.3 CSS的优势</h4>
      <ul>
<li>内容与表现分离</li>
<li>网页的表现统一，容易修改</li>
<li>丰富的样式，是的页面布局更加灵活</li>
<li>减少网页的代码量，增加网页的浏览速度，节省网络宽带</li>
<li>运用独立于页面的CSS，有利于网页被搜索引擎收录 </li>
</ul>

        <h4 id="1-4-CSS基本语法"   >
          <a href="#1-4-CSS基本语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-CSS基本语法" class="headerlink" title="1.4 CSS基本语法"></a>1.4 CSS基本语法</h4>
      <p><strong>语法</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">选择器&#123;</span><br><span class="line">	声明1；</span><br><span class="line">	声明2;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">span&#123;</span><br><span class="line">	font-size:12px;</span><br><span class="line">	color:#F00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>CSS语法以冒号分隔，冒号前面的称为属性，后面的称为值</p>
<p>CSS的最后一条声明后的 “;” 可写可不写，但是，基于W3C标准规范考虑，建议最后一条声明的结束 “;” 都要写上</p>

        <h4 id="1-5-引入CSS样式的三种方式"   >
          <a href="#1-5-引入CSS样式的三种方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-引入CSS样式的三种方式" class="headerlink" title="1.5 引入CSS样式的三种方式"></a>1.5 引入CSS样式的三种方式</h4>
      <p>引入CSS有三种样式，分别是</p>
<p>外部样式表(External style sheet)<br>内部样式表(Internal style sheet)<br>内联样式(Inline style)</p>
<p>下面来一一介绍</p>

        <h5 id="1-5-1-内部样式表-Internal-style-sheet"   >
          <a href="#1-5-1-内部样式表-Internal-style-sheet" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-1-内部样式表-Internal-style-sheet" class="headerlink" title="1.5.1 内部样式表(Internal style sheet)"></a>1.5.1 内部样式表(Internal style sheet)</h5>
      <p>当单个文档需要特殊的样式时，就应该使用内部样式表。你可以使用 <style> 标签在文档头部定义内部样式表，就像这样:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;style&gt;</span><br><span class="line">		hr &#123;color:sienna;&#125;</span><br><span class="line">		p &#123;margin-left:20px;&#125;</span><br><span class="line">		body &#123;background-image:url(&quot;images/back40.gif&quot;);&#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="1-5-2-外部样式表-External-style-sheet"   >
          <a href="#1-5-2-外部样式表-External-style-sheet" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-2-外部样式表-External-style-sheet" class="headerlink" title="1.5.2 外部样式表(External style sheet)"></a>1.5.2 外部样式表(External style sheet)</h5>
      <p>当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用<code> &lt;link&gt;</code> 标签链接到样式表。 <code>&lt;link&gt;</code> 标签在（文档的）头部：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></div></figure>
<p>浏览器会从文件 mystyle.css 中读到样式声明，并根据它来格式文档。<br>外部样式表可以在任何文本编辑器中进行编辑。文件不能包含任何的 html 标签。样式表应该以 .css 扩展名进行保存。下面是一个样式表文件的例子：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">hr &#123;color:sienna;&#125;</span><br><span class="line">p &#123;margin-left:20px;&#125;</span><br><span class="line">body &#123;background-image:url(&quot;/images/back40.gif&quot;);&#125;</span><br></pre></td></tr></table></div></figure>

        <h5 id="1-5-3-内联样式-Inline-style"   >
          <a href="#1-5-3-内联样式-Inline-style" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-3-内联样式-Inline-style" class="headerlink" title="1.5.3 内联样式(Inline style)"></a>1.5.3 内联样式(Inline style)</h5>
      <p>由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法，例如当样式仅需要在一个元素上应用一次时。</p>
<p>要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style 属性可以包含任何 CSS 属性。本例展示如何改变段落的颜色和左外边距：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>


        <h5 id="1-5-4-多重样式"   >
          <a href="#1-5-4-多重样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-4-多重样式" class="headerlink" title="1.5.4 多重样式"></a>1.5.4 多重样式</h5>
      <p>如果某些属性在不同的样式表中被同样的选择器定义，那么属性值将从更具体的样式表中被继承过来。 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">h1</span><br><span class="line">&#123;</span><br><span class="line">    color:blue;</span><br><span class="line">    text-align:left;</span><br><span class="line">    font-size:8px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>而内部样式表拥有针对 h1 选择器的两个属性：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">h1</span><br><span class="line">&#123;</span><br><span class="line">    text-align:right;</span><br><span class="line">    font-size:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>假如拥有内部样式表的这个页面同时与外部样式表链接，那么 h1 得到的样式是：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">color:bllue;</span><br><span class="line">text-align:lewft;</span><br><span class="line">font-size:20px;</span><br></pre></td></tr></table></div></figure>

<p>即颜色属性将被继承于外部样式表，而文字排列（text-alignment）和字体尺寸（font-size）会被内部样式表中的规则取代。</p>

        <h5 id="1-5-5-多重样式优先级"   >
          <a href="#1-5-5-多重样式优先级" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-5-5-多重样式优先级" class="headerlink" title="1.5.5 多重样式优先级"></a>1.5.5 多重样式优先级</h5>
      <p>样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。</p>
<p>一般情况下，优先级如下：</p>
<p><strong>（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;!-- 外部样式 style.css --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt;</span><br><span class="line">    &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      /* 内部样式 */</span><br><span class="line">      h3&#123;color:green;&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;测试!&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></div></figure>

<p><strong>如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。</strong></p>

        <h3 id="2-行内元素和块级元素的转换"   >
          <a href="#2-行内元素和块级元素的转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-行内元素和块级元素的转换" class="headerlink" title="2.行内元素和块级元素的转换"></a>2.行内元素和块级元素的转换</h3>
      <ul>
<li>display ：CSS属性<ul>
<li>控制元素的显示和隐藏</li>
<li>块级元素与行内元素的转变</li>
</ul>
</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">display值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">设置元素不会被显示</td>
</tr>
<tr>
<td align="center">inline</td>
<td align="center">元素会别显示为内联(行内)元素</td>
</tr>
<tr>
<td align="center">block</td>
<td align="center">元素会被显示为块级元素</td>
</tr>
<tr>
<td align="center">inline-block</td>
<td align="center">行内块元素</td>
</tr>
</tbody></table></div>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;链接标签&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            /*添加CSS样式：span凸显出来*/</span><br><span class="line">            span&#123;</span><br><span class="line">                /* 字体 颜色*/</span><br><span class="line">                font-size: 25px;</span><br><span class="line">                color: red;</span><br><span class="line">                /*隐藏span*/</span><br><span class="line">                display:none;</span><br><span class="line">                /* span行内元素转换为块级元素 */</span><br><span class="line">                display: block;</span><br><span class="line">                /* span转换为行内块元素 */</span><br><span class="line">                /* 行内块元素：可以设置宽高 */</span><br><span class="line">                display: inline-block;</span><br><span class="line">            &#125;</span><br><span class="line">            div&#123;</span><br><span class="line">                /* div由块元素转换为行内元素 */</span><br><span class="line">                display: inline;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">       &lt;span&gt;第一个span&lt;/span&gt;</span><br><span class="line">       &lt;span&gt;第二个span&lt;/span&gt;</span><br><span class="line">       &lt;p&gt;欢迎访问网站，您好，请登录，&lt;span&gt;免费注册&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">       &lt;div&gt;第一个div&lt;/div&gt;</span><br><span class="line">       &lt;div&gt;第二个div&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>借助display属性可转换行内及块元素<ul>
<li>block 和 none：二级菜单住展示、TAB切换、焦点图轮播</li>
<li>inline 和 inlinne-block：使用列表制作横向导航、菜单等</li>
</ul>
</li>
</ul>

        <h3 id="3-CSS基本选择器"   >
          <a href="#3-CSS基本选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-CSS基本选择器" class="headerlink" title="3.CSS基本选择器"></a>3.CSS基本选择器</h3>
      <p>选择器有三种，分别为：</p>
<ul>
<li>标签选择器</li>
<li>类选择器</li>
<li>ID选择器</li>
</ul>

        <h4 id="3-1-标签选择器"   >
          <a href="#3-1-标签选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-标签选择器" class="headerlink" title="3.1 标签选择器"></a>3.1 标签选择器</h4>
      <p>HTML标签作为标签选择器的名称<br>如：<code>&lt;h1&gt;...&lt;h6&gt;</code>、<code>p</code>、<code>&lt;img/&gt;</code></p>
<p>示例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">	font-size:16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/206695/25/674/97344/613ffe25E3e8ccf08/b53e9c256585595a.png" alt="20210914094226.png"></p>
<p>所有相同名字的标签都会被更改</p>

        <h4 id="3-2-类选择器"   >
          <a href="#3-2-类选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-类选择器" class="headerlink" title="3.2 类选择器"></a>3.2 类选择器</h4>
      <p>类选择器就是给标签设置一个 class 属性，然后通过 .class的类名称也就是 h1 来进行属性的赋值</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">.h1&#123;</span><br><span class="line">	color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;h1 class=&quot;h1&quot;&gt;这是h1&lt;/h1&gt;</span><br></pre></td></tr></table></div></figure>

<p>不同标签可以使用同一个样式</p>

        <h4 id="3-3-ID选择器"   >
          <a href="#3-3-ID选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-ID选择器" class="headerlink" title="3.3 ID选择器"></a>3.3 ID选择器</h4>
      <p>id选择器不以  <strong>.</strong> 开头，而是以 # 开头，和类选择器使用一样</p>
<p>每个ID是唯一的声明 id 只能声明一次</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#h1&#123;</span><br><span class="line">	color:yellow;</span><br><span class="line">&#125;</span><br><span class="line">&lt;h1 id=&quot;h1&quot;&gt;这是h1&lt;/h1&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3-4-选择器优先级"   >
          <a href="#3-4-选择器优先级" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-选择器优先级" class="headerlink" title="3.4 选择器优先级"></a>3.4 选择器优先级</h4>
      <p>ID选择器 &gt; 类选择器 &gt; 标签选择器</p>

        <h3 id="4-CSS高级选择器"   >
          <a href="#4-CSS高级选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-CSS高级选择器" class="headerlink" title="4.CSS高级选择器"></a>4.CSS高级选择器</h3>
      
        <h4 id="4-1-CSS层次选择器"   >
          <a href="#4-1-CSS层次选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-CSS层次选择器" class="headerlink" title="4.1 CSS层次选择器"></a>4.1 CSS层次选择器</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">选择器</th>
<th align="center">类型</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E F</td>
<td align="center"><font color="red">后代</font>选择器</td>
<td align="center">选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内</td>
</tr>
<tr>
<td align="center">E&gt;F</td>
<td align="center"><font color="red">子</font>选择器</td>
<td align="center">选择匹配的F元素，且匹配的F元素是匹配的E元素的子元素</td>
</tr>
<tr>
<td align="center">E+F</td>
<td align="center">相邻<font color="red">兄弟</font>选择器</td>
<td align="center">选择匹配的F元素，且匹配的F元素仅位于匹配的E元素后面</td>
</tr>
<tr>
<td align="center">E~F</td>
<td align="center">通用<font color="red">兄弟</font>选择器</td>
<td align="center">选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素</td>
</tr>
</tbody></table></div>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;CSS高级选择器&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</span><br><span class="line">        &lt;link href=&quot;#&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            /* CSS高级选择器--层次选择器 */</span><br><span class="line">            /* 后代选择器 */</span><br><span class="line">            /* body p&#123;</span><br><span class="line">                background-color: red;</span><br><span class="line">            &#125;*/</span><br><span class="line">             /* 子选择器 */</span><br><span class="line">             /* body&gt;p&#123;</span><br><span class="line">                background-color: red;</span><br><span class="line">             &#125; */</span><br><span class="line">             /* 相邻兄弟选择器 */</span><br><span class="line">             /* .two+p&#123;</span><br><span class="line">                background-color: red;</span><br><span class="line">             &#125; */</span><br><span class="line">              /* 通用兄弟选择器 */</span><br><span class="line">              .two~p&#123;</span><br><span class="line">                background-color: red;</span><br><span class="line">             &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">       &lt;p id=&quot;one&quot;&gt;1&lt;/p&gt;</span><br><span class="line">       &lt;div class=&quot;two&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">       &lt;p&gt;3&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;four&quot;&gt;4&lt;/p&gt;</span><br><span class="line">       &lt;div&gt;&lt;p&gt;5&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">       &lt;p id=&quot;six&quot;&gt;6&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;seven&quot;&gt;7&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;eight&quot;&gt;8&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;nine&quot;&gt;9&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="4-2-CSS属性选择器"   >
          <a href="#4-2-CSS属性选择器" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-CSS属性选择器" class="headerlink" title="4.2 CSS属性选择器"></a>4.2 CSS属性选择器</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">属性选择器</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E[attr]</td>
<td align="center">选择匹配具有属性attr的E元素</td>
</tr>
<tr>
<td align="center">E[attr=val]</td>
<td align="center">选择匹配具有属性attr的E元素,并且属性值为val（其中val区分大小写）</td>
</tr>
<tr>
<td align="center">E[attr^=val]</td>
<td align="center">选择匹配元素E，且E元素定义了属性attr，其属性值是以val开头的任意字符串</td>
</tr>
<tr>
<td align="center">E[attr$=val]</td>
<td align="center">选择匹配元素E，且E元素定义了属性attr，其属性值是以val结尾的任意字符串</td>
</tr>
<tr>
<td align="center">E[attr*=val]</td>
<td align="center">选择匹配元素E，且E元素定义了属性attr，其属性值包含了“val”，换句话说，字符串val与属性值中的任意位置相匹配</td>
</tr>
</tbody></table></div>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;CSS高级选择器&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</span><br><span class="line">        &lt;link href=&quot;#&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">             /* CSS高级选择器--属性选择器 */</span><br><span class="line">             /* p[id]&#123;</span><br><span class="line">                 background-color: red;</span><br><span class="line">             &#125; */</span><br><span class="line"></span><br><span class="line">             /*取值区分大小*/ </span><br><span class="line">             /*p[id=seven]&#123;</span><br><span class="line">                 background-color: red;</span><br><span class="line">             &#125;*/</span><br><span class="line">             /* p[id^=s]&#123;</span><br><span class="line">                 background-color: red;</span><br><span class="line">             &#125; */</span><br><span class="line"></span><br><span class="line">             /* p[id$=t]&#123;</span><br><span class="line">                 background-color: red;</span><br><span class="line">             &#125; */</span><br><span class="line">             p[id*=e]&#123;</span><br><span class="line">                 background-color: red;</span><br><span class="line">             &#125;</span><br><span class="line">           </span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">       &lt;p id=&quot;one&quot;&gt;1&lt;/p&gt;</span><br><span class="line">       &lt;div class=&quot;two&quot;&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">       &lt;p&gt;3&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;four&quot;&gt;4&lt;/p&gt;</span><br><span class="line">       &lt;div&gt;&lt;p&gt;5&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">       &lt;p id=&quot;six&quot;&gt;6&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;seven&quot;&gt;7&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;eight&quot;&gt;8&lt;/p&gt;</span><br><span class="line">       &lt;p id=&quot;nine&quot;&gt;9&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></div></figure>


        <h3 id="5-CSS字体样式"   >
          <a href="#5-CSS字体样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-CSS字体样式" class="headerlink" title="5.CSS字体样式"></a>5.CSS字体样式</h3>
      <p>CSS样式常用属性</p>

        <h4 id="font-family属性"   >
          <a href="#font-family属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#font-family属性" class="headerlink" title="font-family属性"></a>font-family属性</h4>
      <p><strong>示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">	font-family:Verdanna,&quot;楷体&quot;;</span><br><span class="line">&#125;</span><br><span class="line">body&#123;</span><br><span class="line">	font-family:Times,&quot;Times New Roman&quot;,&quot;楷体&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>body的示例中，font-family可以写多个字体类型，通过逗号(,)分割，如果有第一个字体样式就使用第一个，如果没有就会往后去找，中文的字体类型要用引号引起来，</p>

        <h4 id="font-size属性"   >
          <a href="#font-size属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#font-size属性" class="headerlink" title="font-size属性"></a>font-size属性</h4>
      <p><strong>设置字体大小</strong></p>
<p>常用单位：em、px（像素）</p>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">h1&#123;</span><br><span class="line">	font-size:24px;</span><br><span class="line">&#125;</span><br><span class="line">h2&#123;</span><br><span class="line">	font-size:116px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>默认的一个网页中字体为 16 像素</p>

        <h4 id="font-style属性"   >
          <a href="#font-style属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#font-style属性" class="headerlink" title="font-style属性"></a>font-style属性</h4>
      <p>有三个取值</p>
<ul>
<li>normal：文本正常显示</li>
<li>italic：文本斜体显示</li>
<li>oblique：文本斜体现显示</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">.p1&#123;</span><br><span class="line">	font-style:normal;</span><br><span class="line">&#125;</span><br><span class="line">.p2&#123;</span><br><span class="line">	font-style:italic;</span><br><span class="line">&#125;</span><br><span class="line">.p3&#123;</span><br><span class="line">	font-style:oblique;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p class=&quot;p1&quot;&gt;第一段文字&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;p2&quot;&gt;第二段文字&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;p3&quot;&gt;第二段文字&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="font-weight属性"   >
          <a href="#font-weight属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#font-weight属性" class="headerlink" title="font-weight属性"></a>font-weight属性</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">normal</td>
<td align="center">默认值，定义标准的字体</td>
</tr>
<tr>
<td align="center"><font color="red">bold</font></td>
<td align="center">粗体字体</td>
</tr>
<tr>
<td align="center">bolder</td>
<td align="center">更粗的字体</td>
</tr>
<tr>
<td align="center">lighter</td>
<td align="center">更细的字体</td>
</tr>
<tr>
<td align="center">100、200、300、400</td>
<td align="center">定义由细到粗的字体 400 等同于normal,700等同于bold</td>
</tr>
</tbody></table></div>

        <h4 id="font-属性"   >
          <a href="#font-属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#font-属性" class="headerlink" title="font 属性"></a>font 属性</h4>
      <p>字体属性可以和在一起</p>
<p>字体属性的顺序：字体风格 -&gt; 字体粗细 -&gt; 字体大小 -&gt; 字体类型</p>
<p>示例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">p span&#123;</span><br><span class="line">	font:oblique bold 12px &quot;楷体&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="6-CSS文本样式"   >
          <a href="#6-CSS文本样式" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-CSS文本样式" class="headerlink" title="6.CSS文本样式"></a>6.CSS文本样式</h3>
      
        <h4 id="6-1-color属性"   >
          <a href="#6-1-color属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1-color属性" class="headerlink" title="6.1 color属性"></a>6.1 color属性</h4>
      <ul>
<li>颜色名称</li>
<li>十六进制<ul>
<li>十六进制方法表示颜色 ：前两位表示红色分量，最后两位表示蓝色分量</li>
</ul>
</li>
<li>RGB<ul>
<li>rbg(r,g,b) ：正整数的取值为 0~255</li>
</ul>
</li>
<li>RGBA<ul>
<li>在RBG基础上增加了控制 alpha 透明度的参数，允许设定一个颜色的透明度。其中这个透明通道值为 0~1，a表示透明度：0等于透明；1=不透明</li>
</ul>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">color:red;</span><br><span class="line">color:#A983D8;</span><br><span class="line">color:#EEFF66;</span><br><span class="line">color:rbg(0,255,255);</span><br><span class="line">color:rgba(0,0,255,0.5);</span><br></pre></td></tr></table></div></figure>


        <h4 id="6-2-排版文字段落"   >
          <a href="#6-2-排版文字段落" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-排版文字段落" class="headerlink" title="6.2 排版文字段落"></a>6.2 排版文字段落</h4>
      
        <h5 id="6-2-1-水平对齐–text-align属性"   >
          <a href="#6-2-1-水平对齐–text-align属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-1-水平对齐–text-align属性" class="headerlink" title="6.2.1 水平对齐–text-align属性"></a>6.2.1 水平对齐–text-align属性</h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">left</td>
<td align="center">把文字排列到左边</td>
</tr>
<tr>
<td align="center">right</td>
<td align="center">把文字排列到右边</td>
</tr>
<tr>
<td align="center">center</td>
<td align="center">把文字排列到中间</td>
</tr>
<tr>
<td align="center">justify</td>
<td align="center">实现两端对其文本效果</td>
</tr>
</tbody></table></div>

        <h5 id="6-2-3-首行缩进–text-indent属性"   >
          <a href="#6-2-3-首行缩进–text-indent属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-3-首行缩进–text-indent属性" class="headerlink" title="6.2.3 首行缩进–text-indent属性"></a>6.2.3 首行缩进–text-indent属性</h5>
      <p><strong>取值：em或px</strong></p>

        <h5 id="6-2-3-行高–line-height属性"   >
          <a href="#6-2-3-行高–line-height属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-3-行高–line-height属性" class="headerlink" title="6.2.3 行高–line-height属性"></a>6.2.3 行高–line-height属性</h5>
      <p>行与行之间的高度<br><strong>取值 ：px</strong></p>

        <h5 id="6-2-4-文本装饰–text-decoration属性"   >
          <a href="#6-2-4-文本装饰–text-decoration属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-4-文本装饰–text-decoration属性" class="headerlink" title="6.2.4 文本装饰–text-decoration属性"></a><font color="red">6.2.4 文本装饰–text-decoration属性</font></h5>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">默认值，定义的标准文本</td>
</tr>
<tr>
<td align="center">underline</td>
<td align="center">设置文本的下划线</td>
</tr>
<tr>
<td align="center">overline</td>
<td align="center">设置文本的上划线</td>
</tr>
<tr>
<td align="center">line-through</td>
<td align="center">设置文本的删除线</td>
</tr>
</tbody></table></div>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML笔记(1)</title>
    <url>/2021/09/13/HTML(1)/</url>
    <content><![CDATA[
        <h2 id="HTML"   >
          <a href="#HTML" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2>
      
        <h3 id="1-认识HTML"   >
          <a href="#1-认识HTML" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-认识HTML" class="headerlink" title="1.认识HTML"></a>1.认识HTML</h3>
      <p>HTML 即 <font color="red">H</font>yper <font color="red">T</font>ext <font color="red">M</font>arkuo <font color="red">L</font>anguage (超文本标记语言)</p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/208030/40/138/77623/613c5032E04581de9/034e22e79ecc9936.png" alt="20210911144344.png"></p>
<p><strong>HTML结构</strong></p>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/74571/29/17124/161054/613c510aE35edc041/f9ac1ec2458f2f0e.png" alt="20210911144459.png"></p>
<p>注意：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;、&lt;/body&gt;等成对的标签，分别叫开放标签和闭合标签，单独呈现的标签(空元素)，如&lt;hr/&gt;: 意为用/来关闭空元素</span><br></pre></td></tr></table></div></figure>



        <h3 id="2-网页编辑工具"   >
          <a href="#2-网页编辑工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-网页编辑工具" class="headerlink" title="2.网页编辑工具"></a>2.网页编辑工具</h3>
      <p><strong>前端</strong></p>
<ul>
<li>记事本</li>
<li>Dreamweaver  </li>
</ul>
<p><strong>全栈</strong></p>
<ul>
<li>WebStorm  </li>
<li>Sublime  </li>
<li>Atom  </li>
<li>Notepad++   </li>
<li>VSCode  网址：<span class="exturl"><a class="exturl__link"   href="https://code.visualstudio.com/" >https://code.visualstudio.com/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </li>
</ul>
<p><strong>后台</strong></p>
<ul>
<li>Myeclipse  </li>
<li>IDEA  </li>
</ul>
<p><strong>VSCode ：</strong><br>一个运行与 Mac OS X 、Windows 、Linux之上，针对于编写现代 Web 和云应用的跨平台源代码编辑器</p>
<p><strong>优点：免费开源 、跨平台、功能可扩展、智能感知、内置 Git 等等。</strong></p>
<p><strong>VSCode推荐插件</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">插件名称</th>
<th align="center">插件作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Chinese(Simplified) Language Pack for Visual Studio Code</td>
<td align="center">中文</td>
</tr>
<tr>
<td align="center">Open in Browser</td>
<td align="center">在VSCode中打开浏览器访问</td>
</tr>
<tr>
<td align="center">Auto Rename Tag</td>
<td align="center">自动完成另一侧标签的同步修改</td>
</tr>
<tr>
<td align="center">Auto Close Tag</td>
<td align="center">自动闭合HTML/XML标签</td>
</tr>
<tr>
<td align="center">HTML CSS Support</td>
<td align="center">智能提示CSS类名以及id</td>
</tr>
<tr>
<td align="center">HTML Snippets</td>
<td align="center">智能提示HTML标签及标签含义</td>
</tr>
<tr>
<td align="center">Path Intellisense</td>
<td align="center">自动提示文件路径，支持各种快熟引入文件</td>
</tr>
<tr>
<td align="center">Beautify</td>
<td align="center">格式化 HTML、JS、CSS</td>
</tr>
<tr>
<td align="center">JavaScript(ES6) code snippets</td>
<td align="center">ES6语法智能提示，以及快速输入</td>
</tr>
<tr>
<td align="center">jQuery code Snippets</td>
<td align="center">jQuery 代码智能提示</td>
</tr>
</tbody></table></div>

        <h3 id="3-网页的基本标签"   >
          <a href="#3-网页的基本标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-网页的基本标签" class="headerlink" title="3.网页的基本标签"></a>3.网页的基本标签</h3>
      
        <h4 id="3-1-标题标签"   >
          <a href="#3-1-标题标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-标题标签" class="headerlink" title="3.1 标题标签"></a>3.1 标题标签</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;...&lt;/h1&gt;~&lt;h6&gt;...&lt;/h6&gt;</span><br><span class="line">示例：</span><br><span class="line">&lt;h1&gt;h1标题&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;h2标题&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;h3标题&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;h4标题&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;h5标题&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;h6标题&lt;/h6&gt;</span><br></pre></td></tr></table></div></figure>

<p><strong>h1最大 ，h6最小，只有h1sd</strong></p>

        <h4 id="3-2-段落标签"   >
          <a href="#3-2-段落标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-段落标签" class="headerlink" title="3.2 段落标签"></a>3.2 段落标签</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;...&lt;/p&gt;</span><br><span class="line">示例：</span><br><span class="line">&lt;h1&gt;我和我的祖国&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;我和我的祖国，一刻也不能分割&lt;/p&gt;</span><br><span class="line">&lt;p&gt;无论我走到哪里，都流出一首赞歌&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>

<p>段落可以自动换行</p>

        <h4 id="3-3-换行标签"   >
          <a href="#3-3-换行标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-换行标签" class="headerlink" title="3.3 换行标签"></a>3.3 换行标签</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">&lt;h1&gt;我和我的祖国&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">	我和我的祖国，一刻也不能分割&lt;br/&gt;</span><br><span class="line">	无论我走到哪里，都流出一首赞歌&lt;br/&gt;</span><br><span class="line">	我歌唱每一座高山，我歌唱每一条河&lt;br/&gt;</span><br><span class="line">	袅袅炊烟，小小村落&lt;br/&gt;</span><br><span class="line">  路上一道辙&lt;br/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>

<p>换行不换段，因此 <strong>br</strong> 比 <strong>p</strong> 标签的上下间距小</p>

        <h4 id="3-4-水平线标签"   >
          <a href="#3-4-水平线标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-水平线标签" class="headerlink" title="3.4 水平线标签"></a>3.4 水平线标签</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;hr/&gt;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">&lt;h1&gt;我和我的祖国&lt;/h1&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">	我和我的祖国，一刻也不能分割&lt;br/&gt;</span><br><span class="line">	无论我走到哪里，都流出一首赞歌&lt;br/&gt;</span><br><span class="line">	我歌唱每一座高山，我歌唱每一条河&lt;br/&gt;</span><br><span class="line">	袅袅炊烟，小小村落&lt;br/&gt;</span><br><span class="line">  路上一道辙&lt;br/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3-5-字体样式标签"   >
          <a href="#3-5-字体样式标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-5-字体样式标签" class="headerlink" title="3.5 字体样式标签"></a>3.5 字体样式标签</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;strong&gt;加粗标签&lt;/strong&gt; </span><br><span class="line">&lt;em&gt;斜体标签&lt;/em&gt; </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;我和我的祖国&lt;/h1&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">	我和我的&lt;strong&gt;祖国&lt;/strong&gt; ，一刻也不能分割&lt;br/&gt;</span><br><span class="line">	无论我走到哪里，都流出一首赞歌&lt;br/&gt;</span><br><span class="line">	我歌唱每一座高山，我歌唱每一条河&lt;br/&gt;</span><br><span class="line">	&lt;em&gt;袅袅&lt;/em&gt;炊烟，&lt;em&gt;小小&lt;/em&gt;村落&lt;br/&gt;</span><br><span class="line">  路上一道辙&lt;br/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3-6-注释和特殊符号"   >
          <a href="#3-6-注释和特殊符号" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-6-注释和特殊符号" class="headerlink" title="3.6 注释和特殊符号"></a>3.6 注释和特殊符号</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">特殊符号</th>
<th align="center">字符实体</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空格</td>
<td align="center"><code>&amp;nbsp;</code></td>
<td align="center"><code>&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&amp;nbsp;</code></td>
</tr>
<tr>
<td align="center">大于号(&gt;)</td>
<td align="center"><code>&amp;gt;</code></td>
<td align="center">如果时间<code>&amp;gt;</code>晚上六点，就坐车回家</td>
</tr>
<tr>
<td align="center">小于号(&lt;)</td>
<td align="center"><code>&amp;lt;</code></td>
<td align="center">如果时间<code>&amp;lt;</code>早上七点，就坐车上班</td>
</tr>
<tr>
<td align="center">引号(“)</td>
<td align="center"><code>&amp;quot;</code></td>
<td align="center">W3C规范中，HTML的属性值必须要用成对的<code>&amp;quot;</code>引起来</td>
</tr>
<tr>
<td align="center">版权符号@</td>
<td align="center"><code>&amp;copy;</code></td>
<td align="center">YKP<code>&amp;copy;</code> 2021-09-12</td>
</tr>
</tbody></table></div>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;&amp;nbsp;&amp;nbsp;&amp;lt;我和我的祖国&amp;gt;&amp;nbsp;&amp;nbsp;&lt;/h1&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">	我和我的&lt;strong&gt;祖国&lt;/strong&gt; ，一刻也不能分割&lt;br/&gt;</span><br><span class="line">	无论我走到哪里，都流出一首赞歌&lt;br/&gt;</span><br><span class="line">	我歌唱每一座高山，我歌唱每一条河&lt;br/&gt;</span><br><span class="line">	&lt;em&gt;袅袅&lt;/em&gt;炊烟，&lt;em&gt;小小&lt;/em&gt;村落&lt;br/&gt;</span><br><span class="line">  路上一道辙&lt;br/&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">YKP&amp;copy;&amp;nbsp;2021-09-12</span><br></pre></td></tr></table></div></figure>


        <h3 id="4-图像标签"   >
          <a href="#4-图像标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-图像标签" class="headerlink" title="4.图像标签"></a>4.图像标签</h3>
      
        <h4 id="常见的图像格式"   >
          <a href="#常见的图像格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见的图像格式" class="headerlink" title="常见的图像格式"></a>常见的图像格式</h4>
      <ul>
<li>jpg</li>
<li>gif</li>
<li>png </li>
<li>bmp </li>
</ul>

        <h4 id="图像标签格式"   >
          <a href="#图像标签格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#图像标签格式" class="headerlink" title="图像标签格式"></a>图像标签格式</h4>
      <p><strong>语法：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;path&quot; alt=&quot;text&quot; title&quot;text&quot; with=&quot;x&quot; height=&quot;y&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p><strong>src 、alt、title</strong> 被称为属性，多个属性之间用空格隔开，一个标签里面可以有多个属性</p>
<p>对于图像而言，有两个必须要写的属性，即 <strong>src</strong> 和 <strong>alt</strong></p>
<ul>
<li>src : 图片路径</li>
<li>alt : 当图片不能正常显示的时候，<strong>alt</strong>会在图片应该显示的位置显示对应的文字</li>
<li>title： 鼠标悬停提示文字</li>
<li>width ：图片宽度</li>
<li>height ：图片高度</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;image/hetao.jpg&quot; alt=&quot;无漂白薄皮核桃&quot; title&quot;无漂白薄皮核桃&quot; with=&quot;160&quot; height=&quot;160&quot;/&gt;</span><br></pre></td></tr></table></div></figure>



        <h3 id="5-链接标签"   >
          <a href="#5-链接标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-链接标签" class="headerlink" title="5.链接标签"></a>5.链接标签</h3>
      
        <h4 id="5-1-页面间的链接"   >
          <a href="#5-1-页面间的链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-1-页面间的链接" class="headerlink" title="5.1 页面间的链接"></a>5.1 页面间的链接</h4>
      <p><strong>从一个页面链接到另外一个页面</strong></p>
<p><strong>语法</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;path&quot; target=&quot;目标窗口位置&quot;&gt;链接文本或图像&lt;/a&gt;</span><br></pre></td></tr></table></div></figure>
<ul>
<li>href ：链接路径</li>
<li>target ：链接在哪个窗口打开，常用值 ：_self ( 在本浏览器窗口打开 )、_blank ( 在一个新的浏览器窗口打开 )</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;a href =&quot;detail.html&quot; traget=&quot;_blank&quot;&gt;Java编程思想&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href =&quot;detail.html&quot; traget=&quot;_blank&quot;&gt;</span><br><span class="line">	&lt;img src=&quot;img/bianchengsixiang.jpg&quot; alt=&quot;Java编程思想&quot; title=&quot;Java编程思想&quot;/&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-2-锚链接"   >
          <a href="#5-2-锚链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-锚链接" class="headerlink" title="5.2 锚链接"></a>5.2 锚链接</h4>
      
        <h5 id="锚链接"   >
          <a href="#锚链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h5>
      <ul>
<li>从A页面的甲位置跳到本页面的乙位置</li>
<li>从A页面的甲位置跳到B页面的乙位置</li>
</ul>

        <h5 id="创建步骤"   >
          <a href="#创建步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h5>
      <p>创建跳转标记</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;a name=&quot;marker&quot;&gt;乙位置&lt;/a&gt;</span><br></pre></td></tr></table></div></figure>

<p>创建跳转链接</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#marker&quot;&gt;甲位置&lt;/a&gt;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-3-功能性链接"   >
          <a href="#5-3-功能性链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-3-功能性链接" class="headerlink" title="5.3 功能性链接"></a>5.3 功能性链接</h4>
      <ul>
<li>电子邮件</li>
<li>QQ</li>
<li>MSN</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;mailto:xiaoxiao@163.com&quot;&gt;联系我&lt;/a&gt;</span><br></pre></td></tr></table></div></figure>

<p>使用功能性链接要以 mailto:  为前缀</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML笔记(2)</title>
    <url>/2021/09/13/HTML(2)/</url>
    <content><![CDATA[
        <h2 id="HTML"   >
          <a href="#HTML" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2>
      
        <h3 id="1-列表"   >
          <a href="#1-列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-列表" class="headerlink" title="1.列表"></a><font color="#4CB8E7">1.列表</font></h3>
      <p><font color="#4CB8E7"><strong>什么是列表</strong></font></p>
<p>列表就是信息资源的一种展示形式。它可以使信息结构化和条理化，并以列表的形样式显示出来，以便浏览者能更快捷地获得相应的信息</p>
<p><font color="#4CB8E7"><strong>列表的分类</strong></font> </p>
<ul>
<li>无序列表</li>
<li>有序列表</li>
<li>定义列表</li>
</ul>
<p><font color="#4CB8E7"><strong>HTML 列表标签</strong></font><br>| 标签 | 描述 |<br>| :—-: | :—-: |<br>| <code>&lt;ol&gt;</code> | 定义有序列表 |<br>| <code>&lt;ul&gt;</code> | 定义无序列表 |<br>| <code>&lt;li&gt;</code> | 定义列表项 |<br>| <code>&lt;dl&gt;</code> | 定义列表 |<br>| <code>&lt;dt&gt;</code> | 自定义列表项目 |<br>| <code>&lt;dd&gt;</code> | 定义自定列表项的描述 |</p>

        <h4 id="1-1无序列表"   >
          <a href="#1-1无序列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1无序列表" class="headerlink" title="1.1无序列表"></a><font color="#4CB8E7">1.1无序列表</font></h4>
      <p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">&lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>aaa</li>
<li>bbb</li>
</ul>

<p>ul 声明无序列表  li 声明列表项<br>ul 默认的是黑心小圆点 ：disc ；circle：空心圆圈  ；square：黑心小方块</p>
<p><strong>特性：</strong></p>
<blockquote>
<p>没有顺序，每个<code>&lt;li&gt;</code>标签独占一行<br>默认<code>&lt;li&gt;</code>标签项前面有个实心小圆点<br>一般用于无序类型的列表，如导航、侧边栏新闻、有规律的图文组合模块等</p>
</blockquote>

        <h4 id="1-2有序列表"   >
          <a href="#1-2有序列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2有序列表" class="headerlink" title="1.2有序列表"></a><font color="#4CB8E7">1.2有序列表</font></h4>
      <p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;aaa&lt;/li&gt;</span><br><span class="line">&lt;li&gt;bbb&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></div></figure>

<ol>
<li>aaa</li>
<li>bbb</li>
</ol>

<p>ol 声明有序列表  li 声明列表项<br>ol 默认是有序数字 1 还有：A a I i 四种取值</p>
<p><strong>特性：</strong></p>
<blockquote>
<p>有顺序，每个<code>&lt;oi&gt;</code>标签独占一行<br>默认<code>&lt;oi&gt;</code>标签项前面有顺序标记<br>一般用于排序类型的列表，如试、问候卷等</p>
</blockquote>

        <h4 id="1-3定义列表"   >
          <a href="#1-3定义列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3定义列表" class="headerlink" title="1.3定义列表"></a><font color="#4CB8E7">1.3定义列表</font></h4>
      <p><strong>示例：</strong><br>volume</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">	&lt;dt&gt;水果&lt;/dt&gt;</span><br><span class="line">	&lt;dd&gt;苹果&lt;/dd&gt;</span><br><span class="line">	&lt;dd&gt;桃子&lt;/dd&gt;</span><br><span class="line">	&lt;dd&gt;李子&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></div></figure>

<dl>
    <dt>水果</dt>
    <dd>苹果</dd>
    <dd>桃子</dd>
    <dd>李子</dd>
</dl>

<p>dl：声明定义列表，dt：声明列表项，dd：定义列表内容</p>
<p><strong>特性：</strong></p>
<blockquote>
<p>没有顺序，每个<code>&lt;dt&gt;</code>标签、<code>&lt;dd&gt;</code>标签独占一行<br>默认没有标记<br>一般用于一个标题下有一个或多个列表项的情况</p>
</blockquote>

        <h3 id="2-表格"   >
          <a href="#2-表格" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-表格" class="headerlink" title="2.表格"></a><font color="#4CB8E7">2.表格</font></h3>
      <p>表格的优点</p>
<ul>
<li>简单通用</li>
<li>结构稳定</li>
</ul>
<p>表格基本结构</p>
<ul>
<li>单元格</li>
<li>行</li>
<li>列</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;th&gt;1行1列的标题&lt;/th&gt;</span><br><span class="line">		&lt;th&gt;2行2列的标题&lt;/th&gt;</span><br><span class="line">		&lt;th&gt;3行3列的标题&lt;/th&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;1行1列的单元格&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;1行2列的单元格&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;1行3列的单元格&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;2行1列的单元格&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;2行2列的单元格&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;2行3列的单元格&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></div></figure>

<div class="table-container"><table>
    <tr>
        <th>1行1列的标题</th>
        <th>2行2列的标题</th>
        <th>3行3列的标题</th>
    </tr>
    <tr>
        <td>1行1列的单元格</td>
        <td>1行2列的单元格</td>
        <td>1行3列的单元格</td>
    </tr>
    <tr>
        <td>2行1列的单元格</td>
        <td>2行2列的单元格</td>
        <td>2行3列的单元格</td>
    </tr>
</table></div>

<p>table：表格标签；tr：行标签；th：标题标签；td：单元格标签<br>colspan=”2”：表示单元格跨两列 ；rowspan=”2”：表示单元格跨两行</p>

        <h3 id="3-表单"   >
          <a href="#3-表单" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-表单" class="headerlink" title="3.表单"></a><font color="#4CB8E7">3.表单</font></h3>
      <p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; action=&quot;result.html&quot;&gt;</span><br><span class="line">   &lt;p&gt;账号：&lt;input name=&quot;name&quot; type=&quot;text&quot;&gt;&lt;/p&gt;</span><br><span class="line">   &lt;p&gt;密码：&lt;input name=&quot;pwd&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">       &lt;input type=&quot;submit&quot; name=&quot;Button&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">       &lt;input type=&quot;reset&quot; name=&quot;Reset&quot; value=&quot;重置&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line"> &lt;/form&gt;</span><br></pre></td></tr></table></div></figure>

<form method="POST" action="result.html">
    <p>账号：<input name="name" type="text"></p>
    <p>密码：<input name="pwd" type="password"></p>
     <p>
        <input type="submit" name="Button" value="提交">
        <input type="reset" name="Reset" value="重置">
     </p>
</form>

<p>method：规定如何发生表单数据，常用值：get 、post<br>get:通过浏览器地址进行提交，不安全<br>在实际网页开发中通常采用 post 方式提交表单数据</p>

        <h4 id="3-1-input"   >
          <a href="#3-1-input" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-input" class="headerlink" title="3.1 input"></a>3.1 input</h4>
      <p><strong>语法：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;fname&quot; value=&quot;text&quot;/&gt;</span><br></pre></td></tr></table></div></figure>
<p>type：input元素类型；name：input元素名称；value：input元素的值</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">type</td>
<td align="center">指定袁术的类型。text、password、checkbox、radio、submit、reset、file、hidden、image和button，默认为text</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">指定表单元素的名称</td>
</tr>
<tr>
<td align="center">value</td>
<td align="center">元素的初始值，type为radio是必须指定的一个值</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">指定表单元素的初始宽度，当type为text或password时，表单元素的大小以字符为单位。对于其他类型，宽度以像素为单位</td>
</tr>
<tr>
<td align="center">maxlength</td>
<td align="center">type为text或password时，可输入的最大字符数</td>
</tr>
<tr>
<td align="center">checked</td>
<td align="center">type为radio或checkbox时，指定按钮是否被选中</td>
</tr>
</tbody></table></div>
<p><strong>表单高级应用</strong></p>
<ul>
<li>隐藏域</li>
<li> 只读</li>
<li> 禁用</li>
</ul>
<p><strong>隐藏域</strong></p>
<p>可以传递一些不想被用户看到的信息</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">input type=&quot;hidden&quot; name=&quot;myHiddenInfo&quot; value=&quot;login&quot; /&gt;</span><br></pre></td></tr></table></div></figure>

<p><strong>只读文本框</strong></p>
<p>使 input 框只读，不能修改</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">input name=&quot;name&quot; value=&quot;张三&quot; readonly /&gt;</span><br></pre></td></tr></table></div></figure>

<p><strong>禁用</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">input type=&quot;submit&quot; disabled value=&quot;保存&quot;/&gt;</span><br></pre></td></tr></table></div></figure>



        <h3 id="4-块元素和行内元素"   >
          <a href="#4-块元素和行内元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-块元素和行内元素" class="headerlink" title="4.块元素和行内元素"></a><font color="#4CB8E7">4.块元素和行内元素</font></h3>
      <p><strong>块元素</strong>：无论内容多少，该元素独占一行 ( p、h1~h6、li …… )<br><strong>行内元素元素</strong>：内容撑开宽度，左右都是行内元素的可以排在一行 ( a、strong、em ……)</p>
<p>示例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;块元素：段落1p&lt;/p&gt;</span><br><span class="line">&lt;p&gt;块元素：段落2p&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;块元素：标题标签&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;块元素：标题标签&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;#&quot;&gt;行内元素：超链接&lt;/a&gt;</span><br><span class="line">&lt;strong &gt;行内元素：字体元素&lt;/strong&gt;</span><br><span class="line">&lt;em&gt;行内元素：字体元素斜体&lt;/em&gt;</span><br></pre></td></tr></table></div></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多态性(2)</title>
    <url>/2021/09/10/Java-%E5%A4%9A%E6%80%81(2)/</url>
    <content><![CDATA[
        <h4 id="Java-多态-2"   >
          <a href="#Java-多态-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-多态-2" class="headerlink" title="Java-多态(2)"></a>Java-多态(2)</h4>
      <p>多态的应用<br>Java-多态(1)里面使用的向上转型大家都已经了解了，接下来介绍多态第二种 Java中实现和使用多态的主要方式</p>

        <h5 id="使用父类作为方法的返回值"   >
          <a href="#使用父类作为方法的返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用父类作为方法的返回值" class="headerlink" title="使用父类作为方法的返回值"></a>使用父类作为方法的返回值</h5>
      <p><strong>下面通过一个例子来演示</strong></p>
<p>假如有三种动物被一个主人领养，这个主人可以根据其他人要求任意送出一只宠物。送出的动物会发出相应的叫声</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//主人类</span><br><span class="line">public class Host()&#123;</span><br><span class="line">	//赠送动物</span><br><span class="line">	public Animal donateAnimal(Stringt ype)&#123;</span><br><span class="line">		Animal animal;</span><br><span class="line">		if(type==&quot;dog&quot;)&#123;</span><br><span class="line">			animal = new Dog();</span><br><span class="line">		&#125;else if(type==cat)&#123;</span><br><span class="line">			animal = new Cat();</span><br><span class="line">		&#125;else if(type==Duck)&#123;</span><br><span class="line">			animal = new Duck();</span><br><span class="line">		&#125;</span><br><span class="line">		return animal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>以上为主人类代码，以下为测试类代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test()&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Host host = new Host();</span><br><span class="line">		Animal animal;</span><br><span class="line">		animal = host.donateAnimal(&quot;dog&quot;);</span><br><span class="line">		animal.cry();//狗叫</span><br><span class="line">		animal = host.donateAnimal(&quot;cat&quot;);</span><br><span class="line">		animal.cry();//猫叫</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>从上述代码中将父类Animal作为赠送动物方法的返回类型，而不是具体的子类，调用者仍然可以控制动物叫，动物叫的行为则由具体的动物类型决定</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Object类</title>
    <url>/2021/09/10/Java%20Object%E7%B1%BB/</url>
    <content><![CDATA[
        <h3 id="Java-Object类"   >
          <a href="#Java-Object类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-Object类" class="headerlink" title="Java Object类"></a>Java Object类</h3>
      
        <h4 id="Object类介绍"   >
          <a href="#Object类介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#Object类介绍" class="headerlink" title="Object类介绍"></a>Object类介绍</h4>
      <p>Object 是所有的类的直接或间接父类<br><strong>如:Cat后面的 extends Object 不写也默认继承</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Cat (extends Object)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="Object类被子类经常重写的方法"   >
          <a href="#Object类被子类经常重写的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Object类被子类经常重写的方法" class="headerlink" title="Object类被子类经常重写的方法"></a>Object类被子类经常重写的方法</h4>
      <div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">toString()</td>
<td align="center">比较两个对象是否是同一个对象，是则返回true</td>
</tr>
<tr>
<td align="center">equals()</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="center">hashCode()</td>
<td align="center">返回该对象的哈希代码值</td>
</tr>
<tr>
<td align="center">getClass()</td>
<td align="center">获取当前对象所属的类信息，返回Class对象</td>
</tr>
</tbody></table></div>

        <h4 id="equals-方法介绍"   >
          <a href="#equals-方法介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#equals-方法介绍" class="headerlink" title="equals( )方法介绍"></a>equals( )方法介绍</h4>
      <p> 作用：比较两个对象是否是同一个对象，是则返回 <font color="blue">true</font>，不是则返回 <font color="blue">false</font></p>
<p>  下面用一个例子来演示</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//学生类</span><br><span class="line">public class Student extends Object&#123;</span><br><span class="line">	//这里加上了 extends Object; 不加 extends Object 也默认会有</span><br><span class="line">	//属性：学号 姓名 年龄 体重</span><br><span class="line">	private int sid;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	private int weight;</span><br><span class="line">	</span><br><span class="line">	//无参构造</span><br><span class="line">	public Student()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//有参构造</span><br><span class="line">	public Student(int sid,String name,int age,int weight)&#123;</span><br><span class="line">		this.sid=sid;</span><br><span class="line">		this.name=name;</span><br><span class="line">		this.age=age;</span><br><span class="line">		this.weight=weight;</span><br><span class="line">	&#125;</span><br><span class="line">	//getter、setter方法</span><br><span class="line">	public int getSid() &#123;</span><br><span class="line">		return sid;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSid(int sid) &#123;</span><br><span class="line">		this.sid = sid;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getWeight() &#123;</span><br><span class="line">		return weight;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setWeight(int weight) &#123;</span><br><span class="line">		this.weight = weight;</span><br><span class="line">	&#125;	</span><br><span class="line">	//main方法</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		//例1</span><br><span class="line">	 	Student s1= new Student(1,&quot;张三&quot;,18,50);</span><br><span class="line">		Student s2= new Student(1,&quot;张三&quot;,18,50);</span><br><span class="line">		s1和s2指向的不是同一个地址值,所以为false</span><br><span class="line">		//判断两个对象是否为同一对象</span><br><span class="line">		System.out.println(s1 == s2);</span><br><span class="line">		System.out.println(s1.equals(s2));</span><br><span class="line">		</span><br><span class="line">		//例2</span><br><span class="line">		Student s1= new Student(1,&quot;张三&quot;,18,50);</span><br><span class="line">		Student s2= s1;</span><br><span class="line">		//判断两个对象是否为同一对象</span><br><span class="line">		System.out.println(s1 == s2);</span><br><span class="line">		System.out.println(s1.equals(s2));</span><br><span class="line">		//s1和s2指向的是同一个地址值 所以为true		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>从上面代码可以得出：<font color="blue">equals( )</font>和<font color="blue">==</font>没有太大的区别<br>不同的是<font color="blue">equals( )</font>个方法 而<font color="blue">==</font>是一个操作符</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多态性(1)</title>
    <url>/2021/09/10/Java-%E5%A4%9A%E6%80%81(1)/</url>
    <content><![CDATA[
        <h3 id="Java-多态性"   >
          <a href="#Java-多态性" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-多态性" class="headerlink" title="Java-多态性"></a>Java-多态性</h3>
      <p>多态是Java面向对象的一个重要的特性</p>

        <h4 id="1-认识多态"   >
          <a href="#1-认识多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-认识多态" class="headerlink" title="1.认识多态"></a>1.认识多态</h4>
      <p>多态一词通常含义是指能够呈现出多种不同的形式或形态，而在程序设计的术语中，它意味着一个特定类型的变量可以引用不同类型的对象，并且能自动地调用引用的对象的方法，也就是根据作用到的不同对象类型，响应不同的操作。方法重写是实现多态的基础<br><img src="https://img03.sogoucdn.com/app/a/100540022/2021080311010588619450.png" alt="20210803105806.png"></p>

        <h4 id="2-为什么使用多态"   >
          <a href="#2-为什么使用多态" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-为什么使用多态" class="headerlink" title="2.为什么使用多态"></a>2.为什么使用多态</h4>
      <p>不使用多态会频繁修改代码,代码可扩展性、可维护性差</p>

        <h4 id="3-多态初体验"   >
          <a href="#3-多态初体验" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-多态初体验" class="headerlink" title="3.多态初体验"></a>3.多态初体验</h4>
      <p>通过下面的例子理解什么是多态</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//父类 宠物类</span><br><span class="line">public class Pet &#123;</span><br><span class="line">	public void toHospital()&#123;</span><br><span class="line">		System.out.println(&quot;宠物看病 ! ! !&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//子类 小狗类</span><br><span class="line">public class Dog extends Pet&#123;</span><br><span class="line">	public void toHospital()&#123;</span><br><span class="line">		System.out.println(&quot;小狗看病&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//子类 鸟</span><br><span class="line">public class Bird extends Pet&#123;</span><br><span class="line">	public void toHospital()&#123;</span><br><span class="line">		System.out.println(&quot;小鸟看病&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//看病测试类</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//示例一</span><br><span class="line">		Dog dog = new Dog();</span><br><span class="line">		dog.toHospital();//小狗看病</span><br><span class="line">		Bird bird = new Bird();</span><br><span class="line">		bird.toHospital();//小鸟看病</span><br><span class="line">		</span><br><span class="line">		//示例二</span><br><span class="line">		Pet pet= new Pet();</span><br><span class="line">		pet = new Dog();</span><br><span class="line">		pet.toHospital();//小狗看病</span><br><span class="line">		pet = new Bird();</span><br><span class="line">		pet.toHospital();//小鸟看病		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p>前后两段代码运行效果完全一样 示例二虽然定义的是Pet类但实际执行调用的都是Pet子类的方法</p>
<p>这就体现了多态性</p>
<p>多态意味着在一次方法调用中根据包含的对象的实际类型(即实际的子类对象)来决定应该调用哪个方法，而不是用来储存对象引用的变量的类型来决定的。</p>
<p>当调用一个方法时，为了实现多态操作，这个方法即是在父类中声明过，也必须是在子类中重写过的方法。</p>
<p>从上面的代码可以得出:<font color="red">实现多态必须要在继承(extends)和重写(override)的基础上实现</font></p>

        <h3 id="向上-向下-转型"   >
          <a href="#向上-向下-转型" class="heading-link"><i class="fas fa-link"></i></a><a href="#向上-向下-转型" class="headerlink" title="向上(向下)转型"></a>向上(向下)转型</h3>
      
        <h4 id="1-向上转型"   >
          <a href="#1-向上转型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-向上转型" class="headerlink" title="1.向上转型"></a>1.向上转型</h4>
      <p>子类向父类的转换称为向上转型</p>
<p>向上转型的语法格式如下</p>
<blockquote>
<p>&lt;父类型&gt;&lt;引用变量名&gt; = new &lt;子类型&gt;( );</p>
</blockquote>
<p>例：</p>
<blockquote>
<p>Pet  dog= new Dog( ); </p>
</blockquote>
<p>基本数据类型之间的转换和向上(向下)转型相似，举例如下:<br>( 1 ) 把<font color="blue"> int </font>型常量或变量的值赋值给<font color="blue"> double </font>型变量，可以自动进行类型转换</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">int i= 5;</span><br><span class="line">double d1= i;</span><br></pre></td></tr></table></div></figure>
<p>( 2 )  把double型常量或变量的值赋给int型变量，必须进行强制类型转换。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">double d2= 3.14;</span><br><span class="line">int a=(int)d2;</span><br></pre></td></tr></table></div></figure>
<p>上面是数据类型之间的类型转换</p>
<p>在引用数据类型的子类和父类之间也存在着类型转换的问题</p>
<p><font color="blue"> Pet </font>为抽象父类,<font color="blue"> Dog </font>为抽象子类,<font color="blue"> Pet </font>父类中包含抽象方法<font color="blue"> toHospital( )</font></p>
<blockquote>
<p>Pet pet = new Dog( ); //子类到父类的转换<br>pet.toHospital( );</p>
</blockquote>
<p>会调用<font color="blue"> Dog </font>类的<font color="blue"> toHospital( ) </font>方法，而不是<font color="blue"> Pet </font>类的<font color="blue"> toHospital( ) </font>方法,体现了多态</p>
<p>但是<font color="blue"> Pet </font>对象无法调用子类特有的方法</p>
<p><strong>总结：</strong></p>
<blockquote>
<p>1.将一个父类的引用指向一个子类对象称为向上转型，系统会自动进行类型转换<br>2.此时通过父类引用变量调用的方法是子类覆盖或继承了父类的方法，不是父类的方法<br>3.此时通过父类引用变量无法调用子类特有的方法</p>
</blockquote>

        <h4 id="2-向下转型"   >
          <a href="#2-向下转型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-向下转型" class="headerlink" title="2.向下转型"></a>2.向下转型</h4>
      <p>向上转型后，父类无法调用子类特有的方法，但是如果需要调用子类特有的方法，可以通过把父类转换为子类来实现</p>
<p>将一个指向子类对象的父类引用赋给一个子类引用，即将父类类型转换为子类类型，称为向下转型，此时必须进行强制类型转换。</p>
<p>在<font color="blue"> Dog </font>中声明一个特有的<strong>接飞盘</strong>方法 <strong><font color="blue">catchingFlyDisc( )</font></strong>,这个方法是子类特有的，下面的代码就会出现问题</p>
<blockquote>
<p>// <font color="blue"> Pet </font>为父类 ，<font color="blue"> Dog </font>为子类，<br>// Pet中包含方法<font color="blue"> toHospital()</font>,不包含<font color="blue"> catchingFlyDisc()</font>方法<br><font color="red">Pet pet = new Dog() </font> //子类到父类的转换<br>//会调用Dog类的 toHospital()方法，而不是Pet类的toHospital()方法，体现了多态<br><font color="red"> pet.toHospital(); </font>//可以调用父类和子类共有的方法<br><font color="red"> pet.catchingFlyDisc( ); </font>//无法调用子类特有的方法</p>
</blockquote>
<p>可以这样理解，主人可以为任何宠物看病，但只能和狗狗玩接飞盘游戏。在没有确实宠物是狗狗的情况下，主人不能与宠物玩接飞盘游戏。因为他需要的是一个宠物，但是没有明确要求是一只狗狗，所以很有可能他的宠物是一只鸟，因此就不能确实是否能玩接飞盘游戏。那么这里需要做的就是强制类型转换，将父类转换为子类，然后才能调用子类特有的方法。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Pet pet = new Pet();//声明一个父类</span><br><span class="line">Dog dog = (Dog)pet; //将父类 pet 转换为子类 Dog 类型</span><br><span class="line">dog.catchingFlyDisc();//执行子类 Dog 特有的方法</span><br></pre></td></tr></table></div></figure>

<p>上述这种向下转型的操作对接口和抽象（普通）父类同样适用。</p>
<p>向下转型的语法: <font color="#4169E1">&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类的引用变量&gt;</font>；</p>

        <h4 id="3-instanceof-运算符"   >
          <a href="#3-instanceof-运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-instanceof-运算符" class="headerlink" title="3.instanceof 运算符"></a>3.instanceof 运算符</h4>
      <p>在向下转型的过程中没如果不是转换为真实的子类类型，会出现类型转换异常：<font color="#FF0000">ClassCastException</font></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//Pet 为父类 ，Dog为子类，Bird为子类</span><br><span class="line">Pet pet = new Dog(); //子类到父类的转换</span><br><span class="line">pet.toHospital();//会调用Dog的 toHospital() 方法</span><br><span class="line">Bird bird = (Bird)pet; // 将pet转换为Bird类会出错</span><br></pre></td></tr></table></div></figure>
<p>Java中提供了<font color="    #EEB422"> instanceof </font>运算符来进行类型的判断</p>
<p><strong>示例如下：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Pet pet = new Dog;</span><br><span class="line">		//Pet pet = new Bird;</span><br><span class="line">		pet.toHospital();</span><br><span class="line">		if(pet instanceof Dog)&#123;</span><br><span class="line">			Dog dog = (Dog)pet;</span><br><span class="line">			d.carchingFlyDisc(); //执行狗狗的特有方法，接飞盘</span><br><span class="line">		&#125;else if(pet instanceof Bird)&#123;</span><br><span class="line">			Bird bird = (Bird)pet;</span><br><span class="line">			bird.fly(); //执行小鸟的特有方法，飞翔</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>使用<font color="    #EEB422"> instanceof </font>时，对象的类型必须和<font color="    #EEB422"> instanceof </font>后面的参数所指定的类有继承关系，否则会出现编译错误。</p>
<p>例如：代码 “ pet instanceof String “ ，会出现编译错误。</p>
<p><font color="    #EEB422"> instanceof </font> 通常和强制类型转换结合使用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2021/09/10/Java-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[
        <h3 id="Java-异常"   >
          <a href="#Java-异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-异常" class="headerlink" title="Java-异常"></a>Java-异常</h3>
      
        <h4 id="1-什么是异常？"   >
          <a href="#1-什么是异常？" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-什么是异常？" class="headerlink" title="1.什么是异常？"></a>1.什么是异常？</h4>
      <p>异常是指在程序运行过程中所发生的不正常事件，如所需文件找不到、网络连接不通或连接中断、算术运算出错（如被零除）、数组下标越界、装载一个不存在的类、对null对象操作、类型转换异常等。异常会中段断正在运行的程序。</p>
<p><strong>生活中的异常：</strong><br>正常情况下，小王每天开车去上班，耗时大约30钟</p>
<p><strong>异常情况：</strong><br>上班路上会发生：堵车、车子故障等事故，会影响小王的上班时间</p>
<p>下面看一个程序中的异常：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">System.out.print(&quot;请输入被除数：&quot;);</span><br><span class="line">int num1 = sc.nextInt();</span><br><span class="line">System.out.print(&quot;请输入除数：&quot;);</span><br><span class="line">int num2 = sc.nextInt();</span><br><span class="line">System.out.print(num1+&quot;/&quot;+num2+&quot;=&quot;+(num1/num2));</span><br><span class="line">System.out.print(&quot;感谢使用本程序！&quot;);</span><br></pre></td></tr></table></div></figure>
<p>这个程序正常来说执行是不会报错的，但是一但出现异常程序将会立刻结束，不仅计算和输出商的语句不会执行，就连输出“感谢本程序！”的语句也不会执行,如下图所示：<br><img src="https://img13.360buyimg.com/ddimg/jfs/t1/196986/12/1936/20605/610cd871E919798c6/827ba5954b9b8427.png" alt="20210806143606.png"></p>
<p>或者用户输入跟数字无关的字母、下划线等，也会出现异常</p>
<p>总结下来：异常就是指在程序运行过程中所发生的不正常事件，它会中断正在运行的程序</p>
<blockquote>
<p>程序运行——&gt;异常——&gt;程序中断运行</p>
</blockquote>
<p><strong>在生活中面对异常会这样处理</strong></p>
<blockquote>
<p>开车—&gt;堵车—&gt;绕行或者等待—&gt;到公司<br>开车—&gt;车子故障—&gt;请道路救援维修，或者自己维修—&gt;到公司</p>
</blockquote>
<p><strong>生活中 ，根据不同的异常进行相应的处理，而不会就此中断我们的生活</strong></p>
<p><strong>如何解决异常?</strong></p>
<blockquote>
<p>程序中出现异常，如何解决？<br>程序员通过代码堵住程序中可能出现的 “漏洞”</p>
<p>程序中的异常处理<br>根据不同的异常进行相应的处理，而不会就此中断程序运行</p>
<p>Java异常处理机制</p>
</blockquote>
<p>异常<br>1.在程序的运行过程中所发生的不正常的事件，它会中断中断正在运行的程序<br>异常处理<br>1.根据不同的异常进行相应的处理，而不会就此中断程序运行<br>2.Java使用异常处理机制为程序提供了错误处理的能力</p>

        <h4 id="2-异常处理机制"   >
          <a href="#2-异常处理机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-异常处理机制" class="headerlink" title="2.异常处理机制"></a>2.异常处理机制</h4>
      <p>Java 编程语言使用异常处理机制为程序提供了错误处理的能力</p>
<p>程序中预先设置号对付异常的处理办法—&gt;程序运行—&gt;异常<br>对异常进行处理—&gt;处理完毕，程序继续运行</p>
<p>例：处理除数为0的传统方法<br>在用户录入之前做判断，排除一些用户的非法操作</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入被除数：&quot;);</span><br><span class="line">        int num1 = sc.nextInt();</span><br><span class="line">        System.out.print(&quot;请输入除数：&quot;);</span><br><span class="line">        int num2 = 0;</span><br><span class="line">        //在接收用户录入之前做判断，排除一些用户的非法操作</span><br><span class="line">        //hasNextInt():用户输入的必须是int类型的数据</span><br><span class="line">        if(sc.hasNextInt())&#123;</span><br><span class="line">            num2=sc.nextInt();</span><br><span class="line">            //用户录入整数</span><br><span class="line">            if(0==num2)&#123;</span><br><span class="line">                //用户录入的是0</span><br><span class="line">                System.out.println(&quot;输入的除数不能为0，程序退出！&quot;);</span><br><span class="line">                //退出JVM，非0代表异常终止</span><br><span class="line">                System.exit(1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(num1+&quot;/&quot;+num2+&quot;=&quot;+(num1/num2));</span><br><span class="line">                System.out.print(&quot;感谢使用本程序！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //用户录入的是非整数</span><br><span class="line">            System.out.println(&quot;输入的除数不是整数，程序退出！&quot;);</span><br><span class="line">            //退出JVM，非0代表异常终止</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>弊端：</strong><br>1.代码臃肿<br>2.程序员要花很大精力 “堵漏洞”<br>3.程序员很难堵住所有 “漏洞”<br>4.异常处理代码和业务代码交织在一起，影响了代码的可读性，加大日后程序的维护难度。</p>

        <h5 id="接下来介绍Java的异常处理机制"   >
          <a href="#接下来介绍Java的异常处理机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#接下来介绍Java的异常处理机制" class="headerlink" title="接下来介绍Java的异常处理机制"></a>接下来介绍Java的异常处理机制</h5>
      <p>Java提供了异常处理机制，可以由系统来处理程序在运行过程中可能出现的异常事件，使程序员又更多精力关注于业务代码编写。</p>
<p>有五个关键字：try、catch、finally、throw、throws</p>
<blockquote>
<p>1.try:执行可能产生异常的代码（捕获异常）<br>2.catch：捕获异常<br>3.finally：无论是否发生异常，代码总能执行<br>4.throws：声明方法可能要抛出的各种异常<br>5.throw：手动抛出异常</p>
</blockquote>
<p><strong>例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    //简单的try-catch处理异常</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.print(&quot;请输入被除数：&quot;);</span><br><span class="line">            int num1 = sc.nextInt();</span><br><span class="line">            System.out.print(&quot;请输入除数：&quot;);</span><br><span class="line">            int num2 = sc.nextInt();</span><br><span class="line">            System.out.print(num1+&quot;/&quot;+num2+&quot;=&quot;+(num1/num2));</span><br><span class="line">            System.out.print(&quot;感谢使用本程序！&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            //捕获异常，对异常做处理</span><br><span class="line">            System.err.println(&quot;出现错误:被除数和除数必须为整数，且不能为零!&quot;);</span><br><span class="line">            System.exit(1);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>比起传统处理异常，try-catch更节省代码</p>

        <h4 id="3-try-catch"   >
          <a href="#3-try-catch" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-try-catch" class="headerlink" title="3.try-catch"></a>3.try-catch</h4>
      <p><strong>掌握使用 try-catch异常处理的三种</strong> </p>
<p>第一种：正常执行，可能出现异常</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public void method()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		//代码段(此处不会产生异常)</span><br><span class="line">	&#125;catch(异常类型 e)&#123;</span><br><span class="line">		//对异常进行处理的代码段</span><br><span class="line">	&#125;</span><br><span class="line">	//代码段</span><br><span class="line">&#125;</span><br><span class="line">//try里面没有异常的话，不会执行carch会继续执行后面的代码段</span><br></pre></td></tr></table></div></figure>
<p><strong>第二种：出现异常</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public void method()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		//代码段1</span><br><span class="line">		//产生异常的代码段2</span><br><span class="line">		//代码段3</span><br><span class="line">	&#125;catch(异常类型 e)&#123;</span><br><span class="line">		//对异常进行处理的代码段4</span><br><span class="line">	&#125;</span><br><span class="line">	//代码段5</span><br><span class="line">	//有异常进入catch之后还会执行代码段5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>第二种：异常类型不匹配</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public void method()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		//代码段1</span><br><span class="line">		//产生异常的代码段2</span><br><span class="line">		//代码段3</span><br><span class="line">	&#125;catch(异常类型 e)&#123;</span><br><span class="line">		//对异常进行处理的代码段4</span><br><span class="line">	&#125;</span><br><span class="line">	//代码段5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>异常类型不匹配的话，不会进入到catch里面，也不会继续执行后面的代码</strong></p>

        <h4 id="4-异常对象处理"   >
          <a href="#4-异常对象处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-异常对象处理" class="headerlink" title="4.异常对象处理"></a>4.异常对象处理</h4>
      <p>在catch块中处理异常<br> 加入用户自定义处理信息</p>
<blockquote>
<p>System.err.println(“出现错误:被除数和除数必须是整数”);</p>
</blockquote>
<p>调用方法输出异常</p>
<blockquote>
<p>e.printStackTrace( );//输出异常的堆栈信息</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">catch (Exception e)&#123;</span><br><span class="line">  //捕获异常，对异常做处理</span><br><span class="line"> System.err.println(&quot;出现错误:被除数和除数必须为整数，且不能为零!&quot;);</span><br><span class="line">  //System.exit(1);</span><br><span class="line">  //输出异常堆栈信息</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;;</span><br><span class="line">//printStackTrace()的堆栈跟踪功能显示出程序运行到当前类的执行流程</span><br></pre></td></tr></table></div></figure>
<p>异常对象常用的方法</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void printStackTrace()</td>
<td>输出异常新堆栈信息</td>
</tr>
<tr>
<td align="center">String getMessage()</td>
<td>是printStackTrace()输出信息的一部分</td>
</tr>
</tbody></table></div>
<p>getMessage( )：返回报错信息的字符串</p>
<p><strong>常见的异常类型</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">异常类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Exception</td>
<td align="center">异常层次结构的父类</td>
</tr>
<tr>
<td align="center">ArithmeticException</td>
<td align="center">算术错误情形，如以零作除数</td>
</tr>
<tr>
<td align="center">ArraylndexOutOfBoundsException</td>
<td align="center">数组下标越界</td>
</tr>
<tr>
<td align="center">NullPointerException</td>
<td align="center">尝试访问null对象成员</td>
</tr>
<tr>
<td align="center">ClassNotFoundException</td>
<td align="center">不能加载所需的类</td>
</tr>
<tr>
<td align="center">lllegalArgumentException</td>
<td align="center">方法接收到非法参数</td>
</tr>
<tr>
<td align="center">ClassCastException</td>
<td align="center">对象强制类型转换出错</td>
</tr>
<tr>
<td align="center">NumberFormatException</td>
<td align="center">算术错误情形，如以零作除数</td>
</tr>
<tr>
<td align="center">ArithmeticException</td>
<td align="center">数字格式转换异常，如把”abc”转换成数字</td>
</tr>
</tbody></table></div>

        <h4 id="5-try-catch-finally"   >
          <a href="#5-try-catch-finally" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-try-catch-finally" class="headerlink" title="5.try-catch-finally"></a>5.try-catch-finally</h4>
      <p><strong>在try-catch块后加入finally ，finally不管前面是否发生异常都会被执行</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    //简单的try-catch处理异常</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.print(&quot;请输入被除数：&quot;);</span><br><span class="line">            int num1 = sc.nextInt();</span><br><span class="line">            System.out.print(&quot;请输入除数：&quot;);</span><br><span class="line">            int num2 = sc.nextInt();</span><br><span class="line">            System.out.print(num1+&quot;/&quot;+num2+&quot;=&quot;+(num1/num2));</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            //捕获异常，对异常做处理</span><br><span class="line">            System.err.println(&quot;出现错误:被除数和除数必须为整数，且不能为零!&quot;);</span><br><span class="line">           </span><br><span class="line">            //System.exit(1);</span><br><span class="line">            //输出异常堆栈信息</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.print(&quot;感谢使用本程序！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//唯一不执行的情况是写了</span><br><span class="line">//System.exit(1);</span><br><span class="line">如果catch里面有return的话，是先执行finally，再执行return</span><br></pre></td></tr></table></div></figure>
<p><strong>面试题：</strong><br>1.try-catch块中存在return语句，是否还执行finally块？如果执行，说出执行循序</p>
<p>答：执行finally，不管有没有异常，finally始终是执行的，finally的执行循序在 return 之前</p>
<p>2.try-catch- finally块中，finally块唯一不执行的情况是什么?</p>
<p>答：在catch里面加入了System.exit(1);此时进入到catch里面会终止JVM的进程</p>

        <h4 id="6-多重catch"   >
          <a href="#6-多重catch" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-多重catch" class="headerlink" title="6. 多重catch"></a>6. 多重catch</h4>
      <p><strong>引发多种类型的异常</strong></p>
<p>1.排列catch语句的顺序∶先子类后父类<br>2.发生异常时按顺序逐个匹配<br>3.只执行第一个与异常类型匹配的catch语句</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    //简单的try-catch处理异常</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.print(&quot;请输入被除数：&quot;);</span><br><span class="line">            int num1 = sc.nextInt();</span><br><span class="line">            System.out.print(&quot;请输入除数：&quot;);</span><br><span class="line">            int num2 = sc.nextInt();</span><br><span class="line">            System.out.print(num1+&quot;/&quot;+num2+&quot;=&quot;+(num1/num2));</span><br><span class="line"></span><br><span class="line">        &#125;catch (InputMismatchException e)&#123;</span><br><span class="line">            //捕获异常，对异常做处理</span><br><span class="line">            System.err.println(&quot;出现错误:被除数和除数必须为整数!&quot;);</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">        &#125;catch (ArithmeticException e)&#123;</span><br><span class="line">            //捕获异常，对异常做处理</span><br><span class="line">            System.err.println(&quot;出现错误:除数不能为零!&quot;);</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            //捕获异常，对异常做处理</span><br><span class="line">            System.err.println(&quot;出现错误:非法操作!&quot;);</span><br><span class="line">            //System.exit(1);</span><br><span class="line">            //输出异常堆栈信息</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;感谢使用本程序！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>多重catch的执行顺序：先执行小的异常，把大的异常放到最后</strong></p>

        <h4 id="7-throws声明异常"   >
          <a href="#7-throws声明异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-throws声明异常" class="headerlink" title="7. throws声明异常"></a>7. throws声明异常</h4>
      <p>thriws声明某个方法可能抛出的各种异常，多个异常用逗号隔开</p>
<p>方法1：调用者处理异常<br>方法2：调用者继续声明异常   ，main()方法声明的异常有Java虚拟机处理</p>
<p>示例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot;请输入被除数&quot;);</span><br><span class="line">		int bei=sc.nextInt();</span><br><span class="line">		System.out.println(&quot;请输入除数&quot;);</span><br><span class="line">		int chuShu = sc.nextInt();</span><br><span class="line">		</span><br><span class="line">		int sum=bei/chuShu;</span><br><span class="line">		System.out.println(bei+&quot;/&quot;+chuShu+&quot;=&quot;+sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">```				</span><br><span class="line"></span><br><span class="line">除了系统自动抛出异常外，有些问题需要程序员自行抛出和异常</span><br><span class="line">如：我声明了一个人类，但是男女在意义上只能是男或者是女，在OOP阶段可以使用异常来进行处理</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>public class Person {<br>    private String name;<br>    private String sex;<br>    private String age;<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    public String getSex() {<br>        return sex;<br>    }<br>    //性别只能是男和女，其他字符串报异常<br>    public void setSex(String sex) throws Exception {<br>        if(“男”.equals(sex) ||”女”.equals(sex)){<br>            this.sex=sex;<br>        }else{<br>            //当使用 throw显式抛出异常，必须对异常处理，或throws声明异常<br>            throw new Exception(“性别只能为男女”);<br>        }<br>    }<br>    public String getAge() {<br>        return age;<br>    }</p>
<pre><code>public void setAge(String age) &#123;
    this.age = age;
&#125;

//个人信息介绍
public void print()&#123;
    System.out.println(this.getName()+&quot;--&quot;+this.getSex()+&quot;--&quot;+this.getAge());
&#125;
//main方法
public static void main(String[] args)&#123;
    Person p = new Person();
    try &#123;
        p.setSex(&quot;sc &quot;);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    p.print();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">| throw | throws | </span><br><span class="line">| :-----: | :----: |</span><br><span class="line">| 生成并抛出异常| 声明方法内抛出了异常 | </span><br><span class="line">| 位于方法体内部，可作为单独语句使用 | 必须跟在方法参数列表后面，不能单独使用 | </span><br><span class="line">| 抛出一个异常对象，且只能是一个 | 声明抛出异常类型，可以跟多个异常 | </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8. throws自定义异常</span><br><span class="line">定义一个自定义异常：创建一个普通类，继承Exception使用super调用父类的方法</span><br></pre></td></tr></table></div></figure>
<p>//自定义异常类（Person类性别赋值异常）<br>public class SexException extends Exception{</p>
<pre><code>public SexException()&#123;&#125;
//由特定异常信息构建异常对象
public SexException(String message)&#123;
    super(message);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">在setSex里面修改抛出的异常为SexException</span><br></pre></td></tr></table></div></figure>
<p>//性别只能是男和女，其他字符串报异常<br>    public void setSex(String sex) throws SexException {<br>        if(“男”.equals(sex) ||”女”.equals(sex)){<br>            this.sex=sex;<br>        }else{<br>            //当使用 throw显式抛出异常，必须对异常处理，或throws声明异常<br>            throw new SexException(“性别只能为男女”);<br>        }<br>    }</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">最后调用setSex方法来try-catch自定义异常</span><br></pre></td></tr></table></div></figure>
<p>public static void main(String[] args){<br>        Person p = new Person();<br>        try {<br>            p.setSex(“sc”);<br>        } catch (SexException e) {<br>            e.printStackTrace();<br>        }<br>        p.print();<br>    }</p>
<p>```</p>

        <h4 id="9-异常链和异常处理原则"   >
          <a href="#9-异常链和异常处理原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-异常链和异常处理原则" class="headerlink" title="9. 异常链和异常处理原则"></a>9. 异常链和异常处理原则</h4>
      <p>问题：<br>A方法调用B方法时，B方法却抛出了异常。那A方法继续抛出原有的异常还是抛出一个新的异常呢？</p>
<p>1.抛出原有的异常 ：A方法与B方法进行了关联 ，不便于代码的修改和扩展<br>2.抛出新的异常：会丢失原有的异常信息</p>
<p>异常链是JDK1.4推出的创建了新的异常但却保留了原有异常的信息</p>

        <h4 id="10-异常处理原则"   >
          <a href="#10-异常处理原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-异常处理原则" class="headerlink" title="10.异常处理原则"></a>10.异常处理原则</h4>
      <blockquote>
<p>异常处理与性能<br>异常只能用于非正常情况<br>需要对捕获的异常做处理<br>不要将过于庞大的代码块放在try中<br>在catch中指定具体的异常类型</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Error和Exception的区别</title>
    <url>/2021/09/10/Java-Error%E5%92%8CException%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[
        <h3 id="Error和Exception的区别"   >
          <a href="#Error和Exception的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h3>
      <p>首先介绍一下Java异常体系结构</p>
<p>Java中的异常有很多类型，异常在Java中被封装成了各种异常类</p>
<p>所有异常类型都是Throwable类的子类，它派生了两个子类：Error类和Exception类</p>

        <h4 id="1-Error类"   >
          <a href="#1-Error类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Error类" class="headerlink" title="1.Error类"></a>1.Error类</h4>
      <p>Error类：表示仅靠程序本身无法恢复的严重错误，一般是与虚拟机相关的问题，如内存溢出、动态链接失败、虚拟机错误。应用程序不应该抛出这种类型的错误（一般由虚拟机抛出）。假如出现这种错误，应尽力使程序安全退出。</p>

        <h4 id="2-Exception类"   >
          <a href="#2-Exception类" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Exception类" class="headerlink" title="2.Exception类"></a>2.Exception类</h4>
      <p>Exception类：由Java应用程序抛出和处理的非严重错误，如所需文件找不到、网络连接不通或连接中断、算术运算出错（如被零除）、数组下标越界、装载一个不存在的类、对null对象操作、类型转换异常等。它的各种不同的子类分别对应不同类型的异常。Exception又可分为两大类异常：运行时异常和Checked异常。</p>

        <h5 id="运行时异常"   >
          <a href="#运行时异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5>
      <p>包括RuntimeException及其所有子类。不要求程序必须对他们进行处理。如算数异常（ArithmeticException）。运行时异常在编译阶段不会出错，在运行阶段才会报错</p>

        <h5 id="Checked异常（非运行时异常）"   >
          <a href="#Checked异常（非运行时异常）" class="heading-link"><i class="fas fa-link"></i></a><a href="#Checked异常（非运行时异常）" class="headerlink" title="Checked异常（非运行时异常）"></a>Checked异常（非运行时异常）</h5>
      <p>除了运行时异常外的其他从Exception类继承来的异常类<br>当Checked异常出现时，程序必须处理该类异常，不处理编译就会报错</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>异常</tag>
        <tag>Error和Exception的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类</title>
    <url>/2021/09/10/Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[
        <h2 id="抽象类"   >
          <a href="#抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2>
      
        <h3 id="1-初识抽象类和抽象方法"   >
          <a href="#1-初识抽象类和抽象方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-初识抽象类和抽象方法" class="headerlink" title="1.初识抽象类和抽象方法"></a>1.初识抽象类和抽象方法</h3>
      
        <h4 id="1-1区分普通方法和抽象方法"   >
          <a href="#1-1区分普通方法和抽象方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1区分普通方法和抽象方法" class="headerlink" title="1.1区分普通方法和抽象方法"></a>1.1区分普通方法和抽象方法</h4>
      <p>  在<strong>Java</strong>中，当一个类的方法被<font color="blue"> abstract </font>关键字修饰时，该方法为抽象方法。</p>
<p>  <strong>抽象方法所在的类必须定义为抽象类</strong></p>
<p>当一个方法被定义为抽象方法之后，意味着该方法不会有具体实现，而是在抽象类的子类中通过重写进行实现。定义抽象方法的语法格式如下：</p>
<blockquote>
<p><strong>[访问修饰符] abstract &lt;返回类型&gt; &lt;方法名&gt; ([参数列表])；</strong></p>
</blockquote>
<p><font color="#f56b7f"> abstract 关键字表示该方法被定义为抽象方法。</font><br><font color=""></font><br>  普通方法和抽象方法的区别:</p>
<blockquote>
<ol>
<li>抽象方法需要用修饰符abstract修饰，普通方法不用</li>
<li> 抽象方法没有方法体，普通方法有方法体</li>
</ol>
</blockquote>

        <h4 id="1-2区分普通类和抽象类"   >
          <a href="#1-2区分普通类和抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2区分普通类和抽象类" class="headerlink" title="1.2区分普通类和抽象类"></a>1.2区分普通类和抽象类</h4>
      <p>  在Java中，当一个类被<font color="blue"> abstract </font>关键字修饰时，该类为抽象类。</p>
<p>  <strong>定义抽象类的语法格式如下：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">abstract class&lt;类名&gt;&#123;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><font color="blue"> abstract </font> 关键字表示该类被定义为抽象类。<br>  普通类和抽象类的区别：<br>   1.抽象类需要用<font color="blue"> abstract </font> 修饰符修饰，普通类不用<br>    2.抽象类不能被实例化 ，普通类可以。<br>   Dog dog = new Dog();这就是实例化</p>

        <h4 id="1-3定义一个抽象类"   >
          <a href="#1-3定义一个抽象类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3定义一个抽象类" class="headerlink" title="1.3定义一个抽象类"></a>1.3定义一个抽象类</h4>
      <p>   当一个类被定义为抽象类时，它可以包含各种类型的成员，包括属性、方法等，其中方法又可以分为普通方法和抽象方法，<strong>也就是说抽象类里可以有非抽象的方法</strong><br>   如抽象类结构图：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public abstract class 类名称&#123;</span><br><span class="line">	修饰符 abstract 返回类型 方法名(); &lt;------ 抽象方法</span><br><span class="line">	修饰符 返回类型 方法名()&#123;</span><br><span class="line">		普通方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>注意：</strong>抽象方法只能定义在抽象类中。但是抽象类中可以包含抽象方法，也可以包含普通方法，还可以包含普通类包含的一切成员</p>

        <h3 id="2-使用抽象类描述抽象事物"   >
          <a href="#2-使用抽象类描述抽象事物" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用抽象类描述抽象事物" class="headerlink" title="2.使用抽象类描述抽象事物"></a>2.使用抽象类描述抽象事物</h3>
      <p><strong>下面通过一个示例简单的认识抽象类和抽象方法的用法：</strong></p>
<p>有一个宠物类，宠物具体分为狗狗、企鹅等，实例化一个狗狗类、企鹅类是有意义的，而实例化一个宠物类则是不合理的，这里可以把宠物类定义为抽象类，避免宠物类被实例化</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//宠物抽象类 ，即狗狗和企鹅的父类</span><br><span class="line">public abstract class Pet &#123;</span><br><span class="line">	//属性  ： 昵称 健康度  亲密度</span><br><span class="line">	private String name =&quot;无名氏&quot;;//昵称</span><br><span class="line">	private int health = 100;//健康值</span><br><span class="line">	private int love = 0;//亲密度</span><br><span class="line">	</span><br><span class="line">	//无参构造</span><br><span class="line">	public Pet() &#123;&#125;</span><br><span class="line">	//有参构造</span><br><span class="line">	public Pet(String name, int health, int love) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.health = health;</span><br><span class="line">		this.love = love;</span><br><span class="line">	&#125;</span><br><span class="line">	//输出宠物信息</span><br><span class="line">	public void print()&#123;</span><br><span class="line">		System.out.println(&quot;宠物的自白:\n我的名字叫&quot;+this.name+&quot;,健康值是&quot;+this.health+&quot;,和主人的亲密度是:&quot;+this.love+&quot;。&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>注意抽象类是不能被实例化的，下面是个错误示例:</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">	public static viod main(Stirng[] args)&#123;</span><br><span class="line">		Pet pet = new Pet(&quot;贝贝&quot;);</span><br><span class="line">		pet.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>抽象类实例化会报个错：</strong></p>
<blockquote>
<p><strong>java.long.Error: Unresolved compilation problem: Cannot instantiate the type Pet</strong> </p>
</blockquote>
<p>抽象类不能直接实例化，但它的子类是可以实例化的，如果子类中没有重写print( )方法，子类将继承Pet类的该方法，但无法正确输出子类信息。在Java中可以将print( )方法定义为抽象方法，让子类重写该方法，下面展示此部分代码：</p>
<p><strong>在抽象的宠物类中定义抽象方法</strong></p>
<p><strong>具体代码如上面所示，这里只展示部分</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//把上面代码</span><br><span class="line">	public void print()&#123;</span><br><span class="line">		System.out.println(&quot;宠物的自白:\n我的名字叫&quot;+this.name+&quot;,健康值是&quot;+this.health+&quot;,和主人的亲密度是:&quot;+this.love+&quot;。&quot;);</span><br><span class="line">//替换为</span><br><span class="line">public abstract void print();</span><br></pre></td></tr></table></div></figure>

<p><strong>抽象宠物类子类：狗狗类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//子类 狗狗类</span><br><span class="line">public class Dog extends Pet &#123;</span><br><span class="line">	//狗狗的属性 品种</span><br><span class="line">	private String strain;//品种</span><br><span class="line">	private String name;//姓名</span><br><span class="line">	</span><br><span class="line">	//有参构造</span><br><span class="line">	public Dog(String strain)&#123;</span><br><span class="line">		this.strain=strain;</span><br><span class="line">	&#125;</span><br><span class="line">	//getter方法</span><br><span class="line">	public String getStrain() &#123;</span><br><span class="line">		return strain;</span><br><span class="line">	&#125;</span><br><span class="line">	//重写父类的print()方法</span><br><span class="line">	public void print() &#123;</span><br><span class="line">		System.out.println(&quot;我是一只&quot;+this.strain+&quot;。&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Pet dog = new Dog(&quot;哈士奇&quot;);</span><br><span class="line">		dog.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>抽象类和抽象方法的优势</strong></p>
<p>抽象类中已经实现的方法可以被其子类使用，使代码可以被复用；同时提供了抽象方法，保证了子类具有自身的独特性</p>
<p><strong>抽象类的局限性</strong></p>
<p>子类继承抽象父类之后，写出来的方法可能会出现代码重复，造成代码冗余</p>

        <h3 id="3-总结"   >
          <a href="#3-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3>
      <p><strong>抽象类与抽象方法的使用</strong><br>1.抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类<br>2.如果子类没有实现父类的所有抽象方法，子类必须被定义为抽象类<br>3.没有抽象构造方法，也没有抽象静态方法<br>4.抽象类中可以有非抽象的构造方法，创建子类的实例时可能调用</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>List-ArrayList</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-ArrayList/</url>
    <content><![CDATA[
        <h3 id="List接口"   >
          <a href="#List接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3>
      <p>Collection 接口是最基本的集合接口，<font color="#9400D3">可以存储一组不唯一，无序的对象。</font></p>
<p>List接口继承自Collection接口，List接口中<font color="#9400D3">存储一组不唯一，有序（插入顺序）的对象。</font>用户可使用索引访问List接口中的元素，类似于数组，List的接口中允许存放重复元素。</p>
<p>List接口常用的实现类有<font color="#9400D3"> ArrayList </font>和<font color="#9400D3"> LinkedList </font></p>

        <h4 id="1-ArrayList"   >
          <a href="#1-ArrayList" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h4>
      <p>ArrayList是对数组进行了封装，实现了长度可变的数组，而且和数组采用相同的存储方式，在内存中分配连续的空间如下图所示，那么可以说明<font color="#9400D3"> ArrayList </font>的底层是基于数组实现的。所以，经常称ArrayList为动态数组。<br>但它不等同于数组，<font color="#9400D3"> ArrayList </font>集合中可以添加任何类型的数据，并且添加的数据都将转换成<font color="#9400D3"> Object </font>类型，而在数组中只能添加同一类型的数据。<br><img src="https://img11.360buyimg.com/ddimg/jfs/t1/206276/38/448/6025/6110e489Ea9fc5281/f0410ead98641b7b.png" alt="20210809161637.png"></p>
<p><strong>ArrayList类提供了很多方法用于操作数据，下方表格是ArrayList类常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean add(Object obj)</td>
<td>在列表的末尾添加元素o，起始索引位置从0开始</td>
</tr>
<tr>
<td align="center">void add(int index,Object o)</td>
<td>在指定的索引位置添加元素o,索引位置必须介于0和列表中元素个数之间</td>
</tr>
<tr>
<td align="center">int size()</td>
<td>返回列表中的元素个数</td>
</tr>
<tr>
<td align="center">Object get(int index)</td>
<td>返回指定索引位置处的元素，取出的元素是Object类型，使用前需要进行强制类型转换</td>
</tr>
<tr>
<td align="center">void set(int index,Object obj)</td>
<td>将index索引位置的元素替换为obj元素</td>
</tr>
<tr>
<td align="center">boolean contains(Object o)</td>
<td>判断列表中是否存在指定元素o</td>
</tr>
<tr>
<td align="center">int indexOf(Object obj)</td>
<td>返回元素在集合中出现的索引位置</td>
</tr>
<tr>
<td align="center">boolean remove(Object o)</td>
<td>从列表中删除元素o</td>
</tr>
<tr>
<td align="center">Obejct remove(int index)</td>
<td>从列表中删除指定位置的元素，起始索引位置从0开始</td>
</tr>
</tbody></table></div>
<p><strong>下面示例用ArrayList常用方法动态操作数据：</strong></p>
<p>问题：<br>（1）判断集合中是否包含某元素<br>（2）移除索引为 0 的元素<br>（3）把索引为1的元素替换为其他元素<br>（4）输出某个元素所在的索引位置<br>（5）清空ArrayList集合中的数据<br>（6）判断ArrayList集合中是否包含数据</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 调用ArrayList的无参构造方法，创建集合对象。</span><br><span class="line">		 常用的ArrayList类的构造方法还有一个带参数的重载版本，即ArrayList (int initialCapacity),</span><br><span class="line">		 它构造一个具有初识容量的空列表。</span><br><span class="line">		*/</span><br><span class="line">		ArrayList list = new ArrayList();</span><br><span class="line">		list.add(&quot;张三丰&quot;);</span><br><span class="line">		list.add(&quot;郭靖&quot;);</span><br><span class="line">		list.add(&quot;杨过&quot;);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//(1)判断集合中是否包含&quot;李莫愁&quot;</span><br><span class="line">		System.out.println(list.contains(&quot;李莫愁&quot;));//不包含则输出false</span><br><span class="line">		//(2)把索引为0的数据移除</span><br><span class="line">		System.out.println(&quot;----------移除前----------&quot;);</span><br><span class="line">		for(int i=0;i&lt;=list.size();i++)&#123;</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		list.remove(0);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;----------移除后----------&quot;);</span><br><span class="line">		for(int i=0;i&lt;=list.size();i++)&#123;</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;#####################################&quot;);</span><br><span class="line">		</span><br><span class="line">		//(3)把索引为1的数据替换为&quot;黄蓉&quot;</span><br><span class="line">		System.out.println(&quot;----------替换前----------&quot;);</span><br><span class="line">		for(int i=0;i&lt;=list.size();i++)&#123;</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		list.set(1,&quot;黄蓉&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;----------替换后----------&quot;);</span><br><span class="line">		for(int i=0;i&lt;=list.size();i++)&#123;</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//(4)输出某个元素所在的索引位置,有数据输出所在位置的下标，没数据输出-1</span><br><span class="line">		System.out.println(list.indexOf(&quot;杨过&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//(5)清空ArrayList集合中的数据</span><br><span class="line">		System.out.println(&quot;----------清空前----------&quot;);</span><br><span class="line">		for(int i=0;i&lt;=list.size();i++)&#123;</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		for (Object o : list) &#123;</span><br><span class="line">			System.out.println(o);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		list.clear();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;----------清空后---------&quot;);</span><br><span class="line">		for(int i=0;i&lt;=list.size();i++)&#123;</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		//(6)判断ArrayList集合中是否包含数据,有数据输出 true 没数据输出false</span><br><span class="line">		list.clear();</span><br><span class="line">		for (Object obj : list) &#123;</span><br><span class="line">			System.out.print(obj);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(list.isEmpty());</span><br></pre></td></tr></table></div></figure>

<p>注意：调用ArrayList类的add(Object obj)方法时，添加到集合当中的数据将被转换为Object类型</p>
<p>下面使用ArrayList集合实现新闻的存储<br>存储新闻标题信息（包含ID、名称、创建者）<br>获取新闻标题的总数<br>可以逐条打印每条新闻标题的名称</p>
<p><strong>声明一个新闻对象</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//新闻标题类：ID 新闻标题 创建者</span><br><span class="line">public class NewsTitle &#123;</span><br><span class="line">	</span><br><span class="line">	private int id;</span><br><span class="line">	private String title;</span><br><span class="line">	private String author;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public NewsTitle() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public NewsTitle(int id, String title, String author) &#123;</span><br><span class="line"></span><br><span class="line">		this.id = id;</span><br><span class="line">		this.title = title;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getTitle() &#123;</span><br><span class="line">		return title;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setTitle(String title) &#123;</span><br><span class="line">		this.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getAuthor() &#123;</span><br><span class="line">		return author;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAuthor(String author) &#123;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>测试新闻对象</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class NewsMgr &#123;</span><br><span class="line">//对新闻标题的存储即操作（ArrayList）</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建新闻标题对象</span><br><span class="line">		NewsTitle title1 = new NewsTitle(1,&quot;北京热门景点故宫&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle title2 = new NewsTitle(1,&quot;北京热门景点长城&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle title3 = new NewsTitle(1,&quot;北京热门景点颐和园&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle title4 = new NewsTitle(1,&quot;北京热门景点北海&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle title5 = new NewsTitle(1,&quot;北京热门景点天安门&quot;,&quot;author&quot;);</span><br><span class="line">		</span><br><span class="line">		//创建集合对象,并且将新闻标题加入到集合中</span><br><span class="line">		ArrayList  list = new ArrayList();</span><br><span class="line">		//等同于数组中的list[0] = title1;</span><br><span class="line">		list.add(title1);</span><br><span class="line">		list.add(title2);</span><br><span class="line">		list.add(title3);</span><br><span class="line">		list.add(title4);</span><br><span class="line">		list.add(title5);</span><br><span class="line"></span><br><span class="line">		//获取新闻标题的总数</span><br><span class="line">		//ArrayList的size()方法等同于数组的length属性的作用</span><br><span class="line">		System.out.println(&quot;新闻标题一共有&quot;+list.size()+&quot;条。&quot;);</span><br><span class="line">		//逐条打印新闻标题名称</span><br><span class="line">		//方法一：遍历ArrayList元素的位置(下标)</span><br><span class="line">		for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">			NewsTitle title = (NewsTitle)list.get(i);</span><br><span class="line">			System.out.println(title.getTitle());</span><br><span class="line">		&#125;</span><br><span class="line">		//方法二:增强型for</span><br><span class="line">		System.out.println(&quot;#############################&quot;);</span><br><span class="line">		for (Object obj : list) &#123;</span><br><span class="line">			NewsTitle title = (NewsTitle)obj;</span><br><span class="line">			System.out.println(title.getTitle());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>ArrayList优点：ArrayList集合因为可以使用索引来直接获取元素，遍历元素和随机访问元素的效率比较高。但是由于ArrayList集合采用了和数组相同的存储方式，在内存中分配连续的空间，因此在添加和删除非尾部元素时会导致后面所有元素的移动，这就造成在插入、删除操作频繁的应用场景下使用ArrayList会导致性能低下，所以数据操作频繁时，最好用LinkedList存储数据。</p>
<p>Collection接口常用通用方法有:clear()、isEmpty()、iterator()、toArray()<br>clear()：清空集合<br>isEmpty()：判断一个集合是否为空<br>iterator()：获取遍历集合的迭代器<br>toArray()：把一个集合转变成一个序列</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>ArrayList</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2021/09/10/Java-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[
        <h4 id="接口"   >
          <a href="#接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口" class="headerlink" title="接口"></a>接口</h4>
      <p>上面了解到了抽象类的局限性，解决这个问题最理想的方式就是使用接口</p>

        <h4 id="1-什么是接口？"   >
          <a href="#1-什么是接口？" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-什么是接口？" class="headerlink" title="1. 什么是接口？"></a>1. 什么是接口？</h4>
      <p>Java中接口的作用和生活中的接口类似，它提供一种约定，使得实现接口的类（或结构）在形式上保持一致<br>概念性的接口，指系统对外提供的所有服务<br><font color="blue"> interface </font>定义的是实实在在的接口，即接口类型<br>接口的存在弥补了Java单根继承的缺点</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">[访问修饰] interface 接口名称 [extends 其他接口名]&#123;</span><br><span class="line">	//声明变量</span><br><span class="line">	//声明方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface MyInterface&#123;</span><br><span class="line">	public void foo();</span><br><span class="line">	//其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="JDK8之前的接口特性"   >
          <a href="#JDK8之前的接口特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#JDK8之前的接口特性" class="headerlink" title="JDK8之前的接口特性"></a>JDK8之前的接口特性</h4>
      <blockquote>
<p>1.接口中的变量都是静态常量( public static final ) ，必须显式初始化<br>2.接口中所有方法默认都是public abstract<br>3.接口没有构造方法，不可以被实例化，但可以被实现(常作为类型使用)<br>4.实现类必须实现接口的所有方法<br>5.实现类可以实现多个接口 (Java中的多继承)<br>6.implements、多个接口使用逗号隔开</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">	//静态常量:接口中的变量必须是publication </span><br><span class="line">	public static final double PI=3.14;</span><br><span class="line">	//等同于</span><br><span class="line">	double PI=3.14;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	int m2(); 等同于 public abstract int m2();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="2-接口初体验"   >
          <a href="#2-接口初体验" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-接口初体验" class="headerlink" title="2. 接口初体验"></a>2. 接口初体验</h4>
      <p>用程序描述接口</p>
<p> 电脑主机有USB接口，鼠标和键盘需要用USB插头插到电脑上来使用<br> USB接口本市没有实现任何功能<br> USB接口规定了数据传输的要求<br> USB接口可以被多种USB设备实现</p>
<p><strong>根据USB接口可以使用Java接口来实现</strong><br>    1.编写USB接口   根据需求设置方法<br>    2.实现USB接口   实现所有方法<br>    3.使用USB接口   用多态的方式使用</p>
<p><strong>下面用代码来展示一下具体写法</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//USB接口：描述连接计算机和外部设备的串口总线标准</span><br><span class="line">//        定义一种输入输出接口的技术规范</span><br><span class="line">public interface USB &#123;</span><br><span class="line">	//USB接口并不实现具体功能，通过抽象方法来定义一种数据输入输出规范和标准</span><br><span class="line">	void service();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//满足USB标准的U盘</span><br><span class="line">public class USBDisk implements USB&#123;</span><br><span class="line">	public void service()&#123;</span><br><span class="line">		System.out.println(&quot;U盘：连接USB接口，传输数据&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//满足USB标准的风扇</span><br><span class="line">public class USBFan implements USB&#123;</span><br><span class="line">	public void service()&#123;</span><br><span class="line">		System.out.println(&quot;风扇：连接USB接口，获得电流，风扇转动&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//使用接口</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//USB风扇</span><br><span class="line">		USB uFan = new USBFan();</span><br><span class="line">		uFan.service();</span><br><span class="line">		//USB U盘</span><br><span class="line">		USB uDisk = new USBDisk();</span><br><span class="line">		uDisk.service();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>从上面例子看到了接口的简单使用可以知道：</p>
<p>1.接口表示一种能力(体现在接口的方法上)</p>
<p>2.面向接口编程<br>  <strong>程序设计时：</strong><br>  关心实现类有何能力，而不关心实现细节<br>  面向接口的约而不考虑接口的具体实现</p>

        <h4 id="3-面向接口编程"   >
          <a href="#3-面向接口编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-面向接口编程" class="headerlink" title="3. 面向接口编程"></a>3. 面向接口编程</h4>
      <p><strong>案例：实现防盗门功能</strong><br>防盗门功能：<strong>开门、关门、开锁、关锁</strong></p>
<p><strong>类图</strong><br><img src="https://img02.sogoucdn.com/app/a/100540022/2021080515183620645442.png" alt="20210805151759.png"></p>
<p>定义父类 门 ：Door</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//门 ：抽象方法 开门 关门</span><br><span class="line">public abstract class Door &#123;</span><br><span class="line">	public abstract void open();</span><br><span class="line">	public abstract void close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>定义子类 防盗门 : TheftproofDoor </p>
<p><strong>子类既继承门又实现锁的功能</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//防盗门：是门(is-a)，具备锁的能力(has-a)</span><br><span class="line">public class TheftproofDoor extends Door implements Lock &#123;</span><br><span class="line">	//上锁</span><br><span class="line">	public void lockUp() &#123;</span><br><span class="line">		System.out.println(&quot;锁门&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	//开锁</span><br><span class="line">	public void openLock() &#123;</span><br><span class="line">		System.out.println(&quot;开锁&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	//开门</span><br><span class="line">	public void open() &#123;</span><br><span class="line">		System.out.println(&quot;开门&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	//关门</span><br><span class="line">	public void close() &#123;</span><br><span class="line">		System.out.println(&quot;关门&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>定义接口 ：锁 ：Lock </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//锁 ：开锁 上锁</span><br><span class="line">public interface Lock &#123;</span><br><span class="line">	void lockUp();</span><br><span class="line">	void openLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>测试类: 测试开门、关门、锁门、开锁等功能</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//测试防盗门功能</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TheftproofDoor d= new TheftproofDoor();		</span><br><span class="line">		//开门开锁</span><br><span class="line">		d.openLock();</span><br><span class="line">		d.open();</span><br><span class="line">		//关门上锁</span><br><span class="line">		d.close();</span><br><span class="line">		d.lockUp();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>还可以加一个门拍照的功能</p>
<p>接口表示一种能力，一个人可以有多种能力，一个类可以实现多个接口</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java-接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Collections类及常用方法</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-Collections%E7%B1%BB/</url>
    <content><![CDATA[
        <h3 id="Collections类及常用方法"   >
          <a href="#Collections类及常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Collections类及常用方法" class="headerlink" title="Collections类及常用方法"></a>Collections类及常用方法</h3>
      <p>Collections类是Java提供的一个集合操作工具类，它包含了大量的静态方法们用于实现对集合元素的排序、查找和替换等操作</p>
<p>Collections 和 Collection不同，前者是集合的操作类，后者是集合的接口</p>
<p>Collections提供的常用的静态方法</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sort()</td>
<td align="center">排序</td>
</tr>
<tr>
<td align="center">binarySearch()</td>
<td align="center">查找</td>
</tr>
<tr>
<td align="center">max()\min()</td>
<td align="center">查找最大\最小值</td>
</tr>
<tr>
<td align="center">reverse()</td>
<td align="center">反转元素顺序</td>
</tr>
</tbody></table></div>

        <h4 id="Collections类的用方法示例："   >
          <a href="#Collections类的用方法示例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Collections类的用方法示例：" class="headerlink" title="Collections类的用方法示例："></a>Collections类的用方法示例：</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class TestCollections &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//Collections常用方法</span><br><span class="line">		List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(&quot;zhc&quot;);</span><br><span class="line">		list.add(&quot;ykp&quot;);</span><br><span class="line">		list.add(&quot;hwz&quot;);</span><br><span class="line">		list.add(&quot;hs&quot;);</span><br><span class="line">		list.add(&quot;dadada&quot;);</span><br><span class="line">		list.add(&quot;zoo&quot;);</span><br><span class="line">		list.add(&quot;sda&quot;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">		for (String s : list) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">		//使用Collections对集合进行升序排列</span><br><span class="line">		Collections.sort(list);</span><br><span class="line">		for (String s : list) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-----------------------&quot;);</span><br><span class="line">		//查找集合元素的最大、最小值</span><br><span class="line">		System.out.println(&quot;集合中的最大值:&quot;+Collections.max(list));</span><br><span class="line">		//查找集合元素的最大、最小值</span><br><span class="line">		System.out.println(&quot;集合中的最小值:&quot;+Collections.min(list));</span><br><span class="line">		//查找集合中特定的元素</span><br><span class="line">		System.out.println(Collections.binarySearch(list,&quot;zoo&quot;));</span><br><span class="line">		//反转排列顺序</span><br><span class="line">		Collections.reverse(list);</span><br><span class="line">		for (String s : list) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="对集合元素排序查找"   >
          <a href="#对集合元素排序查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#对集合元素排序查找" class="headerlink" title="对集合元素排序查找"></a>对集合元素排序查找</h4>
      <p>排序是针对集合的一个常见需求。要排序就要知道两个元素哪个大哪个小。在Java中，如果要实现一个类的对象之间比较大小，那么这个类就要实现Comparable接口。</p>
<p>此接口强行对实现它的每个类的对象进行整体排序。</p>
<p>这种排序被称为类的自然排序，类的compareTo( )方法被称为它的自然比较方法。此方法用于比较此对象与指定对象的顺序，如果小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p>
<p><strong>compareTo方法的定义语法格式如下:</strong></p>
<blockquote>
<p>int  compareTo(Object obj);</p>
</blockquote>
<p>其中有参数和返回值</p>
<p>参数：obj即要比较的对象<br>返回值：负整数、零或正整数，根据此对象是小于、等于还是大于指定返回对象返回不同的值。</p>
<p>实现此接口的对象列表（和数组）可以通过Collections.sort( )方法（和Arrays.sort( )方法）进行自动排序。下面通过示例来体验</p>
<p>学生实体类，compareTo( )在此段代码的最后</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//实现Comparable接口</span><br><span class="line">public class Student implements Comparable&#123;</span><br><span class="line">	private int no;</span><br><span class="line">	private String name;</span><br><span class="line">	private String sex;</span><br><span class="line">	</span><br><span class="line">	public Student() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public Student(int no, String name, String sex) &#123;</span><br><span class="line">	</span><br><span class="line">		this.no = no;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Student [no=&quot; + no + &quot;, name=&quot; + name + &quot;, sex=&quot; + sex + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getNo() &#123;</span><br><span class="line">		return no;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNo(int no) &#123;</span><br><span class="line">		this.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSex() &#123;</span><br><span class="line">		return sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSex(String sex) &#123;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//重写方法：定义学生对象的比较规则</span><br><span class="line">	//比较规则：按学号升序排列</span><br><span class="line">	//比较对象：当前学生对象（this） 和Object o</span><br><span class="line">	public int compareTo(Object o) &#123;</span><br><span class="line">		Student student = (Student)o;</span><br><span class="line">		if(this.no==student.no)&#123;</span><br><span class="line">			return 0;//学号相同个，两个对象一般大</span><br><span class="line">		&#125;else if(this.no&gt; student.no)&#123;</span><br><span class="line">			return 1;//当前学生对象学号大于比较的学生对象学号</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			return -1;//当前学生对象学号小于比较的学生对象学号</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>元素之间可以比较大小之后，就可以使用Collections类的sort( )方法对元素进行排序操作了。</p>
<p>前面介绍过List接口和Map接口，Map接口本身是无序的，所以不能对Map接口做排序操作。但是List是有序的，所以可以对List接口进行排序。</p>
<p>注意：List接口中存放的元素，必须是实现了Comparable接口的元素才可以</p>
<p>下面示例是使用Collections类的静态方法sort( ) 和binarySearch( )对List集合进行排序                                                                                             </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//Collections常用方法</span><br><span class="line">		List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();</span><br><span class="line">		Student s1= new Student(1,&quot;张三&quot;,&quot;男&quot;);</span><br><span class="line">		Student s2= new Student(2,&quot;李四&quot;,&quot;男&quot;);</span><br><span class="line">		Student s3= new Student(3,&quot;李丽丽&quot;,&quot;女&quot;);</span><br><span class="line">		Student s4= new Student(4,&quot;刘立春&quot;,&quot;女&quot;);</span><br><span class="line">		list.add(s1);</span><br><span class="line">		list.add(s2);</span><br><span class="line">		list.add(s3);</span><br><span class="line">		list.add(s4);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;-----------排序前-----------&quot;);</span><br><span class="line">		for (Student stu : list) &#123;</span><br><span class="line">			System.out.println(stu);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-----------排序后-升序排序-----------&quot;);</span><br><span class="line">		//使用Collections类的sort()对集合进行升序排列</span><br><span class="line">		Collections.sort(list);</span><br><span class="line">		for (Student stu : list) &#123;</span><br><span class="line">			System.out.println(stu);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-----------排序后-降序排序-----------&quot;);</span><br><span class="line">		//使用Collections类的reverse()反转排列顺序</span><br><span class="line">		Collections.reverse(list);</span><br><span class="line">		for (Student stu  : list) &#123;</span><br><span class="line">			System.out.println(stu);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>Collections</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流(输入、输入流)</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-IO%E6%B5%81/</url>
    <content><![CDATA[
        <h3 id="Java-I-O"   >
          <a href="#Java-I-O" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h3>
      
        <h4 id="Java-IO原理"   >
          <a href="#Java-IO原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-IO原理" class="headerlink" title="Java IO原理"></a>Java IO原理</h4>
      <p>I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</p>
<p>Java程序汇总，对于数据的输入/输出操作以“流(Stream)”的方式进行。</p>
<p>流：是一种抽象概念，是对数据传输的总称，也就是说数据在设备间的传输称为流，流的本质是数据传输</p>
<p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据    ，并通过标准的方法输入或输出数据。</p>
<p>其中java.io.File类就是对文件进行操作的，包括对文件和目录属性的操作、对文件读写的操作等。</p>

        <h4 id="java-io-File类"   >
          <a href="#java-io-File类" class="heading-link"><i class="fas fa-link"></i></a><a href="#java-io-File类" class="headerlink" title="java.io.File类"></a>java.io.File类</h4>
      <p>File对象既可表示文件，也可表示目录，在程序中一个File对象可以代表一个文件或目录。利用它可用来对文件或目录进行基本操作。它可以查出与文件相关的信息，如名称、最后修改日期、文件大小等。</p>
<p><strong>File类的构造方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">File(String dir,String subpath)</td>
<td align="center">在指定目录下常见指定文件名的文件;dir参数指定目录路径，subpath参数指定文件名</td>
</tr>
<tr>
<td align="center">File(String parent,String subpath)</td>
<td align="center">根据一个文件对象和一个子文件构造文件对象；parent参数指定目录文件，subpath参数指定文件名</td>
</tr>
</tbody></table></div>
<p><strong>File类的常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean exists()</td>
<td align="center">测试文件是否存在</td>
</tr>
<tr>
<td align="center">boolean isFile()</td>
<td align="center">判断是否是文件</td>
</tr>
<tr>
<td align="center">boolean isDirectory</td>
<td align="center">判断是否是目录</td>
</tr>
<tr>
<td align="center">String getPath()</td>
<td align="center">返回此对象表示的文件的相对路径名</td>
</tr>
<tr>
<td align="center">String getAbsolutePath()</td>
<td align="center">返回此对象表示的文件的绝对路径名</td>
</tr>
<tr>
<td align="center">String getName()</td>
<td align="center">返回此对象的文件或目录的名称</td>
</tr>
<tr>
<td align="center">boolean delete()</td>
<td align="center">删除此对象指定的文件或目录</td>
</tr>
<tr>
<td align="center">boolean createNewFile()</td>
<td align="center">创建名称的空文件，不创建文件夹</td>
</tr>
<tr>
<td align="center">boolean mkdir()</td>
<td align="center">创建一个目录，它的路径名由当前File对象指定</td>
</tr>
<tr>
<td align="center">boolean mkdirs()</td>
<td align="center">创建包括父目录的目录</td>
</tr>
<tr>
<td align="center">long length()</td>
<td align="center">返回文件的长度，单位为字节，如果文件不存在，则返回0L</td>
</tr>
<tr>
<td align="center">long lastModified()</td>
<td align="center">获取文件或目录的最后修改日期</td>
</tr>
</tbody></table></div>
<p><strong>案例：文件的创建、查询和删除</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class TestCreateFile &#123;</span><br><span class="line">    //创建文件</span><br><span class="line">    public void create(File file)&#123;</span><br><span class="line">        if(!file.exists())&#123;</span><br><span class="line">            //如果文件不存在，创建文件</span><br><span class="line">            try &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">                System.out.println(&quot;文件已创建&quot;);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取文件信息</span><br><span class="line">    public void showFileInfo(File file)&#123;</span><br><span class="line">        if (file.exists())&#123;</span><br><span class="line">            if(file.isFile())&#123;</span><br><span class="line">                //是文件</span><br><span class="line">                System.out.println(&quot;文件名称:&quot;+file.getName());</span><br><span class="line">                System.out.println(&quot;文件相对路径：&quot;+file.getPath());</span><br><span class="line">                System.out.println(&quot;文件绝对路径：&quot;+file.getAbsolutePath());</span><br><span class="line">                System.out.println(&quot;文件的长度：&quot;+file.length()+&quot;个字节&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(file.isDirectory())&#123;</span><br><span class="line">                //是目录</span><br><span class="line">                System.out.println(&quot;此文件是目录&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;文件不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删除文件</span><br><span class="line">    public void delete(File file)&#123;</span><br><span class="line">        if(file.exists())&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            System.out.println(&quot;文件已删除！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //测试方法</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestCreateFile fileDemo = new TestCreateFile();</span><br><span class="line">        //不加路径直接创建文件会创建在项目中</span><br><span class="line">        File file = new File(&quot;E:/TestFile/test.txt&quot;);</span><br><span class="line">        fileDemo.create(file);</span><br><span class="line">        fileDemo.showFileInfo(file);</span><br><span class="line">        fileDemo.delete(file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h4 id="java中的流"   >
          <a href="#java中的流" class="heading-link"><i class="fas fa-link"></i></a><a href="#java中的流" class="headerlink" title="java中的流"></a>java中的流</h4>
      <p>前面讲述了如何利用java.io包的File类对文件或目录的属性进行操作，但File类不能访问文件的内容，就是不能从文件中读取数据或往文件里写数据</p>
<p>读文件是指把文件中的数据读取到内存中。反之，写文件是把内存中的数据写到文件中，要通过流来读写文件</p>
<p>流是指一连串流动的字符，是一组有序的数据序列，是以<font color="red">先进先出</font>的方式发送和接收数据的通道，如下图所示</p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/202013/17/2325/13587/61209013E127ae10a/c7973d98f6162dd3.png" alt="20210821133231.png"></p>
<p>流分为输入流和输出流。输入/输出流是相对于计算机内存来说的，如果数据输入到内存，则称为输入流，如果从内存中输出则称为输出流。</p>
<p>Java的输出流主要由 OutputStream 和 Writer 作为基类，而输入流主要由 InputStream 和 Reader 作为基类。</p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/177537/30/20366/74568/61209739Edb3f3229/124d6c3054d3ac51.png" alt="20210821135527.png"></p>
<p>在 java.io 包中封装了许多输入/输出流的 API 。在程序中，这些输入/输出流类的对象称为流对象。可以通过这些流对象将内存中的数据以流的方式写入文件，也可以通过流对象将文件中的数据以流的方式读取到内存 。</p>
<p>构造流对象时旺旺回合数据源（如文件）联系起来。数据源分为源数据源和目标数据源。输入流关联的是源数据源，输出流关联的是目标数据源如下图所示</p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/178018/12/20397/91404/612098adE1cb09e8a/9f81225728e9bd81.png" alt="0210821140922.png"></p>
<p><strong>输入/输出流又分为字节流和字符流两种形式，如下如所示</strong></p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/193235/17/19195/134349/61209765E50985742/131bffd585e3af3c.png" alt="20210821140156.png"></p>
<p><strong>字节流是8位通用字节流，其基本单位是字节。</strong>字节流的基类是 InputStream类和 OutputStream类， 它们是抽象类</p>
<p><strong>字符流是16位Unicode字符流，基本单位是Unicode字符。</strong>字符流最适合用来处理字符串和文本。因为它们支持国际上大多数的字符集和语言。字符流的基类是Reader类和Writer类，它们也是抽象类</p>
<p>一个被访问的基本特征都是通过实现这4个抽象类的方法来建立的。这些类的常用方法如下</p>
<p><strong>InputStream类常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流中读取下一个字节数据</td>
</tr>
<tr>
<td align="center">int read(byte[] b)</td>
<td align="center">从输入流中读取数据，并将数据存储在缓冲区数组b中，返回实际读取的字节数</td>
</tr>
<tr>
<td align="center">int read(byte[] b,int off,int len)</td>
<td align="center">从输入流中读取最多len长度的字节，保存到字节数组b中，保存的位置从off开始</td>
</tr>
<tr>
<td align="center">int available()</td>
<td align="center">可以从输入流中读取的字节数目</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输入流</td>
</tr>
</tbody></table></div>
<p>InputStream类的常用子类有FileInputStream，用于从文件中读取数据</p>
<br/>

<p><strong>OutputStream类的常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void wtite(int c)</td>
<td align="center">将指定的字节数据写入此输入流</td>
</tr>
<tr>
<td align="center">void write(byte[] buf)</td>
<td align="center">将数组buf中的所有字节写入此输出流中</td>
</tr>
<tr>
<td align="center">void write(byte[] b,int off,int len)</td>
<td align="center">将字节数组中从偏移量off开始的长度为len的字节数据输出到输出流中</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输出流</td>
</tr>
</tbody></table></div>
<p>OutputStream类的常用子类有FileOutputStream，用于向文件写数据</p>
<br/>

<p><strong>Reader类的常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流中读取单个字符，返回所读取的字符数据</td>
</tr>
<tr>
<td align="center">int read(byte[] b)</td>
<td align="center">从输入流中最多读取c.length个字符，保存到字符数组c中，返回实际的字符数</td>
</tr>
<tr>
<td align="center">int read(byte[] b,int off,int len)</td>
<td align="center">从输入流中读取最多len个字符，保存到字符数组c中，保存的位置从off位置开始，返回实际读取的字符数</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输入流</td>
</tr>
</tbody></table></div>
<p>Reader类的常用子类为BufferReader，接受Reader对象作为参数，并对其添加字符缓冲器</p>
<br/>

<p><strong>Writer类的常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void wtite(String str)</td>
<td align="center">将str字符串例包含的字符输出到指定的输出流中</td>
</tr>
<tr>
<td align="center">void write(String str,int off,int len)</td>
<td align="center">将str字符串里重off位置开始，长度为len的多个字符输出到输出流中</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输出流</td>
</tr>
<tr>
<td align="center">void flush()</td>
<td align="center">刷新输出流</td>
</tr>
</tbody></table></div>
<p>Writer类的常用子类为BufferWriter，用于将数据缓冲到字符输出流</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>1.在操作上字节流和字符流有一个区别，字符流在操作时使用了缓冲区（内部存储器），而字节流在操作时字节操作文件，不会使用缓冲区<br>2.所有的这些方法在出现错误时都会抛出IOException异常</p>
</blockquote>

        <h4 id="FileInputStream练习"   >
          <a href="#FileInputStream练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileInputStream练习" class="headerlink" title="FileInputStream练习"></a>FileInputStream练习</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//通过字节输入流完成对文件的读操作</span><br><span class="line">public class FileInputStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建FileInputStream对象</span><br><span class="line">            fis = new FileInputStream(&quot;E:/TestFile/test.txt&quot;);</span><br><span class="line">            //借助FileInputStream对象的read()方法读取文件</span><br><span class="line">           /* int data;//读取到的每个字节的整数表示形式，如 h--104</span><br><span class="line">            System.out.println(&quot;字节数：\n&quot;+fis.available());</span><br><span class="line">            while ((data = fis.read())!=-1)&#123;</span><br><span class="line">                System.out.print((char)data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n字节数：&quot;+fis.available());*/</span><br><span class="line">            //借助FileInputStream对象的read(byte[])方法读取文件</span><br><span class="line">            byte[] b = new byte[1024];</span><br><span class="line">            int data;//读取到的字节数</span><br><span class="line">            while ((data = fis.read(b))!=-1)&#123;</span><br><span class="line">                //字节读取到了字节数组b中，需要循环输出b的内容</span><br><span class="line">                //for(int i =0;i&lt;b.length;i++)&#123;</span><br><span class="line">                for(int i =0;i&lt;data;i++)&#123;</span><br><span class="line">                    System.out.print((char) b[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;catch (FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="FileOutputStream练习"   >
          <a href="#FileOutputStream练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileOutputStream练习" class="headerlink" title="FileOutputStream练习"></a>FileOutputStream练习</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//通过字节输出流完成对文件的写入操作</span><br><span class="line">public class FileOuputStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream fos=null;</span><br><span class="line">        //创建字节输出流对象(OutputStream)</span><br><span class="line">        //fos = new FileOutputStream(&quot;E:/testFile/test.txt&quot;);</span><br><span class="line">        //ture:不覆盖源文件内容，在末尾追加新的内容</span><br><span class="line">        fos = new FileOutputStream(&quot;E:/testFile/test.txt&quot;,true);</span><br><span class="line">        //调用字节输出流对象(OutputStream)的write方法写入文件</span><br><span class="line">        String info = &quot;好好学Java,挣钱养老婆&quot;;</span><br><span class="line">        //将写入的字符串打散为一个字节数组</span><br><span class="line">        byte[] infos = info.getBytes();</span><br><span class="line">        fos.write(infos,0,infos.length);</span><br><span class="line">        System.out.println(&quot;test文件已被更新&quot;);</span><br><span class="line">        //关闭输出流</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>InputStream 和 OutputStream综合案例，读取文件中的内容，并把内容赋值给另一个文档</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream fis=null;</span><br><span class="line">        FileOutputStream fos = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            fis = new FileInputStream(&quot;E:/TestFile/test.txt&quot;);</span><br><span class="line">            fos = new FileOutputStream(&quot;E:/TestFile/test1.txt&quot;);</span><br><span class="line">            byte[] words = new byte[1024];</span><br><span class="line">            int len =-1;</span><br><span class="line">            //文件中的内容读取出来存放到了字节数组words中</span><br><span class="line">            while ((len=fis.read(words))!=-1)&#123;</span><br><span class="line">                //将字节数组words写出到输出流fos中</span><br><span class="line">                fos.write(words,0,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;文件赋值完毕&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



        <h4 id="FileReader练习"   >
          <a href="#FileReader练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileReader练习" class="headerlink" title="FileReader练习"></a>FileReader练习</h4>
      <p>FileReader类是Reader的孙子类，因为Reader是抽象类，不能被实例化，所以就用FileReader来实现具体的方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//1.引入资源</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">//借助字符输入流FileReader读取文件</span><br><span class="line">public class FileReaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileReader fr = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //2.创建字符输入流FileReader对象</span><br><span class="line">            fr =  new FileReader(&quot;E:/TestFile/test.txt&quot;);</span><br><span class="line">            //3.调用FileReader对象的read()方法</span><br><span class="line">            StringBuffer sb = new StringBuffer();</span><br><span class="line">            char[] ch = new char[1024];</span><br><span class="line">            int len =-1;</span><br><span class="line">            while ((len = fr.read(ch))!=-1)&#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //4.关闭字符输入流</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h4 id="InputStreamReader练习"   >
          <a href="#InputStreamReader练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#InputStreamReader练习" class="headerlink" title="InputStreamReader练习"></a>InputStreamReader练习</h4>
      <p>在读取文档内容时，有时会出现中文乱码的情况，有两种办法修改，一种是修改IDE开发工具中的编码格式和修改文档的编码格式，另一种是通过InputStreamReader来实现</p>
<p>InputSrreamReader(InputStream in,String charsetName)中的 charsetName可以设置字符的编码格式</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//借助字符输入流FileReader读取文件</span><br><span class="line">public class FileReaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Reader fr = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //2.创建字符输入流FileInputStream对象</span><br><span class="line">            FileInputStream fis = new FileInputStream(&quot;E:/TestFile/test.txt&quot;);</span><br><span class="line">            fr =  new InputStreamReader(fis,&quot;UTF-8&quot;);</span><br><span class="line">            //3.调用FileInputStream 对象的read()方法</span><br><span class="line">            StringBuffer sb = new StringBuffer();</span><br><span class="line">            char[] ch = new char[1024];</span><br><span class="line">            int len =-1;</span><br><span class="line">            while ((len = fr.read(ch))!=-1)&#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //4.关闭字符输入流</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="BufferedReader练习"   >
          <a href="#BufferedReader练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#BufferedReader练习" class="headerlink" title="BufferedReader练习"></a>BufferedReader练习</h4>
      <p>如何提高字符流读取文本文件的效率？</p>
<p>使用BufferedReader类</p>
<p>BufferedReader 类是Reader的子类<br>BufferedReader 类带有缓冲区<br>按行读取内容的readLine()方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//1.引入资源</span><br><span class="line">import java.io.*;</span><br><span class="line">//借助字符输入流BufferedReader读取文件</span><br><span class="line">public class BufferReaderDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        Reader fr = null;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取本地字符编码格</span><br><span class="line">            System.out.println(System.getProperty(&quot;file.encoding&quot;));</span><br><span class="line">            //2.创建字符输入流FileReader对象</span><br><span class="line">            fis = new FileInputStream(&quot;E:/TestFile/test.txt&quot;);</span><br><span class="line">            fr =  new InputStreamReader(fis,&quot;UTF-8&quot;);</span><br><span class="line">            br = new BufferedReader(fr);</span><br><span class="line">            //3.调用FileReader对象的read()方法</span><br><span class="line">            String s = null;</span><br><span class="line">            while ((s =br.readLine()) !=null)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //4.关闭字符输入流</span><br><span class="line">                br.close();</span><br><span class="line">                fr.close();</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="FileWriter练习"   >
          <a href="#FileWriter练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileWriter练习" class="headerlink" title="FileWriter练习"></a>FileWriter练习</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//借助字符输出流 Writer-FileWriter往文件中写入内容</span><br><span class="line">public class FileWriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Writer writer = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            writer = new FileWriter(&quot;text.txt&quot;);</span><br><span class="line">            String s =&quot;赚钱养老婆&quot;;</span><br><span class="line">            //writer.write(s);</span><br><span class="line">            //指定特定字符串的特定内容写入文件</span><br><span class="line">            writer.write(s,0,2);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="OutputStreamWriter练习"   >
          <a href="#OutputStreamWriter练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#OutputStreamWriter练习" class="headerlink" title="OutputStreamWriter练习"></a>OutputStreamWriter练习</h4>
      <p>OutputStream和InputStream一样，都可以解决乱码</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//借助字符输出流 Writer- OutputStreamWriter往文件中写入内容-解决中文乱码</span><br><span class="line">public class OutputStreamWriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileOutputStream fos =null;</span><br><span class="line">        OutputStreamWriter osw =null;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(System.getProperty(&quot;file.encoding&quot;));</span><br><span class="line">            fos = new FileOutputStream(&quot;text.txt&quot;);</span><br><span class="line">            //字符输出流：把一个字节输出流做了包装，包装的同时指定字符编码格式</span><br><span class="line">            osw = new OutputStreamWriter(fos,&quot;utf-8&quot;);</span><br><span class="line">            String s =&quot;赚钱养老婆&quot;;</span><br><span class="line">            osw.write(s);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               osw.close();</span><br><span class="line">               fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="BufferedWriter练习"   >
          <a href="#BufferedWriter练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#BufferedWriter练习" class="headerlink" title="BufferedWriter练习"></a>BufferedWriter练习</h4>
      <p>BufferedWriter和BufferedReader一样都是提高写文本文件的效率的</p>
<p>BufferedWriter类是Writer类的子类<br>BufferedWriter类带有缓冲区</p>
<p>BufferedWriter常用的构造方法<br>BufferedWriter(Writer out)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//借助字符输出流 BufferedWriter 往文件中写入内容-缓冲区，提高效率</span><br><span class="line">public class BufferedWriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FileOutputStream fos =null;</span><br><span class="line">        OutputStreamWriter osw =null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(System.getProperty(&quot;file.encoding&quot;));</span><br><span class="line">            fos = new FileOutputStream(&quot;text.txt&quot;);</span><br><span class="line">            //字符输出流：把一个字节输出流做了包装，包装的同时指定字符编码格式</span><br><span class="line">            osw = new OutputStreamWriter(fos,&quot;utf-8&quot;);</span><br><span class="line">            //带缓冲区的字符输出流</span><br><span class="line">            bw=new BufferedWriter(osw);</span><br><span class="line">            bw.write(&quot;第一行内容&quot;);</span><br><span class="line">            //bw.newLine();，类似于换行</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(&quot;第二行内容&quot;);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.write(&quot;第三行内容&quot;);</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               osw.close();</span><br><span class="line">               fos.close();</span><br><span class="line">               bw.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="字符输入输出流综合案例"   >
          <a href="#字符输入输出流综合案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符输入输出流综合案例" class="headerlink" title="字符输入输出流综合案例"></a>字符输入输出流综合案例</h4>
      <p>替换文本文件内容</p>
<p>需求说明</p>
<p>读取末班文件pet.template的模板格式内容(保存宠物数据)，把{name}、{type}、{master}替换为具体的宠物信息，将替换后的内容重新写入到文本文件中</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">package cn.bj.DemoWriter;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">//读取模板文件pet.template的模板格式内容(保存宠物数据)</span><br><span class="line">//把&#123;name&#125;、&#123;type&#125;、&#123;master&#125;替换为具体的宠物信息</span><br><span class="line">//将替换后的内容重新写入到pet.txt中</span><br><span class="line">public class ReaderAndWriter &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用带缓冲区的字符输入流读取文件pet.template</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        InputStreamReader isr = null;</span><br><span class="line">        //使用带缓冲区的字符输出流把替换后的新内容写入到pet.txt中</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        OutputStreamWriter osw =null;</span><br><span class="line">        try &#123;</span><br><span class="line">           isr =new InputStreamReader(new FileInputStream(&quot;E:/TestFile/pet.template&quot;),&quot;UTF-8&quot;);</span><br><span class="line">            br = new BufferedReader(isr);</span><br><span class="line">            //读取的内容</span><br><span class="line">            StringBuffer sbf = new StringBuffer();</span><br><span class="line">            String line = null;</span><br><span class="line">            while ((line =br.readLine())!=null)&#123;</span><br><span class="line">                //把每次获取的内容追加到StringBuffer里面</span><br><span class="line">                sbf.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;替换前&quot;+sbf);</span><br><span class="line"></span><br><span class="line">            //文件内容的替换，把占位符替换为具体宠物信息</span><br><span class="line">            String newStr = sbf.toString();</span><br><span class="line">            newStr = newStr.replace(&quot;&#123;name&#125;&quot;,&quot;欧欧&quot;);</span><br><span class="line">            newStr = newStr.replace(&quot;&#123;type&#125;&quot;,&quot;狗狗&quot;);</span><br><span class="line">            newStr = newStr.replace(&quot;&#123;master&#125;&quot;,&quot;IU&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;替换后&quot;+newStr);</span><br><span class="line"></span><br><span class="line">            //将新内容写入到pet.txt中</span><br><span class="line">            osw = new OutputStreamWriter(new FileOutputStream(&quot;E:/TestFile/pet.txt&quot;),&quot;UTF-8&quot;);</span><br><span class="line">            bw = new BufferedWriter(osw);</span><br><span class="line">            bw.write(newStr);</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                br.close();</span><br><span class="line">                isr.close();</span><br><span class="line">                bw.close();</span><br><span class="line">                osw.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>List-LinkedList</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-LinkedList/</url>
    <content><![CDATA[
        <h3 id="LinkedList类"   >
          <a href="#LinkedList类" class="heading-link"><i class="fas fa-link"></i></a><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3>
      <p><strong>LinkedList介绍：</strong><br>LinkedList类是List接口的链接列表实现类。它支持实现所有List接口可选的列表的操作，并且允许元素值是任何数据，包括null。</p>
<p>linkedList类采用链表存储方式存储数据，如下图，优点在于插入、删除元素时效率比较高，但是LinkedList类的查找效率很低。<br><img src="https://img14.360buyimg.com/ddimg/jfs/t1/179941/23/18544/12071/6112184bE8e0cb9e5/d7f047248135a7d5.png" alt="LinkedListImage.png"></p>
<p>它除了包含ArrayList类所包含的方法外，还提拱了下面表格中所示的一些方法，可以在LinkedList类的首部或尾部进行插入、删除操作。</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void addFirst(Object obj)</td>
<td>将指定元素插入到当前集合的首部</td>
</tr>
<tr>
<td align="center">void addLast(Object obj)</td>
<td>将指定元素插入到当前集合的尾部</td>
</tr>
<tr>
<td align="center">Object getFirst()</td>
<td>获得当前集合的第一个元素</td>
</tr>
<tr>
<td align="center">Object getLast()</td>
<td>获得当前集合的最后一个元素</td>
</tr>
<tr>
<td align="center">Object removeirst()</td>
<td>移除并返回当前集合的第一个元素</td>
</tr>
<tr>
<td align="center">Object removeLast()</td>
<td>移除并返回当前集合的最后一个元素</td>
</tr>
</tbody></table></div>
<p>例：使用LinkedList集合存储新闻标题（包含ID、名称、创建者），实现获取、添加以及删除头条和末尾新闻标题信息功能，并遍历集合</p>
<p>新闻对象</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//新闻标题类：ID 新闻标题 创建者</span><br><span class="line">public class NewsTitle &#123;</span><br><span class="line">	</span><br><span class="line">	private int id;</span><br><span class="line">	private String title;</span><br><span class="line">	private String author;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public NewsTitle() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public NewsTitle(int id, String title, String author) &#123;</span><br><span class="line"></span><br><span class="line">		this.id = id;</span><br><span class="line">		this.title = title;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getTitle() &#123;</span><br><span class="line">		return title;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setTitle(String title) &#123;</span><br><span class="line">		this.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getAuthor() &#123;</span><br><span class="line">		return author;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAuthor(String author) &#123;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class NewsMgr &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建新闻标题对象</span><br><span class="line">		NewsTitle car = new NewsTitle(1,&quot;汽车&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle medical = new NewsTitle(1,&quot;医学&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle fun = new NewsTitle(1,&quot;娱乐&quot;,&quot;author&quot;);</span><br><span class="line">		NewsTitle gym = new NewsTitle(1,&quot;体育&quot;,&quot;author&quot;);</span><br><span class="line">		</span><br><span class="line">		//创建集合对象,并且将新闻标题加入到集合中</span><br><span class="line">		LinkedList  list = new LinkedList();</span><br><span class="line">		//等同于数组中的list[0] = title1;</span><br><span class="line">		list.add(car);</span><br><span class="line">		list.add(medical);</span><br><span class="line">		//添加头条新闻标题和末条新闻标题</span><br><span class="line">		list.addFirst(fun);</span><br><span class="line">		list.addLast(gym);</span><br><span class="line">		System.out.println(&quot;头条和末条新闻已添加&quot;);</span><br><span class="line">		//获取头条以及末条新闻标题</span><br><span class="line">		NewsTitle first = (NewsTitle)list.getFirst();</span><br><span class="line">		System.out.println(&quot;头条新闻标题为：&quot;+first.getTitle());</span><br><span class="line">		NewsTitle last = (NewsTitle)list.getLast();</span><br><span class="line">		System.out.println(&quot;末条新闻标题为：&quot;+last.getTitle());</span><br><span class="line">		//删除头条新闻和末条新闻</span><br><span class="line">		list.removeFirst();</span><br><span class="line">		list.removeLast();</span><br><span class="line">		System.out.println(&quot;头条新闻和末条新闻已删除！&quot;);</span><br><span class="line">		System.out.println(&quot;遍历所有新闻标题&quot;);</span><br><span class="line">		for (Object obj : list) &#123;</span><br><span class="line">			NewsTitle title = (NewsTitle)obj;</span><br><span class="line">			System.out.println(title.getTitle());</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>除了表格中列出的LinkedList类提供的方法外，LinkedList类和ArrayList类所包含的大部分方法是完全一样的，这主要是因为他们都是List接口的实现类。<br>由于ArrayLIst采用和数组一样的连续的顺序存储方式，当对数据频繁检索时效率高，而LinkedList类采用链表存储方式，当对数据添加、删除或修改比较多时，建议选择LinkedList类存储数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>LinkedList</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流(输入、输入流)</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-IO%E6%B5%81(2)/</url>
    <content><![CDATA[
        <h3 id="Java-I-O-2"   >
          <a href="#Java-I-O-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-I-O-2" class="headerlink" title="Java I/O (2)"></a>Java I/O (2)</h3>
      
        <h4 id="读写二进制文件"   >
          <a href="#读写二进制文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h4>
      <p>前面介绍了如何读写文本文件，但常见的文件读写中还有一种二进制文件的读写</p>
<p>读写二进制文件常用的类还有<strong>DataInputStream</strong>和<strong>DataOutputStream</strong></p>
<p><strong>DataInputStream类</strong></p>
<blockquote>
<p>FileInputStream的子类<br>与FileInputStream类结合使用读取二进制文件</p>
</blockquote>
<p><strong>DataOutputStream类</strong></p>
<blockquote>
<p>FileOutputStream类<br>与FileOutputStream类结合使用写二进制文件</p>
</blockquote>
<p><strong>练习：复制图片到另一个目录</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//借助DataInputStream和DataOutputStream实现二进制文件读写</span><br><span class="line">public class DataOutAndDataIn &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //读取图片文件：E:/TestFile/img/mc.jpg</span><br><span class="line">        DataInputStream dis = null;</span><br><span class="line">        FileInputStream fis= null;</span><br><span class="line">        //将图片文件写到E:/TestFile/img1/mm.jpg</span><br><span class="line">        DataOutputStream dos = null;</span><br><span class="line">        FileOutputStream fos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //输入流</span><br><span class="line">            fis = new FileInputStream(&quot;E:/TestFile/img/cxy.png&quot;);</span><br><span class="line">            dis = new DataInputStream(fis);</span><br><span class="line">            //输出流</span><br><span class="line">            fos = new FileOutputStream(&quot;E:/TestFile/img1/cxy1.jpg&quot;);</span><br><span class="line">            dos = new DataOutputStream(fos);</span><br><span class="line">            //输入流读取二进制文件的同时，输出流写入二进制文件</span><br><span class="line">            int temp;</span><br><span class="line">            while ((temp = dis.read())!=-1)&#123;</span><br><span class="line">                dos.write(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">                fos.close();</span><br><span class="line">                dis.close();</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="序列化"   >
          <a href="#序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4>
      
        <h5 id="认识序列化"   >
          <a href="#认识序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#认识序列化" class="headerlink" title="认识序列化"></a>认识序列化</h5>
      <p>在开发中，经常需要将对象的信息保存到磁盘中便于以后检索，可以使用字符流和字节流发的方法逐一对对象的属性信息进行操作，但是这样做通常很繁琐，而且容易出错。编程在包含大量对象的大型业务应用程序的情形，程序员不得不为每一个对象编写代码，以便将字段和属性保存至磁盘以及从磁盘还原这些字段和属性。序列化提供了轻松实现这个目标的快捷方法</p>
<p>简单的说，序列化就是将对象的状态存储到特定存储介质中的过程，也就是将对象状态转换为可保持或可传输格式的过程。在序列化过程中，会将对象的公有成员、私有成员包括类名，转换为字节流，然后再把字节流写入数据流，存储到存储介质中，这里说的存储介质通常指的是文件</p>
<p>使用序列化的意义在于将Java对象序列化后，可以将其转换为字节序列，这些字节序列可以被保存在磁盘上，也可以借助网络进行传输，同时序列化后的对象保存的是二进制状态，这样实现了平台无关性，即可以将在Windows操作系统中实现序列化的一个对象，传输到UNIX操作系统的机器上，再通过反序列化后得到相同对象，而无需担心数据因平台问题显示异常。</p>

        <h5 id="序列化保存对象信息"   >
          <a href="#序列化保存对象信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#序列化保存对象信息" class="headerlink" title="序列化保存对象信息"></a>序列化保存对象信息</h5>
      <p>序列化机制允许将实现了序列化的Java对象转换为字节序列，这个过程需要借助I/O流来实现。</p>
<p>Java中只有实现了 java.io.Serializable 接口的类的对象才能被序列化，Serializable表示可串行的、可序列化的。所以，对象序列化在某些文献上也被称为串行化。</p>
<p>JDK类库中有些类，如String类、包装类和Date类等都实现了Serializable接口</p>
<p><strong>对象序列化可以分为两步：</strong><br>1.创建一个对象输出流（ObjectOutputStream），它可以包装一个其他类型的输出流，如文件输出流FileOutputStream</p>
<p>例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutStream(&quot;D:/TestFile/stu.txt&quot;));</span><br></pre></td></tr></table></div></figure>
<p>创建了对象输出流oos，包装了一个文件输出流，即C盘文件夹TestFile中的stu.txt文件流</p>
<p>2.通过对象输出流的 writeObject( )方法写对象，也就是输出可序列化对象</p>
<p>示例：实现学员对象的实例化</p>
<p>学员类</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//学员</span><br><span class="line">public class Student implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String pwd;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age, String sex, String pwd) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">        this.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, sex=&#x27;&quot; + sex + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPwd() &#123;</span><br><span class="line">        return pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPwd(String pwd) &#123;</span><br><span class="line">        this.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>实现类</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//序列化学员对象</span><br><span class="line">public class SeriaStu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(&quot;anner&quot;,18,&quot;女&quot;,&quot;123456&quot;);</span><br><span class="line">        //对象输出流</span><br><span class="line">        ObjectOutputStream oos= null;</span><br><span class="line">        FileOutputStream fos = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fos = new FileOutputStream(&quot;E:/TestFile/stu.txt&quot;);</span><br><span class="line">            oos = new ObjectOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            //实现对象序列化</span><br><span class="line">            oos.writeObject(student);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>上述代码如果要保存多个学生对象，可以使用集合</p>

        <h5 id="反序列化获取对象信息"   >
          <a href="#反序列化获取对象信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#反序列化获取对象信息" class="headerlink" title="反序列化获取对象信息"></a>反序列化获取对象信息</h5>
      <p>可以将对象的状态保存到存储介质（如文件）中 ，那么如何将这些对象状态读取出来呢？这就用到反序列化。反序列化，顾名思义就是与序列化相反，是从特定存储介质中读取数据并重新构建成对象的过程。<br>通过反序列化，可以将存储在文件上的对象信息读取出来，然后重新构建为对象。这样就不需要再将文件上的信息一一读取、分析再组织为对象</p>
<p>反序列化分为两步</p>
<p>1.创建一个对象输入流（ObjectInputStream），它可以包装一个其他类型的输入流 ，如文件输入流FileInputStream</p>
<p>2.通过对象输入流的readObject( ) 方法读取对象，该方法返回一个Object类型的对象，如果程序知道该Java对象的类型，则可以将该对象强制转换成其真实的类型。</p>
<p><strong>示例：实现学员对象的反实例化</strong></p>
<p><strong>学员类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//学员</span><br><span class="line">public class Student implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String pwd;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int age, String sex, String pwd) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">        this.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, sex=&#x27;&quot; + sex + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, pwd=&#x27;&quot; + pwd + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPwd() &#123;</span><br><span class="line">        return pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPwd(String pwd) &#123;</span><br><span class="line">        this.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><strong>实现类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//反序列化学员对象</span><br><span class="line">public class SeriaStu1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       </span><br><span class="line">        //对象输入流</span><br><span class="line">        ObjectInputStream ois = null;</span><br><span class="line">        FileInputStream fis = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //构建对象输入流，为反序列化做准备</span><br><span class="line">            fis = new FileInputStream(&quot;E:/TestFile/stu.txt&quot;);</span><br><span class="line">            ois = new ObjectInputStream(fis);</span><br><span class="line">            //实现对象反序列化</span><br><span class="line">            Student student1 = (Student) ois.readObject();</span><br><span class="line">            System.out.println(&quot;反序列化出来的学生信息&quot;+ student1.getName()+student1.getSex());</span><br><span class="line">            System.out.println(student1.getAge()+student1.getPwd());</span><br><span class="line">        &#125;  catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">                fis.close();</span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>通常，对象中的所有属性都会被序列化，但是对于一些敏感信息，如用户的密码，一旦序列化后，人们完全可以通过读取文件或拦截网络传输数据的方式获得这些信息。因此，出于对安全的考虑，某些属性应限制被序列化。解决问题的办法是使用 transient 来修饰。</p>
<p>使用 transient修饰密码,可以避免对象的密码属性被序列化和反序列化</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Student implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">    private transient String pwd;</span><br></pre></td></tr></table></div></figure>

<p>序列化的算法规则：</p>
<blockquote>
<p>1.所有保存到磁盘中的对象都有一个序列号<br>2.当程序试图序列化一个对象时，将会检查是否已经被序列化，只有序列化后的对象餐能被转换成字节序列输出<br>3.如果对象已经被序列化，则程序直接输出一个序列化编号，而不再重新序列化</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>Map之HashMap</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-Map%E4%B9%8BHashMap/</url>
    <content><![CDATA[
        <h3 id="Map接口和HashMap类"   >
          <a href="#Map接口和HashMap类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map接口和HashMap类" class="headerlink" title="Map接口和HashMap类"></a>Map接口和HashMap类</h3>
      
        <h4 id="Map接口概述"   >
          <a href="#Map接口概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h4>
      <blockquote>
<p>Map接口存储一组成对的键 (key) —值 (value) 对象,提供key到value的映射，通过key来检索。<br>Map接口中的key不要求有序，不允许重复。value同样不要求有序，但允许重复。<br>下表中列举了Map接口中常用的方法</p>
</blockquote>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object put(Object key,Object value)</td>
<td>将互相关联的一个key与一个value放入该集合，如果此Map接口中已经包含了对应的vlaue，则旧值将被替换</td>
</tr>
<tr>
<td align="center">Object remove(Object key)</td>
<td>从当前集合中移除与指定key相关的映射，并返回该key关联的旧value。如果key没有任何关联，则返回null</td>
</tr>
<tr>
<td align="center">Object get(Object key)</td>
<td>获得与key相关的value。如果该key不关联任何非null值，则返回null</td>
</tr>
<tr>
<td align="center">booelean contiansKey(Object key)</td>
<td>判断集合中是否存在key</td>
</tr>
<tr>
<td align="center">booelean contiansValue(Object value)</td>
<td>判断集合中是否存在value</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td>判断集合中否存在元素</td>
</tr>
<tr>
<td align="center">void clear()</td>
<td>清除集合中所有元素</td>
</tr>
<tr>
<td align="center">int size()</td>
<td>返回集合中元素的数量</td>
</tr>
<tr>
<td align="center">Set keySet()</td>
<td>获取所有key的集合</td>
</tr>
<tr>
<td align="center">Collection vlaues()</td>
<td>获取所有value的集合</td>
</tr>
</tbody></table></div>
<p>Map接口中存储的数据都是键值对</p>
<p>例如 ：一个人的身份证号码对应一个人，其中，身份证号码就是key，与此号码对应的人是value。</p>

        <h4 id="使用HashMap类存储数据"   >
          <a href="#使用HashMap类存储数据" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用HashMap类存储数据" class="headerlink" title="使用HashMap类存储数据"></a>使用HashMap类存储数据</h4>
      <p>要求：<br>1.输出学员<br>2.输出键集<br>3.判断是否存在”Jack”这个键，如果存在，则根据键获取相应的值<br>4.判断是否存在”Rose”这个键，如果存在，则删除此键值对<br>5.遍历键集输出英文名<br>6.遍历值集</p>
<p><strong>学员实体类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sex;</span><br><span class="line">	</span><br><span class="line">	public Student() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public Student(String name, String sex) &#123;</span><br><span class="line">	</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSex() &#123;</span><br><span class="line">		return sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSex(String sex) &#123;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>操作类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class TestHashMap &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建学员对象</span><br><span class="line">		Student stu = new Student(&quot;黎明&quot;,&quot;男&quot;);</span><br><span class="line">		Student stu1 = new Student(&quot;刘丽&quot;,&quot;女&quot;);</span><br><span class="line">		//创建保存“键值对”的结合对象</span><br><span class="line">		Map students= new HashMap();</span><br><span class="line">		//把英文名称与学员对象按照 </span><br><span class="line">		students.put(&quot;Jack&quot;,stu);</span><br><span class="line">		students.put(&quot;Rose&quot;,stu1);</span><br><span class="line">		//输出学员个数</span><br><span class="line">		System.out.println(&quot;已添加&quot;+students.size()+&quot;个学员信息&quot;);</span><br><span class="line">		//输出键集</span><br><span class="line">		System.out.println(&quot;键集:&quot;+students.keySet());</span><br><span class="line">		//判断是否存在Jack这个键，如果存在，则根据键获取相应的值</span><br><span class="line">		String key = &quot;Jack&quot;;</span><br><span class="line">		if(students.containsKey(key))&#123;</span><br><span class="line">			Student student = (Student)students.get(key);</span><br><span class="line">			System.out.println(&quot;英文名为:&quot;+key+&quot;的学员姓名是:&quot;+student.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		//判断是否存在Rose这个键，如果存在则删除此键值对</span><br><span class="line">		String key1=&quot;Rose&quot;;</span><br><span class="line">		if(students.containsKey(key1))&#123;</span><br><span class="line">			students.remove(key1);</span><br><span class="line">			System.out.println(&quot;学员&quot;+key1+&quot;的信息已删除&quot;);</span><br><span class="line">		&#125;	</span><br><span class="line">		//输出英文名</span><br><span class="line">		System.out.println(&quot;学员英文名:&quot;);</span><br><span class="line">		for (Object key3 : students.keySet()) &#123;</span><br><span class="line">			System.out.println(key3.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		//输出学员详细信息</span><br><span class="line">		for (Object key4 : students.values()) &#123;</span><br><span class="line">			Student student = (Student)key4;</span><br><span class="line">			System.out.println(&quot;姓名：&quot;+student.getName()+&quot;\t性别：&quot;+student.getSex());</span><br><span class="line">		&#125;</span><br><span class="line">		//获取键的集合、值的集合、键和值的集合</span><br><span class="line">		System.out.println(students.keySet());</span><br><span class="line">		System.out.println(students.values());</span><br><span class="line">		System.out.println(students);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>注意：<br>数据添加到HashMap集合后满所有数据的数据类型将转换为Object类型，所以从其中获取数据是需要进行强制类型转换。<br>HashMap类不保证映射的顺序，特别是不保证顺序恒久不变。  </p>
</blockquote>
<p>在上面示例中可以使用增强型for循环遍历HashMap集合的键值和集值，当然也可以使用前面的普通for循环或者Iterator迭代器来遍历，视个人习惯选择  </p>

        <h4 id="遍历Map"   >
          <a href="#遍历Map" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h4>
      <p><strong>遍历Map的三种方法</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		//创建保存“键值对”的集合对象</span><br><span class="line">		Map students= new HashMap();</span><br><span class="line">		//把英文名称与学员对象按照 </span><br><span class="line">		students.put(&quot;Jack&quot;,&quot;黎明&quot;);</span><br><span class="line">		students.put(&quot;Rose&quot;,&quot;刘丽&quot;);</span><br><span class="line">		students.put(&quot;Tom&quot;,&quot;玛法明&quot;);</span><br><span class="line">		students.put(&quot;file&quot;,&quot;阿萨德丽&quot;);</span><br><span class="line">		</span><br><span class="line">		//思路一：遍历key(Set),通过key-&gt;value</span><br><span class="line">		//方法一：增强型for遍历key(Set)</span><br><span class="line">		Set keys = students.keySet();//获取到了Map中的所有个key</span><br><span class="line">		for (Object obj : keys) &#123;</span><br><span class="line">			String key = (String)obj;//获取到了Map中的每一个key</span><br><span class="line">			String value = (String)students.get(key);</span><br><span class="line">			System.out.println(key+&quot;---&quot;+value);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;方法二&quot;);</span><br><span class="line">		//方法二：迭代器Iterator遍历key的集合(Set)</span><br><span class="line">		Iterator itor = keys.iterator();</span><br><span class="line">		while(itor.hasNext())&#123;</span><br><span class="line">			String key = (String)itor.next();//获取到了Map中每一个key</span><br><span class="line">			String value = (String)students.get(key);</span><br><span class="line">			System.out.println(key+&quot;---&quot;+value);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-----------&quot;);</span><br><span class="line">		//思路二：获取Map中的所有键值对，然后再键值对中分别获得key和value</span><br><span class="line">		Set set = students.entrySet();//获得Map键值对</span><br><span class="line">		//遍历键值对的结合，把每个键值对(obj)--map.Entry(键值对的类型)拿出来</span><br><span class="line">		for(Object obj : set)&#123;</span><br><span class="line">			Map.Entry me = (Map.Entry)obj;</span><br><span class="line">			String key = (String)me.getKey();//获取键值对中的键</span><br><span class="line">			String value=(String) me.getValue();//获取键值对中的值</span><br><span class="line">			System.out.println(key+&quot;--&quot;+value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Map练习"   >
          <a href="#Map练习" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map练习" class="headerlink" title="Map练习"></a>Map练习</h4>
      <p>/*<br>         需求说明<br>        学员应聘至外企工作，每个学员都会有一个英文名称，对应该学员对象。<br>        请实现通过英文名称，获得该学员对象的详细信息<br>        学员属性包括姓名以及性别<br>        */</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//创建实体类对象</span><br><span class="line">		Student stu1= new Student(&quot;王五&quot;,&quot;男&quot;);</span><br><span class="line">		Student stu2 = new Student(&quot;王加萨达&quot;,&quot;男&quot;);</span><br><span class="line">		Student stu3= new Student(&quot;李洒我&quot;,&quot;女&quot;);</span><br><span class="line">		Student stu4 = new Student(&quot;李静佳&quot;,&quot;女&quot;);</span><br><span class="line">		</span><br><span class="line">		//声明Map 对象</span><br><span class="line">		Map map = new HashMap();</span><br><span class="line">		//把实体类对象加入到Map中去</span><br><span class="line">		map.put(&quot;Jack&quot;, stu1);</span><br><span class="line">		map.put(&quot;Tom&quot;, stu2);</span><br><span class="line">		map.put(&quot;luxi&quot;, stu3);</span><br><span class="line">		map.put(&quot;Rose&quot;, stu4);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		Set set = map.entrySet();</span><br><span class="line">		for (Object obj : set) &#123;</span><br><span class="line">			Map.Entry mp = (Map.Entry)obj;</span><br><span class="line">			String key =(String)mp.getKey();</span><br><span class="line">			Student student=(Student)mp.getValue();</span><br><span class="line">			System.out.println(&quot;学员姓名是:&quot;+student.getName()+&quot;,性别是:&quot;+student.getSex());</span><br><span class="line">		&#125;</span><br><span class="line">		//实现获取特定英文名称对应的学生信息</span><br><span class="line">		System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		System.out.print(&quot;请输入某位学员的英文名称:&quot;);</span><br><span class="line">		String name = sc.next();</span><br><span class="line">		if(map.containsKey(name))&#123;</span><br><span class="line">			Student student = (Student)map.get(name);</span><br><span class="line">//			System.out.println(&quot;😢😎😉😉😉😉😉😉😗😍🙄&quot;);</span><br><span class="line">			System.out.println(name+&quot;-&quot;+student.getName()+&quot;-&quot;+student.getSex());</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;没有此学生！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>HashMap</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性-Math类和Random类</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-Math%E7%B1%BB%E5%92%8CRandom%E7%B1%BB/</url>
    <content><![CDATA[<p>.txt</p>

        <h3 id="Math类和Random类"   >
          <a href="#Math类和Random类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Math类和Random类" class="headerlink" title="Math类和Random类"></a>Math类和Random类</h3>
      
        <h4 id="Math类"   >
          <a href="#Math类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4>
      <p>java.lang.Math 类提供了常用的数学运算方法和两个静态常量<font color="red">E(自然对数的底数)和PI(圆周率)</font>。此类中所有方法都是静态的。这个类是final类，因此没有子类，Math类常见方法如下</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static double abs(double a)</td>
<td align="center">返回double的绝对值。例，Math.abs(-3.5); 返回3.5</td>
</tr>
<tr>
<td align="center">static double max(double a,double b)</td>
<td align="center">返回两个double值较大的一个，例,Math.max(7.6,78.1);</td>
</tr>
<tr>
<td align="center">static double random()</td>
<td align="center">返回一个随机的double值，该值大于等于0.0,且小于1.0</td>
</tr>
</tbody></table></div>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//Math类常用方法</span><br><span class="line">     </span><br><span class="line">     //提供数学运算的功能</span><br><span class="line">     System.out.println(Math.abs(-8.9));//结果：8.9</span><br><span class="line">     System.out.println(Math.max(12,23));//结果：23</span><br><span class="line">     System.out.println(Math.min(34,1));//结果：1</span><br><span class="line">     //生成 0.0到 1.0之间的随机数</span><br><span class="line">     int random = (int)(Math.random()*10);//0-10不包括 10 之间的随机数</span><br><span class="line">     System.out.println(random);</span><br><span class="line">     //随机数示例，输入4位卡号，卡号的百位数为随机数则中奖</span><br><span class="line"></span><br><span class="line">     int num = (int)(Math.random()*10);</span><br><span class="line">     System.out.println(&quot;系统生成随机数为:&quot;+num);</span><br><span class="line">     System.out.println(&quot;请输入你的会员卡号：&quot;);</span><br><span class="line">     Scanner sc = new Scanner(System.in);</span><br><span class="line">     int account = sc.nextInt();</span><br><span class="line">     int baiWei = account/100%10;</span><br><span class="line">     if(baiWei==num)&#123;</span><br><span class="line">         System.out.println(&quot;恭喜，你中奖了&quot;);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         System.out.println(&quot;没有中奖&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h4 id="Random类"   >
          <a href="#Random类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4>
      <p>Random类也可以生成随机数，需要导入java.util.Random包</p>
<blockquote>
<p>1.Random rand = new Random();//创建一个Random对象<br>2.生成随机数 ：int num = random.nextInt();</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//创建随机数生成器</span><br><span class="line">       //随机数生成器种子不同，每次生成的随机数不同</span><br><span class="line">       //随机数生成器种子相同，每次生成的随机数相同</span><br><span class="line">       //常用写法1:</span><br><span class="line">       Random random = new Random();</span><br><span class="line">       //常用写法2:</span><br><span class="line">       //把时间的毫秒作为种子，为了保证每次生成的种子不同</span><br><span class="line">       //Random random2 = new Random(&quot;时间的毫秒&quot;);</span><br><span class="line">       //生成随机数</span><br><span class="line">       System.out.println(random.nextInt());//生成int范围内的随机整数</span><br><span class="line">       System.out.println(random.nextInt(10));//生成 0-10 范围内的随机整数</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>注意：用同一个种子值来初始化连个Random对象，然后用每个对象调用相同的方法，得到的随机数也是相同的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>Math类和Random类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性—String类</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-String%E7%B1%BB/</url>
    <content><![CDATA[
        <h3 id="String类"   >
          <a href="#String类" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类" class="headerlink" title="String类"></a>String类</h3>
      
        <h4 id="String类概述"   >
          <a href="#String类概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类概述" class="headerlink" title="String类概述"></a>String类概述</h4>
      <p>在Java中，字符串被当做String类型的对象来处理。String类位于java.lang包中，默认情况下，该包被自动导入所有程序。创建String对象的方法如下代码所示</p>
<blockquote>
<p>String s = “Hello World”;</p>
</blockquote>
<p><strong>或者</strong></p>
<blockquote>
<p>Stirng s = new String(“Hello World”);</p>
</blockquote>
<p>String类提供了许多有用的方法，例如获取字符串长度、对两个字符串进行比较、连接两个字符串以及提取一个字符串中的某一部分等。可以用String类提供的方法来完成对字符串的操作。</p>
<p><strong>下面介绍String的常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">length();</td>
<td align="center">返回字符串的长度</td>
</tr>
<tr>
<td align="center">equals();</td>
<td align="center">比较两个字符串对象的内容是否一致，返回值为布尔类型，如果相同则为true，不相同为false</td>
</tr>
<tr>
<td align="center">equalsIgnoreCase();</td>
<td align="center">忽略大小写比较字符串1和字符串2，如果相同，返回true；不相同返回false</td>
</tr>
<tr>
<td align="center">toLowerCase();</td>
<td align="center">转换字符串中的英文字符为小写</td>
</tr>
<tr>
<td align="center">toUpperCase();</td>
<td align="center">转换字符串中的英文字符为大写</td>
</tr>
<tr>
<td align="center">trim();</td>
<td align="center">截取字符串前后的空格后返回新的字符串</td>
</tr>
</tbody></table></div>
<p><strong>常用的提取和搜索字符串的方法</strong>  </p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public int indexOf(int ch)</td>
<td align="center">搜索并返回第一个出现字符ch的位置，没找到返回-1</td>
</tr>
<tr>
<td align="center">Public int indexOf(String value)</td>
<td align="center">搜索并返回第一个出现字符串value的位置，没找到返回-1</td>
</tr>
<tr>
<td align="center">public int lastIndexOf(int ch)</td>
<td align="center">搜索并返回最后一个出现字符ch的位置</td>
</tr>
<tr>
<td align="center">public int lastIndexOf(String value)</td>
<td align="center">搜索并返回最后一个出现字符value的位置</td>
</tr>
<tr>
<td align="center">public String SubString(int index)</td>
<td align="center">提取从指定索引位置开始的部分字符串</td>
</tr>
<tr>
<td align="center">public String SubString(int beginindex,int endindex)</td>
<td align="center">提取beginindex和endindex之间的                                                                                                                                                                                                                                               字符串</td>
</tr>
</tbody></table></div>

        <h4 id="String类length-方法"   >
          <a href="#String类length-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类length-方法" class="headerlink" title="String类length()方法"></a>String类length()方法</h4>
      <p>length( )方法返回字符串的长度，语法格式如下</p>
<blockquote>
<p>字符串.length( );</p>
</blockquote>
<p>示例：注册新用户，要求密码长度不能小于6位</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入密码：&quot;);</span><br><span class="line">        String pwd = sc.next();</span><br><span class="line">        if(pwd.length()&gt;=6)&#123;</span><br><span class="line">            System.out.println(&quot;密码通过&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;密码要至少六位数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="String类equals-方法"   >
          <a href="#String类equals-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类equals-方法" class="headerlink" title="String类equals()方法"></a>String类equals()方法</h4>
      <p>String类提供了equals()方法，比较存储在两个字符串对象的内容是否一致</p>
<blockquote>
<p>字符串 1.equals(字符串2);</p>
</blockquote>
<p> 示例：登录验证，用户名为：“TOM”,密码为：“123456”</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Scanner sc = new Scanner(System.in);</span><br><span class="line">     </span><br><span class="line">       System.out.println(&quot;请输入账号:&quot;);</span><br><span class="line">       String account = sc.next();</span><br><span class="line">       </span><br><span class="line">       System.out.println(&quot;请输入密码:&quot;);</span><br><span class="line">       String pwd = sc.next();</span><br><span class="line">       if(account.equals(&quot;TOM&quot;) &amp;&amp; pwd.equals(&quot;123456&quot;))&#123;</span><br><span class="line">           System.out.println(&quot;登录成功&quot;);</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           System.out.println(&quot;登录失败，请检查账号密码是否正确!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>
<p>equals()：检查组成字符串内容的字符是否完全一致<br>== ：比较两个字符串内存地址是否相同，比较两个字符串是否为同一对象</p>
<p>字符串对象创建问题</p>
<p><strong>第一段代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//创建了一个对象</span><br><span class="line">String s1 = &quot;hello&quot;;</span><br><span class="line">String s2 = &quot;hello&quot;;</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">//两个结果都为true</span><br></pre></td></tr></table></div></figure>
<p>因为两个对象创建的字符串都放在了字符串池中，创建的时候先看看池里面有没有，如果有不在创建，自接从池里面拿</p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/196080/23/18928/92268/611ca848E6821d707/367823ee6b2de97b.png" alt="20210818142248.png"></p>
<p><strong>第二段代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//如下代码创建了两个对象</span><br><span class="line">String s1 = &quot;hello&quot;;//此时s1指向的是字符串池中的“hello”对象</span><br><span class="line">String s2 = new String(&quot;hello&quot;);//此时s2指向的是堆中的“hello”对象</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">//第一个结果为true第二个结果为false</span><br></pre></td></tr></table></div></figure>
<p><strong>第三段代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//如下代码创建了三个对象</span><br><span class="line">String s1 = &quot;hello&quot;;//此时s1指向的是字符串池中的“hello”对象</span><br><span class="line">String s2 = new String(&quot;HELLO&quot;);</span><br><span class="line">/*</span><br><span class="line">此时s2指向的是堆中的“HELLO”对象，但该行代码在字符串池例创建了一个“HELLO”对象，也在堆里创建了一个“HELLO”对象</span><br><span class="line">*/</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">//第一个结果为false第二个结果为false</span><br></pre></td></tr></table></div></figure>
<p><strong>第四段代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//如下代码创建了四个对象</span><br><span class="line">String s1 = new String(&quot;hello&quot;);</span><br><span class="line">/*</span><br><span class="line">此时s2指向的是堆中的“hello”对象，但该行代码在字符串池例创建了一个“hello”对象，也在堆里创建了一个“hello”对象</span><br><span class="line">*/</span><br><span class="line">String s2 = new String(&quot;HELLO&quot;);</span><br><span class="line">/*</span><br><span class="line">此时s2指向的是堆中的“HELLO”对象，但该行代码在字符串池例创建了一个“HELLO”对象，也在堆里创建了一个“HELLO”对象</span><br><span class="line">*/</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">//第一个结果为false第二个结果为false</span><br></pre></td></tr></table></div></figure>


        <h4 id="String类equalsIgnoreCase-方法"   >
          <a href="#String类equalsIgnoreCase-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类equalsIgnoreCase-方法" class="headerlink" title="String类equalsIgnoreCase()方法"></a>String类equalsIgnoreCase()方法</h4>
      <blockquote>
<p>忽略大小写比较字符串1和字符串2，如果相同，返回true；不相同返回false</p>
</blockquote>
<p><strong>示例：账号登录</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;请输入账号:&quot;);</span><br><span class="line">    String account = sc.next();</span><br><span class="line">    System.out.println(&quot;请输入密码:&quot;);</span><br><span class="line">    String pwd = sc.next();</span><br><span class="line">   if(account.equalsIgnoreCase(&quot;tom&quot;) &amp;&amp; pwd.equalsIgnoreCase(&quot;123456&quot;))&#123;</span><br><span class="line">     System.out.println(&quot;登录成功&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      System.out.println(&quot;登录失败，请检查账号密码是否正确!&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="String类toLowerCase-方法"   >
          <a href="#String类toLowerCase-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类toLowerCase-方法" class="headerlink" title="String类toLowerCase()方法"></a>String类toLowerCase()方法</h4>
      <blockquote>
<p>转换字符串中的英文字符为小写</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;请输入账号:&quot;);</span><br><span class="line">       String account = sc.next();</span><br><span class="line">       System.out.println(&quot;请输入密码:&quot;);</span><br><span class="line">       String pwd = sc.next();</span><br><span class="line">       if(account.toLowerCase().equalsIgnoreCase(&quot;tom&quot;.toLowerCase()) &amp;&amp; pwd.equalsIgnoreCase(&quot;123456&quot;))&#123;</span><br><span class="line">           System.out.println(&quot;登录成功&quot;);</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           System.out.println(&quot;登录失败，请检查账号密码是否正确!&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="String类toUpperCase-方法"   >
          <a href="#String类toUpperCase-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类toUpperCase-方法" class="headerlink" title="String类toUpperCase()方法"></a>String类toUpperCase()方法</h4>
      <blockquote>
<p>转换字符串中的英文字符为大写</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;请输入账号:&quot;);</span><br><span class="line">       String account = sc.next();</span><br><span class="line">       System.out.println(&quot;请输入密码:&quot;);</span><br><span class="line">       String pwd = sc.next();</span><br><span class="line">       if(account.toUpperCase().equalsIgnoreCase(&quot;tom&quot;.toUpperCase()) &amp;&amp; pwd.equalsIgnoreCase(&quot;123456&quot;))&#123;</span><br><span class="line">           System.out.println(&quot;登录成功&quot;);</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           System.out.println(&quot;登录失败，请检查账号密码是否正确!&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="String类trim-方法"   >
          <a href="#String类trim-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类trim-方法" class="headerlink" title="String类trim()方法"></a>String类trim()方法</h4>
      <blockquote>
<p>截取字符串前后的空格后返回新的字符串</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">String name = &quot;   admin  &quot;;</span><br><span class="line">System.out.println(name.trim());</span><br></pre></td></tr></table></div></figure>
<p><strong>注意：trim()只能去除字符串两端的空格，字符串中间的字符无法去除</strong></p>

        <h4 id="String类concat-方法"   >
          <a href="#String类concat-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类concat-方法" class="headerlink" title="String类concat()方法"></a>String类concat()方法</h4>
      <blockquote>
<p>字符串连接</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> String s1 = &quot;Hello&quot;;</span><br><span class="line"> String s2 = &quot; World!&quot;;</span><br><span class="line">//加号连接，但是只限于两端都是字符串     </span><br><span class="line"> System.out.println(s1+s2);//连接</span><br><span class="line"> System.out.println(5+4);//加法</span><br><span class="line"> //concat()方法连接</span><br><span class="line"> System.out.println(s1.concat(s2));//连接</span><br></pre></td></tr></table></div></figure>


        <h4 id="String类indexOf-方法"   >
          <a href="#String类indexOf-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类indexOf-方法" class="headerlink" title="String类indexOf()方法"></a>String类indexOf()方法</h4>
      <blockquote>
<p>indexOf( )：查找某个特定的字符串在整个字符串中第一次出现的位置<br>字符串下标从0开始</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">String s = &quot;hrllo World!&quot;;</span><br><span class="line">int index = s.indexOf(&quot;o&quot;);</span><br><span class="line">int index = s.indexOf(&quot;yes&quot;);</span><br></pre></td></tr></table></div></figure>
<p>找到位置，返回元素的所在位置，找不到返回-1</p>

        <h4 id="String类lastIndexOf-方法"   >
          <a href="#String类lastIndexOf-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类lastIndexOf-方法" class="headerlink" title="String类lastIndexOf()方法"></a>String类lastIndexOf()方法</h4>
      <blockquote>
<p>查找某个特定字符串在整个字符串中最后一次出现的位置</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">int index3 = s.lastIndexOf(&quot;o&quot;);</span><br><span class="line">system.out.print(index3);</span><br></pre></td></tr></table></div></figure>

        <h4 id="String类SubString-方法"   >
          <a href="#String类SubString-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类SubString-方法" class="headerlink" title="String类SubString()方法"></a>String类SubString()方法</h4>
      <blockquote>
<p>截取特定字符串内容<br>subString(Index):从index位置（包含）开始截取，一直截取到字符串末尾</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">String result = s.substring(4);//下标为0，从4开始</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></div></figure>

<blockquote>
<p>subString(beginIndex,endIndex):从beginIndex位置开始截取，截取到字符串endIndex(不包含endIndex)</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">String result2 = s.substring(4,7);</span><br><span class="line">System.out.println(result2);</span><br></pre></td></tr></table></div></figure>


        <h4 id="综合案例-截取小鱼儿"   >
          <a href="#综合案例-截取小鱼儿" class="heading-link"><i class="fas fa-link"></i></a><a href="#综合案例-截取小鱼儿" class="headerlink" title="综合案例,截取小鱼儿"></a>综合案例,截取小鱼儿</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">String word = &quot;Hello,   &quot;;</span><br><span class="line">word = word.trim();v</span><br><span class="line">String s1 = word.concat(&quot;小鱼儿!&quot;);</span><br><span class="line">int index1 = s1.indexOf(&#x27;,&#x27;);</span><br><span class="line">System.out.println(index1);</span><br><span class="line">int index4 = s1.indexOf(&#x27;!&#x27;);</span><br><span class="line">System.out.println(index4);</span><br><span class="line">System.out.println(s1.substring(index1+1,index4));</span><br></pre></td></tr></table></div></figure>

        <h4 id="综合案例：使用邮件提交作业"   >
          <a href="#综合案例：使用邮件提交作业" class="heading-link"><i class="fas fa-link"></i></a><a href="#综合案例：使用邮件提交作业" class="headerlink" title="综合案例：使用邮件提交作业"></a>综合案例：使用邮件提交作业</h4>
      <p>需求：文件后缀名为.java 邮箱格式正确@在点 “.”前面</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;----------作业提交系统----------&quot;);</span><br><span class="line">        System.out.println(&quot;请输入要提交的文件名:&quot;);</span><br><span class="line">        String fileName = sc.next();</span><br><span class="line">        System.out.println(&quot;请输入您的个人邮箱:&quot;);</span><br><span class="line">        String email = sc.next();</span><br><span class="line">        boolean jobFlag = false;//作业后缀名，true正确 false错误</span><br><span class="line">        boolean emailFlag = false;//邮件后缀名</span><br><span class="line"></span><br><span class="line">        //检查作业后缀名是否正确</span><br><span class="line">        int index = fileName.lastIndexOf(&quot;.&quot;);</span><br><span class="line">        if(index!=-1 &amp;&amp; fileName.substring(index).equals(&quot;.java&quot;))&#123;</span><br><span class="line">            jobFlag = true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;文件名无效，请从新输入!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //邮箱名是否正确</span><br><span class="line"></span><br><span class="line">        int index2  = email.lastIndexOf(&quot;@&quot;);</span><br><span class="line">        int index3  = email.lastIndexOf(&quot;.&quot;);</span><br><span class="line">        if(index2!=-1 &amp;&amp; index3!=-1 &amp;&amp;index2&lt;index3)&#123;</span><br><span class="line">            emailFlag=true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //作业是否提交成功</span><br><span class="line">        if(jobFlag &amp;&amp; emailFlag)&#123;</span><br><span class="line">            System.out.println(&quot;提交成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;提交失败!&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="查找特定字符出现的次数"   >
          <a href="#查找特定字符出现的次数" class="heading-link"><i class="fas fa-link"></i></a><a href="#查找特定字符出现的次数" class="headerlink" title="查找特定字符出现的次数"></a>查找特定字符出现的次数</h4>
      <p>输入一个字符串，再输入要查找的字符，判断该字符在该字符串中出现的次数</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> public int counter(String info , String find)&#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        String[] chars = new String[info.length()];</span><br><span class="line">        //字符串转换成数组元素</span><br><span class="line">        for(int i=0;i&lt;chars.length;i++)&#123;</span><br><span class="line">            chars[i] = info.substring(i,i+1);</span><br><span class="line">            //拿出来chars中的每个字符串，和要查找的字符串find进行比较，相等就累加计数</span><br><span class="line">            if (chars[i].equals(find))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc  = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入一个字符串:&quot;);</span><br><span class="line">        String info = sc.next();</span><br><span class="line">        System.out.println(&quot;请输入要查找的字符:&quot;);</span><br><span class="line">        String find = sc.next();</span><br><span class="line"></span><br><span class="line">        t1 t = new t1();</span><br><span class="line">        int count = t.counter(info,find);</span><br><span class="line">        System.out.println(info+&quot;中包含了&quot;+count+&quot;个&quot;+find);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="字符串拆分方法-split"   >
          <a href="#字符串拆分方法-split" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串拆分方法-split" class="headerlink" title="字符串拆分方法 split( )"></a>字符串拆分方法 split( )</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class StrMethods &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;************&quot;原歌词************&quot;&quot;);</span><br><span class="line">        String song = &quot;长亭外 古道边 芳草碧连天 晚风拂柳笛声残 夕阳山外山&quot;;</span><br><span class="line">        System.out.println(song);</span><br><span class="line">        //拆分字符串--&gt;String[]</span><br><span class="line">        //按空格拆分</span><br><span class="line">        String[] s = song.split(&quot; &quot;);</span><br><span class="line">        System.out.println(&quot;************&quot;按空格拆分后的歌词************&quot;);</span><br><span class="line">        for (String s1:s) &#123;</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>String类</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-Set-HashSet/</url>
    <content><![CDATA[
        <h3 id="Set接口之HashSet类"   >
          <a href="#Set接口之HashSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Set接口之HashSet类" class="headerlink" title="Set接口之HashSet类"></a>Set接口之HashSet类</h3>
      
        <h4 id="1-Set接口概述"   >
          <a href="#1-Set接口概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Set接口概述" class="headerlink" title="1.Set接口概述"></a>1.Set接口概述</h4>
      <p>Set接口是Collection接口的另一个常用子接口<br>Set接口描述的是一种比较简单的集合。集合中的对象并不按特定的方式排序，并且不能保存重复的对象<br>也就是说Set接口可以存储一组唯一、无序的对象。<br>Set接口常用的实现类是HashSet。<br>Set接口中不存在get( )方法<br>Set中输出的元素是无序的</p>

        <h4 id="2-HashSet类"   >
          <a href="#2-HashSet类" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-HashSet类" class="headerlink" title="2.HashSet类"></a>2.HashSet类</h4>
      <p>假如现在需要在很多数据中查找某个数据，LinkedList类就无需考虑了，他的数据结构决定了它的查找效率很低下。</p>
<p>如果使用ArrayList类，在不知道数据的索引且需要全部遍历的情况下，效率一样很低下。</p>
<p>为此Java集合框架提供了一个查找效率高的集合类HashSet。HashSet类实现了Set接口，是使用Set集合时最常用的一个实现类。</p>
<p><strong>HashSet的特点:</strong></p>
<blockquote>
<p>1.集合内的元素是唯一、无序排列的<br>2.HashSet类是非线程安全的<br>3.允许集合元素值为null<br>4.Set中存放对象的引用</p>
</blockquote>
<p><strong>下面是HashSet的常用方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">booelan add(Object o)</td>
<td>如果Set中尚未包含指定元素o,则添加指定元素o</td>
</tr>
<tr>
<td align="center">void clear()</td>
<td>从Set中移除所有元素</td>
</tr>
<tr>
<td align="center">int size()</td>
<td>返回Set中的元素的数量（Set容量）</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td>如果Set不包含任何元素，则返回true</td>
</tr>
<tr>
<td align="center">boolean contains(Object o)</td>
<td>如果Set包含指定元素o，则返回true</td>
</tr>
<tr>
<td align="center">boolean remove(Object o)</td>
<td>如果指定元素o存在于Set中，则将其移除</td>
</tr>
</tbody></table></div>

        <h4 id="Set中存放对象的引用"   >
          <a href="#Set中存放对象的引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Set中存放对象的引用" class="headerlink" title="Set中存放对象的引用"></a>Set中存放对象的引用</h4>
      <p>如果声明一个Set set = new HashSet( );<br>String s1 = new String(“java”);<br>String s2=s1;<br>String s3 = new String(“java”);<br>set.add(s1);<br>set.add(s2);<br>set.add(s3);<br>那么size中最后输出的长度为：1<br>System.out.println(set.size( ));</p>
<p>因为Set采用对象的equals( )方法比较两个对象是否相等 ，所以在存放对象的时候会先用 equals( )方法 判断Set集合中有没有这个元素，如果有，就直接引用已有的元素，如果没有那就创建一个元素。</p>

        <h4 id="使用HashSet类的常用方法"   >
          <a href="#使用HashSet类的常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用HashSet类的常用方法" class="headerlink" title="使用HashSet类的常用方法"></a>使用HashSet类的常用方法</h4>
      <p>使用HashSet类的常用方法存储并操作新闻标题信息，并遍历集合</p>
<p><strong>新闻对象</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class NewsTitle &#123;</span><br><span class="line">	</span><br><span class="line">	private int id;</span><br><span class="line">	private String title;</span><br><span class="line">	private String author;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public NewsTitle() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public NewsTitle(int id, String title, String author) &#123;</span><br><span class="line"></span><br><span class="line">		this.id = id;</span><br><span class="line">		this.title = title;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(int id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getTitle() &#123;</span><br><span class="line">		return title;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setTitle(String title) &#123;</span><br><span class="line">		this.title = title;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getAuthor() &#123;</span><br><span class="line">		return author;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAuthor(String author) &#123;</span><br><span class="line">		this.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class NewsMgr &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建新闻标题对象</span><br><span class="line">		NewsTitle car = new NewsTitle(1,&quot;汽车&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle medical = new NewsTitle(1,&quot;高考&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle fun = new NewsTitle(1,&quot;娱乐&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle gym = new NewsTitle(1,&quot;体育&quot;,&quot;管理员&quot;);</span><br><span class="line">		</span><br><span class="line">		//创建集合对象,并且将新闻标题加入到集合中</span><br><span class="line">		Set  set = new HashSet();</span><br><span class="line">		set.add(car);</span><br><span class="line">		set.add(medical);</span><br><span class="line">		set.add(fun);</span><br><span class="line">		set.add(gym);</span><br><span class="line">		//获取新闻标题的总数</span><br><span class="line">		System.out.println(&quot;新闻标题数目为:&quot;+set.size()+&quot;条。&quot;);</span><br><span class="line">		//判断汽车新闻是否存在</span><br><span class="line">		System.out.println(&quot;汽车新闻是否存在:&quot;+set.contains(car));</span><br><span class="line">		//移除对象</span><br><span class="line">		set.remove(car);</span><br><span class="line">		System.out.println(&quot;汽车对象已删除:&quot;+set.contains(car));</span><br><span class="line">		//判断集合是否为空</span><br><span class="line">		System.out.println(&quot;集合是否为空:&quot;+set.isEmpty());</span><br><span class="line">		//遍历所有新闻标题</span><br><span class="line">		System.out.println(&quot;遍历所有新闻标题:&quot;);</span><br><span class="line">		for (Object obj : set) &#123;</span><br><span class="line">			NewsTitle title =(NewsTitle)obj;</span><br><span class="line">			System.out.print(title.getTitle()+&quot; &quot;);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在上面的例子中 ，通过增强for循环遍历HashSet,前面讲过List接口可以使用for循环和增强for循环两种方式遍历。</p>
<p>使用 <strong>for</strong> 循环遍历时，通过<strong>get( )<strong>方法取出每个对象，但</strong>HashSet</strong>类不存在<strong>get()<strong>方法，所以Set接口无法使用普通</strong>for</strong>循环遍历。</p>
<p>其实遍历集合还有一种比较常用的方式，即使用 <strong>Iterator</strong> 接口</p>

        <h4 id="Iterator-接口"   >
          <a href="#Iterator-接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4>
      
        <h5 id="Iterator接口概述："   >
          <a href="#Iterator接口概述：" class="heading-link"><i class="fas fa-link"></i></a><a href="#Iterator接口概述：" class="headerlink" title="Iterator接口概述："></a>Iterator接口概述：</h5>
      <p>Iterator接口表示对集合进行迭代的迭代器，Iterator接口为集合而生，专门实现集合的遍历。此接口主要由有以下两个方法</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hasNext()</td>
<td>判断是否存在下一个过可访问的元素，如果仍有元素可以迭代，则返回true</td>
</tr>
<tr>
<td align="center">next( )</td>
<td>返回要访问的下一个元素。</td>
</tr>
</tbody></table></div>
<p>凡是由Collection接口派生而来的接口或者类，都实现了iterate( )方法，iterate( )方法返回一个Iterator对象。      </p>

        <h5 id="使用Iterator遍历集合"   >
          <a href="#使用Iterator遍历集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Iterator遍历集合" class="headerlink" title="使用Iterator遍历集合"></a>使用Iterator遍历集合</h5>
      <p>下面通过示例来学习使用使用迭代器Iterator遍历ArrayList集合</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">关键代码：</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		ArrayList list = new ArrayList();</span><br><span class="line">		</span><br><span class="line">		list.add(&quot;张三&quot;);</span><br><span class="line">		list.add(&quot;李四&quot;);</span><br><span class="line">		list.add(&quot;王五&quot;);</span><br><span class="line">		</span><br><span class="line">			System.out.println(&quot;使用Iterator遍历，分别是:&quot;);</span><br><span class="line">		//获取迭代器</span><br><span class="line">		Iterator it = list.iterator();</span><br><span class="line">		//判断是否有下一个对象</span><br><span class="line">		while(it.hasNext())&#123;</span><br><span class="line">			//it.next()：返回要访问的下一个元素</span><br><span class="line">			String name = (String)it.next();</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面以 ArrayList 为例使用Iterator接口，其他由 Collection 接口直接或间接派生的集合类，如已经学习的 LinkedList 、HashSet 等，同样可以使用 Iterator  接口进行遍历，遍历方式与遍历 ArrayList 集合的方式相同。
    </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>Set</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性—String类、StringBuffer类和StringBuilder类的区别</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-String%E3%80%81StringBuffer%E5%92%8CStringBuilder/</url>
    <content><![CDATA[
        <h3 id="String类、StringBuffer类和StringBuilder类"   >
          <a href="#String类、StringBuffer类和StringBuilder类" class="heading-link"><i class="fas fa-link"></i></a><a href="#String类、StringBuffer类和StringBuilder类" class="headerlink" title="String类、StringBuffer类和StringBuilder类"></a>String类、StringBuffer类和StringBuilder类</h3>
      
        <h4 id="使用StringBuffer类处理字符串"   >
          <a href="#使用StringBuffer类处理字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用StringBuffer类处理字符串" class="headerlink" title="使用StringBuffer类处理字符串"></a>使用StringBuffer类处理字符串</h4>
      <p>除了使用StingBuffer类处理字符串之外，还可以使用StringBuffer类来存储字符串。</p>
<p>StringBuffer类也是Java提供的用于处理字符串的一个类，而且它是比String类更高效地存储字符串的一种引用数据类型。特别是针对字符串进行连接操作时，使用StringBuffer类可以大大提交程序的执行效率。</p>

        <h5 id="如何使用StringBuffer类"   >
          <a href="#如何使用StringBuffer类" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用StringBuffer类" class="headerlink" title="如何使用StringBuffer类"></a>如何使用StringBuffer类</h5>
      <p>StringBuffer 类位于java.util包中 ，是String的增强类。StringBuffer类提供了很多方法可供使用</p>
<p>声明对象并初始化<br>StringBuffer sb = new StringBuffer(123);</p>
<p>常用的StringBuffer方法</p>
<p> 方法  作用  </p>
<hr>
<p> toString() 转换成String类型的语法格式<br> append()  追加字符串<br> insert()  将参数插入到字符串指定位置后并返回 </p>

        <h5 id="toString-方法"   >
          <a href="#toString-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h5>
      <p>语法格式：<br>字符串.toString();</p>
<p>将StringBuffer类型的字符串1转换为String类型的对象并返回。</p>
<p>例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">StringBuffer sb2 = new StringBuffer(12asda);</span><br><span class="line">String sb1  =sb2.toString();转换为String类</span><br></pre></td></tr></table></div></figure>

        <h5 id="toString-方法-1"   >
          <a href="#toString-方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#toString-方法-1" class="headerlink" title="toString()方法"></a>toString()方法</h5>
      <p>语法格式：<br>字符串.append(参数)；</p>
<p>将参数连接到字符串后并返回</p>
<p>该方法和String类的concat( ) 方法一样，都是把一个字符串追加到另一个字符串后面，所不同的是String类中只能将String的字符串追加到一个字符串后面，而StringBuffer类可以将font color=red任何类型font的值追加到字符串之后。</p>
<p>例：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       StringBuffer sb = new StringBuffer(世界上);</span><br><span class="line">       System.out.println(sb);</span><br><span class="line">       int num = 100;</span><br><span class="line">       在字符串后面追加字符串</span><br><span class="line">       StringBuffer sb1 = sb.append(有多少人);</span><br><span class="line">       System.out.println(sb1);</span><br><span class="line">       在字符串后面追加字符</span><br><span class="line">       StringBuffer sb2 = sb1.append(1232451);</span><br><span class="line">       System.out.println(sb2);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="insert-方法"   >
          <a href="#insert-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#insert-方法" class="headerlink" title="insert()方法"></a>insert()方法</h5>
      <p>语法格式：<br>字符串.insert(位置，参数);</p>
<p>将参数插入到字符串指定位置后斌返回。参数值可以是包括String的任何类型</p>
<p>示例：编写一个方法，实现将一个数字字符串转换成以逗号分割的数字串，即从右边开始，每3个数字用逗号分隔。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">利用StringBuffer类的length方法，获取数字串的长度，使用for循环从后往前隔三位插入逗号</span><br><span class="line"> Scanner sc = new Scanner(System.in);</span><br><span class="line"> 接收数字串，存放于StringBuffer类型的对象中</span><br><span class="line"> System.out.println(请输入一串数字：);</span><br><span class="line"> String nums  = sc.next();</span><br><span class="line"> StringBuffer sb = new StringBuffer(nums);</span><br><span class="line"> 从后往前每隔三位添加一个字符</span><br><span class="line"> for (int i=sb.length()-3;i0;i=i-3)&#123;</span><br><span class="line">     sb.insert(i,,);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(sb);</span><br></pre></td></tr></table></div></figure>



        <h4 id="使用StringBuilder类处理字符串"   >
          <a href="#使用StringBuilder类处理字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用StringBuilder类处理字符串" class="headerlink" title="使用StringBuilder类处理字符串"></a>使用StringBuilder类处理字符串</h4>
      <p>java.long.Stringbuilder是JDK 5.0版本新增的类，它是一个可变的字符序列。</p>
<p>此类提供了一个与StringBuffer兼容的API，被设计用作StringBuffer的一个简易替换，在大多数实现中，它比StringBuffer执行要快。使用StringBuilder类处理字符串的方法与StringBUffer类基本一样，不再举例</p>

        <h4 id="使用String类、StringBuffer类和StringBuilder类的对比"   >
          <a href="#使用String类、StringBuffer类和StringBuilder类的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用String类、StringBuffer类和StringBuilder类的对比" class="headerlink" title="使用String类、StringBuffer类和StringBuilder类的对比"></a>使用String类、StringBuffer类和StringBuilder类的对比</h4>
      <p>String、StringBuffer和Builder这三个类在处理字符串时各有各自的特点和适用场景</p>

        <h5 id="String"   >
          <a href="#String" class="heading-link"><i class="fas fa-link"></i></a><a href="#String" class="headerlink" title="String"></a>String</h5>
      <p>String：字符串常量</p>
<p>String是不可变的对象，在每次对String类型进行改变时其实都是等同于生成了一个新的String对象，然后指向新的String对象，所以经常改变内容的字符串最好不要用String类型，因为每次生成对象都会对系统性能产生影响。</p>

        <h5 id="StringBuffer"   >
          <a href="#StringBuffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h5>
      <p>字符串变量</p>
<p>StringBuffer 是可变的字符串，在每次对StringBuffer对象进行改变时，会对StringBuffer对象本身进行操作，而不是生成新的对象，再改变对象引用。<br>所以，在字符串对象经常改变的情况下他推荐使用StringBuffer类。</p>
<p>字符串连接操作中，StringBuffer类的执行效率要比String类高，例如：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">String str  = new String(wlelcome to);</span><br><span class="line">str+= here;</span><br></pre></td></tr></table></div></figure>
<p> 以上这两句代码是使用String类型来操作字符串，但其处理步骤实际上是通过建立一个StringBuffer 对象，让它调用append( ) 方法，最后再转换为String,这样的话，String的连接操作就比StringBuffer多出了一些附加操作，当然效率要低。并且由于String对象的不可变性也会影响性能</p>

        <h5 id="StringBuilder"   >
          <a href="#StringBuilder" class="heading-link"><i class="fas fa-link"></i></a><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5>
      <p>字符串变量</p>
<p>JDK 5.0版本以后提供了StringBuilder类，它和StringBuffer类等价，区别在于StringBuffer类是线程安全的，StringBuilder类是单线程的，不提供同步，理论上效率更高。关于线程相关的知识在后面更新线程会讲到。<br>未完待续。。。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>String类、StringBuffer类和StringBuilder类的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性—包装类</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[
        <h3 id="包装类"   >
          <a href="#包装类" class="heading-link"><i class="fas fa-link"></i></a><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3>
      
        <h4 id="包装类概述"   >
          <a href="#包装类概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#包装类概述" class="headerlink" title="包装类概述"></a>包装类概述</h4>
      <p>Java语言是面向对象的，但是Java中的基本数据类型却不是面向对象的，这在实际开发中存在很多的不便</p>
<p>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类，称为包装类。</p>
<p>包装类均位于 Java.lang 包中<br>包装类提供了一系列实用方法<br>集合不允许存放基本数据类型数据，存放数字时，要用包装类型</p>
<p><strong>Byte、Short、Integer、Long、Float、Double 都是Number类型</strong></p>
<p>包装类和基本数据类型的对应关系如下</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Douoble</td>
</tr>
</tbody></table></div>
<p>包装类的两个用途</p>
<blockquote>
<p>包装类作为基本数据类型对应的类存在，方便对象操作<br>包装类包含每种基本数据类型的相关属性，如最大值、最小值等，以及相关的操作方法</p>
</blockquote>

        <h4 id="包装类和基本数据类型的转换"   >
          <a href="#包装类和基本数据类型的转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h4>
      
        <h5 id="基本数据类型转换为包装类型"   >
          <a href="#基本数据类型转换为包装类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型转换为包装类型" class="headerlink" title="基本数据类型转换为包装类型"></a>基本数据类型转换为包装类型</h5>
      <p>在Java中，基于基本数据类型数据创建包装类对象通常可以采用如下两种方式</p>
<p>1&gt;使用包装类的构造方法</p>
<p>包装类的构造方法有两种形式</p>
<blockquote>
<p>public Type(type value) 以每个包装类对应的基本数据类型作为参数<br>public Type(String value) 以字符串作为参数</p>
</blockquote>
<p>其中，Type表示包装类，参数type为基本数据类型。<br>针对每一个包装类，都可以使用关键字new将一个基本数据类型值包装为一个对象。<br>例如，要创建一个Integer类型的包装类对象，代码可以这样写</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Integer intValue = new Integer(21);</span><br><span class="line">或</span><br><span class="line">Integer intValue = new Integer(&quot;21&quot;);</span><br></pre></td></tr></table></div></figure>

<p><strong>以每个包装类作为基本数据类型作为参数</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //int 转 Integer</span><br><span class="line">        int iNum =9;</span><br><span class="line">        Integer integer = new Integer(iNum);</span><br><span class="line">        //double 转 Double</span><br><span class="line">        double dNum = 9.8;</span><br><span class="line">        Double d = new Double(dNum);</span><br><span class="line">	 //char 转 Character </span><br><span class="line">        char c = &#x27;c&#x27;;</span><br><span class="line">        Character ch = new Character(c);</span><br><span class="line">	 //float 转 Float </span><br><span class="line">        float f = 9.8f;</span><br><span class="line">        Float fl = new Float(f);</span><br><span class="line">	 //boolean 转 Boolean </span><br><span class="line">        boolean b = true;</span><br><span class="line">        Boolean boo = new Boolean(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


<p>**除Character外，以字符串作为参数 **</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Integer i2 = new Integer(&quot;123&quot;);</span><br><span class="line">   System.out.println(i2+1);//124,并非1231</span><br><span class="line">   /*</span><br><span class="line">   当Number类型的包装类构造方法参数为字符串时，</span><br><span class="line">   字符串必须使能转换为Number类型的字符串，否则会</span><br><span class="line">   报：NumberFormatException 数字格式化异常 </span><br><span class="line">*/</span><br><span class="line">//如下为错误写法</span><br><span class="line">   /*</span><br><span class="line">       Integer i3 = new Integer(&quot;love&quot;);</span><br><span class="line">       System.out.println(i3);</span><br><span class="line">       Integer i4 = new Integer(&quot;null&quot;);</span><br><span class="line">       System.out.println(i4);</span><br><span class="line">       Integer i5 = new Integer(null);</span><br><span class="line">       System.out.println(i5);</span><br><span class="line">     */</span><br><span class="line">       </span><br><span class="line">   Double d2 = new Double(&quot;87.9&quot;);</span><br><span class="line">   System.out.println(d2+1);//88.9 并非87.91</span><br><span class="line"></span><br><span class="line">   //传的是true结构就为true，大小写都一样，false和true相同</span><br><span class="line">   //如果传的是其他字符串，则为false</span><br><span class="line">   //Boolean b2 = new Boolean(&quot;true&quot;);</span><br><span class="line">  Boolean b2 = new Boolean(&quot;TrUe&quot;);</span><br><span class="line">   //Boolean b2 = new Boolean(&quot;false&quot;);</span><br><span class="line">   //Boolean b2 = new Boolean(&quot;FalsE&quot;);</span><br><span class="line">   //Boolean b2= new Boolean(&quot;asd&quot;);</span><br><span class="line">     System.out.println(b2);</span><br><span class="line">     </span><br><span class="line">//Character带字符串作为参数的构造方法</span><br><span class="line">    Character c2 = Character(&quot;a&quot;);</span><br><span class="line">   //这样写就会编译不通过</span><br></pre></td></tr></table></div></figure>


        <h4 id="包装类的常用方法"   >
          <a href="#包装类的常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#包装类的常用方法" class="headerlink" title="包装类的常用方法"></a>包装类的常用方法</h4>
      
        <h5 id="XXXValue-：包装类转换成基本类型"   >
          <a href="#XXXValue-：包装类转换成基本类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#XXXValue-：包装类转换成基本类型" class="headerlink" title="XXXValue( )：包装类转换成基本类型"></a>XXXValue( )：包装类转换成基本类型</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//xxxValue();包装类-&gt;基本数据类型</span><br><span class="line">//包装类型变量转换为基本变量</span><br><span class="line">Integer i = new Integer(100);</span><br><span class="line">int intId=  i.intValue();</span><br><span class="line"></span><br><span class="line">Character c = new Character(&#x27;男&#x27;);</span><br><span class="line">char charId = c.charValue();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h5 id="toString-基本数据类型-gt-字符串"   >
          <a href="#toString-基本数据类型-gt-字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#toString-基本数据类型-gt-字符串" class="headerlink" title="toString();基本数据类型-&gt;字符串"></a>toString();基本数据类型-&gt;字符串</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//toString();基本数据类型-&gt;字符串</span><br><span class="line">  int num = 100;</span><br><span class="line">  String sNum = Integer.toString(num);</span><br><span class="line">  boolean b3 = true;</span><br><span class="line">  String s = Boolean.toString(b3);</span><br><span class="line"></span><br><span class="line">  //常用的方法:基本数据类型-&gt;字符串</span><br><span class="line">  //比上面的toString()更常用</span><br><span class="line">  String sNum2 = 100+&quot;&quot;;</span><br><span class="line">  String s2 = true+&quot;&quot;;</span><br></pre></td></tr></table></div></figure>

        <h5 id="parseXXX-把字符串转换为基本类型"   >
          <a href="#parseXXX-把字符串转换为基本类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#parseXXX-把字符串转换为基本类型" class="headerlink" title="parseXXX( )把字符串转换为基本类型"></a>parseXXX( )把字符串转换为基本类型</h5>
      <p><strong>注意：除了Character其他类型都能转换</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">int num = Integer.parseInt(&quot;36&quot;);</span><br><span class="line">boolean bool = Boolean.parseBoolean(&quot;false&quot;);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//parseXXX()：字符串-&gt;基本数据类型,除Character外,</span><br><span class="line">//常用，需记忆</span><br><span class="line">String age=&quot;18&quot;;</span><br><span class="line">int ageNum = Integer.parseInt(age);</span><br><span class="line"></span><br><span class="line">String score = &quot;98.3&quot;;</span><br><span class="line">double score2 = Double.parseDouble(score);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  编译报错，Character不存在这个方法</span><br><span class="line">  String sex = &quot;女&quot;;</span><br><span class="line">  char cSex = Character.parseChar(sex);</span><br><span class="line"> */</span><br></pre></td></tr></table></div></figure>

        <h5 id="valueOf-基本数据类型-基本数类型—-gt-包装类"   >
          <a href="#valueOf-基本数据类型-基本数类型—-gt-包装类" class="heading-link"><i class="fas fa-link"></i></a><a href="#valueOf-基本数据类型-基本数类型—-gt-包装类" class="headerlink" title="valueOf( ):(基本数据类型):基本数类型—&gt;包装类"></a>valueOf( ):(基本数据类型):基本数类型—&gt;包装类</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">int j = 90;</span><br><span class="line">Integer j1 = Integer.valueOf(j);</span><br><span class="line"></span><br><span class="line">char sex = &quot;男&quot;;</span><br><span class="line">Character cSex = Character.valueOf(sex);</span><br></pre></td></tr></table></div></figure>

        <h5 id="valueOf-字符串-字符串—-gt-包装类，除Character以外"   >
          <a href="#valueOf-字符串-字符串—-gt-包装类，除Character以外" class="heading-link"><i class="fas fa-link"></i></a><a href="#valueOf-字符串-字符串—-gt-包装类，除Character以外" class="headerlink" title="valueOf( ):(字符串):字符串—&gt;包装类，除Character以外"></a>valueOf( ):(字符串):字符串—&gt;包装类，除Character以外</h5>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">valueOf()</span><br><span class="line">    字符串-&gt;包装类，除Character以外</span><br><span class="line">    public static Type valueOf(type value)</span><br><span class="line">    注意事项：当包装类为Number，参数字符串必须为数字兼容的字符串 ，否则会报NumberFormatException</span><br><span class="line">    */</span><br><span class="line">    String m = &quot;123&quot;;</span><br><span class="line">    Integer mi= Integer.valueOf(m);</span><br><span class="line">    //注意事项二:</span><br><span class="line">    //当Boolean调用valueOf(字符串)时,除了参数内容为true(不区分大小写)，其他都为 false</span><br><span class="line">    String flags = &quot;true&quot;;</span><br><span class="line">    Boolean bFlag = Boolean.valueOf(flags);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    编译报错，因为Character不存在这个valueOf(字符串)方法</span><br><span class="line">    String gender = &quot;男&quot;;</span><br><span class="line">    Character gender2 = Character.valueOf(gender);</span><br><span class="line">    */</span><br></pre></td></tr></table></div></figure>


        <h4 id="装箱和拆箱"   >
          <a href="#装箱和拆箱" class="heading-link"><i class="fas fa-link"></i></a><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4>
      
        <h5 id="什么是装箱和拆箱？"   >
          <a href="#什么是装箱和拆箱？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是装箱和拆箱？" class="headerlink" title="什么是装箱和拆箱？"></a>什么是装箱和拆箱？</h5>
      <p>在JavaSE 5.0版本后程序员不需要编码实现基数据类型和包装类之间的转换，编译器会自动完成</p>
<blockquote>
<p>装箱:基本类型转换为包装类的对象<br>包装类对象转换为基本类型的值</p>
</blockquote>
<p><strong>例：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//包装类——&gt;基本数据类型 自动转换——&gt;拆箱</span><br><span class="line">  Integer i = new Integer(100);</span><br><span class="line">  //int iNum = i.intValue();//原来写法</span><br><span class="line">  int iNum=i;//拆箱，现在写法</span><br><span class="line">  System.out.println(iNum);</span><br><span class="line">//基本数据类型——&gt;字符串  自动转换——&gt;装箱</span><br><span class="line">   int j = 90;</span><br><span class="line">   Integer j1 = Integer.valueOf(j);//原来写法</span><br><span class="line">   Integer j2= j;//装箱,现在写法</span><br></pre></td></tr></table></div></figure>

<p>包装类对象只有在基本数据类型需要用对象表示时才是用，包装类并不是用来取代基本数据类型的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>包装类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性-多线程</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[
        <h2 id="Java高级特性-多线程"   >
          <a href="#Java高级特性-多线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java高级特性-多线程" class="headerlink" title="Java高级特性-多线程"></a>Java高级特性-多线程</h2>
      
        <h3 id="认识线程"   >
          <a href="#认识线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#认识线程" class="headerlink" title="认识线程"></a>认识线程</h3>
      <p>计算机的操作系统大多采用多任务和分时设计，多任务是指在一个操作系统中可以同时运行多个程序，例如，可以在使用QQ聊天的同时听音乐，即有多个独立运行的任务，每个任务对应一个进程，每个进程又可以产生多个线程。</p>

        <h4 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程" class="headerlink" title="进程"></a>进程</h4>
      <p>认识进程先从程序开始。程序(Program)是对数据描述与操作的代码的集合，如Office中的Word、暴风影音等应用程序</p>
<p><strong>进程是应用程序的执行实例，有独立的内存空间和系统资源</strong></p>
<p>进程(Process)是程序的一次动态执行过程，他对应了从代码加载、执行至执行完毕的一个完整过程，这个过程也是进程本身从产生、发展至消亡的过程。操作系统同时管理一个计算机系统中的多个进程，让计算机系统中的多个进程轮流使用CPU资源，或共享操作系统的其他资源。</p>
<p>进程的特点：</p>
<blockquote>
<p>进程是系统运行程序的基本单位<br>每一个进程都有自己独立的一块内存空间、一组系统资源<br>每一个进程的内部数据和状态都是完全独立的</p>
</blockquote>
<p>当一个应用程序运行的时候会产生一个进程，如下如图所示</p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/200081/4/4690/69697/6125b7faE700d9518/fc6dfd9e5e7e1628.png" alt="20210825112416.png"></p>

        <h4 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h4>
      <p>线程是CPU调度和分配的基本单位，一个进程在其执行过程中可以产生多个线程，而线程必须在某个进程内执行。</p>
<p>线程是进程内部的一个执行单元，是进程中执行运算的最小单位，是可完成一个独立任务的顺序控制流程，如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为多线程。</p>
<p>线程按处理级别可以分为<font color="#4cb8e7">核心线程</font>和<font color="#4cb8e7">用户级线程</font></p>

        <h5 id="核心级线程"   >
          <a href="#核心级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h5>
      <p>核心级线程是系统任务相关的线程，它负责处理不同进程之间的多个线程。允许不同进程中的线程按照同一相对优先调度方法对线程进行调度，使他们有条不紊地工作，可以发挥多处理器的并发优势，以充分利用计算机的软/硬件资源。</p>

        <h5 id="用户级线程"   >
          <a href="#用户级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h5>
      <p>在开发程序时，由于程序的需要而编写的线程即用户级线程，这些线程的创建、执行和消亡都是在编写应用程序时进行控制的。对于用户级线程的切换，通常发生在一个应用程序的诸多线程之间，如迅雷中的多线程下载就属于用户线程。</p>
<p>多线程可以改善用户体验。具有多个线程的进程能更好的表达和解决现实世界的具体问题，多线程是计算机应用开发和程序设计的一项重要的实用技术。</p>
<p><strong>线程和进程既有联系又有区别，具体如下:</strong></p>
<blockquote>
<p>一个进程中至少要有一个线程<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源<br>处理机分配给线程，即真正在处理机上运行的是线程</p>
</blockquote>

        <h4 id="什么是多线程"   >
          <a href="#什么是多线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h4>
      <p>如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为“多线程”</p>
<p><font color="#4cb8e7">多个线程交替占用CPU资源，而非真正的并行执行</font>(程序执行太快，用户无法直观的感受到线程的交替占用CPU资源)</p>
<p><strong>多线程的优势</strong></p>
<p>多线程有着广泛的应用法，下载工具“迅雷”是一款经典的多线程应用程序，在这个下载工具汇中，可以同时执行多个下载任务。这样不但能够加快下载的速度，减少等待的时间，而且还能充分利用网络和系统资源。</p>
<p>多线程的好处如下：</p>
<blockquote>
<p>多线程程序可以带来更好的用户体验，避免因程序执行过慢而导致出现计算机死机或白屏的情况<br>多线程程序可以最大限度地提高计算机系统的利用效率，如迅雷的多线程下载</p>
</blockquote>

        <h3 id="编写线程类"   >
          <a href="#编写线程类" class="heading-link"><i class="fas fa-link"></i></a><a href="#编写线程类" class="headerlink" title="编写线程类"></a>编写线程类</h3>
      <p>每个程序至少自动拥有一个线程，称为主线程。当程序加载到内存时启用主线程。Java程序中的 public static void main(String[] args) 方法是主线程的入口，运行 Java 程序时，会先执行这个方法。</p>
<p>开发中，用户编写的线程一般都是指除了主线程之外的其他线程。</p>
<p><strong>使用一个线程的步骤：</strong></p>
<blockquote>
<p>1.定义一个线程，同时指明这个线程所要执行的代码，即期望完成的功能<br>2.创建线程对象<br>3.启动线程<br>4.终止线程</p>
</blockquote>
<p>定义一个线程类通常有两种方法，分别是继承 java.lang.Thread 类和实现 java.lang.Runnable 接口</p>

        <h4 id="使用Thread类创建线程"   >
          <a href="#使用Thread类创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Thread类创建线程" class="headerlink" title="使用Thread类创建线程"></a>使用Thread类创建线程</h4>
      <p>Java提供了 java.lang.Thread 类支持多线程编程，该类提供了大量的方法来控制和操作线程，常用方法如下</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void run()</td>
<td align="center">执行任务操作的方法</td>
</tr>
<tr>
<td align="center">void start()</td>
<td align="center">使该线程开始执行</td>
</tr>
<tr>
<td align="center">void sleep(long millis)</td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠(暂停执行)</td>
</tr>
<tr>
<td align="center">String getName()</td>
<td align="center">返回该线程的名称</td>
</tr>
<tr>
<td align="center">int getPriority()</td>
<td align="center">返回线程的优先级</td>
</tr>
<tr>
<td align="center">void setPriority(int newPriority)</td>
<td align="center">更新线程的优先级</td>
</tr>
<tr>
<td align="center">Thread.State getState()</td>
<td align="center">返回该线程的状态</td>
</tr>
<tr>
<td align="center">boolean isAlive()</td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center">void interrupt()</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">void yieid()</td>
<td align="center">暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
</tbody></table></div>
<p>创建线程时继承 Thread 类并重写 Thread 类的 run( )方法。Thread类的run( )方法是线程要执行操作任务的方法，所以线程要执行的代码都要写在run( )方法中，并通过调用start( )方法来启动线程。</p>
<p><strong>示例：使用继承Thread类的方式创建线程，在线程中输出1~100的整数</strong></p>
<p><strong>创建线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//创建并启动线程</span><br><span class="line">//继承Thread</span><br><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i=1;i&lt;=100;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>创建测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class TestMyThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程对象并启动</span><br><span class="line">        MyThread thread = new MyThread();</span><br><span class="line">        MyThread thread2 = new MyThread();</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>运行结果图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/187341/8/20161/34640/6125fd0aE6185e8ff/dfd7ac0b29c59f47.png" alt="20210825161905.png"></p>
<p> 从图中可以发现，如果有两个及以上的线程，他们就在互相替换者占用线程，线程每次执行时长由分配的CPU时间片长度决定</p>
<p>注意：不可以使用run( )来启动线程，run()方法被当做main()中的一个普通方法执行 ，失去了线程的意义，要用start( )启动线程</p>

        <h4 id="使用Runnable接口创建线程"   >
          <a href="#使用Runnable接口创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Runnable接口创建线程" class="headerlink" title="使用Runnable接口创建线程"></a>使用Runnable接口创建线程</h4>
      <p>使用继承Thread类的方式创建线程简单明了，符合大家的习惯，但它也有一个缺点，如果定义的类已经继承了其他类则无法在继承Thread类。这时就可以使用Runnable接口创建线程的方式可以解决上述问题</p>
<p>Runnable接口中声明了一个run( )方法，即 public void run( )。一个类可以通过实现 Runnable接口并实现其 run( )方法完成线程的所有活动，已实现的run( )方法称为该对象的线程体。任何实现 Runnable 接口的对象都可以作为一个线程的目标对象。</p>
<p><strong>示例：使用实现Runnable接口的方式创建线程，在线程中输出1~100的整数</strong></p>
<p><strong>创建线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class MyThreadRunnable implements Runnable&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i&lt;=100; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>创建测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class TestMyThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程对象并启动</span><br><span class="line">        Runnable runnable = new MyThreadRunnable();</span><br><span class="line">        Thread thread = new Thread(runnable,&quot;MyThread1&quot;);</span><br><span class="line">        Thread thread2 = new Thread(runnable,&quot;MyThread2&quot;);</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Theard类和Runnable接口的区别"   >
          <a href="#Theard类和Runnable接口的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Theard类和Runnable接口的区别" class="headerlink" title="Theard类和Runnable接口的区别"></a>Theard类和Runnable接口的区别</h4>
      <p>用一个售票的线程来了解两种方法有什么不同</p>

        <h5 id="使用Theard类"   >
          <a href="#使用Theard类" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用Theard类" class="headerlink" title="使用Theard类"></a>使用Theard类</h5>
      <p><strong>编写线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//创建线程，模拟售票过程</span><br><span class="line">public class MyThread1 extends Thread&#123;</span><br><span class="line">    private int ticket =10;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i &lt;=10 ; i++) &#123;</span><br><span class="line">            if(this.ticket&gt;0)&#123;            System.out.println(Thread.currentThread().getName()+&quot;买票&quot;+this.ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test1Thread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread1 thread = new MyThread1();</span><br><span class="line">        MyThread1 thread2 = new MyThread1();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试结果图</strong></p>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/183464/37/21110/49458/61289636E8adc1742/b5bc607210dcd084.png" alt="20210827153659.png"></p>
<p> 从测试结果中可以看出，使用Thread类在售票时两个售票窗口都售出了10张，但发行的只有10张，Thread不会共享数据，它们在分别完成自己的任务</p>

        <h5 id="实现Runnable接口"   >
          <a href="#实现Runnable接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5>
      <p><strong>编写线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//创建线程，模拟售票过程</span><br><span class="line">public class MyRunnable implements Runnable&#123;</span><br><span class="line">    private int ticket =10;</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i &lt;=10 ; i++) &#123;</span><br><span class="line">            if(this.ticket&gt;0)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;买票--&quot;+this.ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><strong>测试线程类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class TestRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;窗口1&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;窗口2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><strong>测试结果图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/193025/36/20236/23306/6128a1c3E33467735/c7a86e826bcb48b9.png" alt="20210827153659.png"></p>
<p>可以看出，使用Runnable接口实现的买票的方法，只卖出了10张票<br>使用Runnable的优点是便于共享资源，共同完成一个任务</p>

        <h3 id="线程的状态"   >
          <a href="#线程的状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3>
      <p>线程的生命周期可以分为4个状态，分别为新生状态、可运行状态、阻塞状态和死亡状态。一个具有生命的线程，总是处于这4种状态之一。</p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/187442/1/20318/235874/6128a4b5Eb10f8fa5/52c3666bac40cca9.png" alt="20210827153659.png"></p>

        <h4 id="1-新生状态-New-Thread"   >
          <a href="#1-新生状态-New-Thread" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-新生状态-New-Thread" class="headerlink" title="1.新生状态(New Thread)"></a>1.新生状态(New Thread)</h4>
      <p>创建线程对象之后，尚未调用其 start( ) 方法之前，这个线程就有了生命，此时线程仅仅是一个空对象，系统没有为其分配资源。此时只能启动和终止线程，任何其他操作都会引发异常。</p>

        <h4 id="2-可运行状态-Runnable"   >
          <a href="#2-可运行状态-Runnable" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-可运行状态-Runnable" class="headerlink" title="2.可运行状态(Runnable)"></a>2.可运行状态(Runnable)</h4>
      <p>当调用 start( ) 方法启动线程之后，系统为该线程分配除 CPU 外的所需资源，这个线程就有了运行的机会，线程处于可运行状态，在这个状态中，该线程对象可能正在运行，也可能尚未运行。对于一个 CPU 的机器而言，任何时刻只能有一个处于可运行状态的线程占用处理机，获取 CPU 资源，此时系统真正运行线程的 run( ) 方法。</p>

        <h4 id="3-阻塞状态"   >
          <a href="#3-阻塞状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-阻塞状态" class="headerlink" title="3.阻塞状态"></a>3.阻塞状态</h4>
      <p>一个正在运行的线程因某些原因不能继续运行时，进入阻塞状态。阻塞状态是一种“不可运行”的状态，而处于这种状态的线程在得到一个特定的事件之后会转回可运行状态</p>
<p>导致一个线程被阻塞有以下原因:</p>
<blockquote>
<p>调用了Thread类的静态方法sleep( )，sleep( )里面可以放参数，参数为毫秒。<br>一个线程执行的执行需要得到一个对象的锁，而这个对象的锁正在被别的线程占用，那么此线程会被阻塞。<br>线程的suspend( )方法被调用而使线程被挂起时，线程进入阻塞状态。但suspend( )容易导致死锁，已经被JDK列为过期方法，基本不再使用。</p>
</blockquote>
<p>处于阻塞状态的线程可以转回可运行状态，例如，在调用sleep( )方法之后，这个线程的睡眠时间已经达到了指定的间隔，那么它就有可能重新回到可运行状态。或当一个线程等待的锁变得可用的时候，那么这个线程也会从阻塞状态转入可运行状态。</p>

        <h4 id="4-死亡状态-Dead"   >
          <a href="#4-死亡状态-Dead" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-死亡状态-Dead" class="headerlink" title="4.死亡状态(Dead)"></a>4.死亡状态(Dead)</h4>
      <p>一个线程的 run( ) 方法运行完毕、stop( ) 方法被调用或者在运行过程中出现未捕获的异常时，线程进入死亡状态。</p>

        <h3 id="线程调度"   >
          <a href="#线程调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3>
      <p>当同一时刻有多个线程处于可运行状态，它们需要排队等待CPU资源，每个线程会自动获取一个线程的优先级(Priority)，优先级的高低反映线程的重要或紧急程度。<br>可运行状态的线程按优先级排队，线程调度依据建立在优先级的基础上的“先到先服务”原则。</p>
<p>线程调度管理器负责线程排队和在线分配CPU，并按线程调度算法进行调度。当线程调度管理器选中某个线程时，该线程获得CPU资源进入运行状态。</p>
<p>线程调度是抢占式调度，即在当前线程执行过程中如果有一个更高优先级的线程进入可运行状态，则这个更高优先级的线程立即被调度执行。</p>
<p><strong>线程的方法</strong></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void setPriority(int newPriority)</td>
<td align="center">更改线程的优先级</td>
</tr>
<tr>
<td align="center">static void sleep(long millis)</td>
<td align="center">在指定的毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td align="center">void join()</td>
<td align="center">等待该线程终止</td>
</tr>
<tr>
<td align="center">static void yield)()</td>
<td align="center">暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
<tr>
<td align="center">void interrput()</td>
<td align="center">中断线程</td>
</tr>
<tr>
<td align="center">boolean isAlive()</td>
<td align="center">测试线程是否处于活动状态</td>
</tr>
</tbody></table></div>

        <h4 id="优先级和休眠"   >
          <a href="#优先级和休眠" class="heading-link"><i class="fas fa-link"></i></a><a href="#优先级和休眠" class="headerlink" title="优先级和休眠"></a>优先级和休眠</h4>
      <p>线程的有优先级用 1~10 表示，10表示最高优先级，默认是值5，每个优先级对应一个Thread类的公用静态常量。例如</p>
<blockquote>
<p>public static final int NORM_PRIORITY=5;<br>public static final int MIN_PRIORITY=1;<br>public static final int MAX_PRIORITY=10;</p>
</blockquote>
<p>每个线程的优先级都介于 Thread.MIN_PRIORITY 和 Thread.MAX_PROPRIORITY 之间。</p>
<p>线程的优先级可以通过 setPriority(int grade) 方法更改，此方法的参数表示要设置的优先级，它必须是一个 1~10 的整数</p>
<p><strong>优先级案例</strong></p>
<p>Thread方法类</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class MyThreadRunnable implements Runnable&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for (int i = 0; i&lt;=10; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+&quot;:&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//测试类</span><br><span class="line">public class TestMyThreadRunnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建线程对象并启动</span><br><span class="line">        Runnable runnable = new MyThreadRunnable();</span><br><span class="line">        Thread thread = new Thread(runnable,&quot;MyThread1&quot;);</span><br><span class="line">        Thread thread2 = new Thread(runnable,&quot;MyThread2&quot;);</span><br><span class="line">        //线程调度：设置线程优先级</span><br><span class="line">        thread2.setPriority(10);</span><br><span class="line">        thread.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        //启动线程</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>休眠案例</strong></p>
<p>测试类</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//模拟线程休眠</span><br><span class="line">public class Wait &#123;</span><br><span class="line">    public static void bySec(long s) throws InterruptedException &#123;</span><br><span class="line">        // s:线程休眠的秒数</span><br><span class="line">        for (int i = 0; i&lt;=s; i++) &#123;</span><br><span class="line">            System.out.println(i+&quot;秒&quot;);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;-----------------线程开始休眠-----------------&quot;);</span><br><span class="line">        Wait.bySec(10);</span><br><span class="line">        System.out.println(&quot;-----------------线程结束休眠-----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h4 id="join-方法"   >
          <a href="#join-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#join-方法" class="headerlink" title="join( ) 方法"></a>join( ) 方法</h4>
      <p>join( ) 方法使当前线程暂停执行，等待调用该方法的线程结束后再继续执行本线程。<br>它有三种重载形式</p>
<blockquote>
<p>public final void join( )<br>public final void join(long mills)<br>public final void join(long mills,int nanos)</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class TestThread &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //创建子线程对象</span><br><span class="line">        Runnable runnable = new MyThread();</span><br><span class="line">        Thread t = new Thread(runnable,&quot;MyThread&quot;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        //主线程</span><br><span class="line">        for (int i = 0; i &lt;=20 ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">            //当i=5的时候，强制把 t 线程加入执行</span><br><span class="line">            //线程调度：join() --等待线程终止：等待 t 线程执行结束后，main主线程在继续执行</span><br><span class="line">            if(i==5)&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="yield-方法"   >
          <a href="#yield-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield-方法" class="headerlink" title="yield( ) 方法"></a>yield( ) 方法</h4>
      <p>yield( ) 方法可以让当前线程暂停执行，允许其他线程执行，但该线程仍处于可运行状态，并不变为阻塞状态。此时，系统选择其他相同或更高级线程执行，若无其他相同或更高优先级线程，则该线程继续执行。</p>
<p><strong>案例：使用yield( ) 方法暂停线程</strong></p>
<p>yield( ) 方法的语法格式如下</p>
<blockquote>
<p>public static void yield( )</p>
</blockquote>
<p>yield( ) 方法可以让当前线程暂停执行，允许其他线程执行，但该线程仍处于可运行状态，并不变为阻塞状态 。此时，系统选择其他相同或更高优先级线程执行，若无其他想同或更高优先级线程，则该线程继续执行。</p>
<p>案例：</p>
<p><strong>方法</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class TestYield implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i=0;i&lt;= 4;i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">            if (i==3)&#123;</span><br><span class="line">                //礼让，线程调度：yield</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建两个线程对象</span><br><span class="line">        Runnable r = new TestYield();</span><br><span class="line">        Thread t1= new Thread(r,&quot;线程A&quot;);</span><br><span class="line">        Thread t2= new Thread(r,&quot;线程B&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>注意：线程礼让只是提供一种可能性，不能保证一定实现礼让</strong></p>

        <h4 id="yield-方法和join-方法的区别"   >
          <a href="#yield-方法和join-方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield-方法和join-方法的区别" class="headerlink" title="yield( ) 方法和join( )方法的区别"></a>yield( ) 方法和join( )方法的区别</h4>
      <p><strong>yield( ):</strong> </p>
<blockquote>
<p>暂停当前正在执行的线程对象，并执行其他线程，线程礼让<br>只是提供一种可能，但那是不能保证一定会实现礼让</p>
</blockquote>
<p><strong>join( ):</strong></p>
<blockquote>
<p>join( ) : 阻塞当前线程，直到其他线程执行完毕，当前线程才进入就绪状态</p>
</blockquote>

        <h4 id="yield-方法和-sleep-方法的区别"   >
          <a href="#yield-方法和-sleep-方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield-方法和-sleep-方法的区别" class="headerlink" title="yield( ) 方法和 sleep( )方法的区别"></a>yield( ) 方法和 sleep( )方法的区别</h4>
      <p>sleep( ) 方法 ：</p>
<blockquote>
<p>使当前线程进入被阻塞的状态<br>即使没有其他等待运行的线程，当前线程也会等待指定的时间<br>其他等待执行的线程的机会是均等的</p>
</blockquote>
<p>yield( ) 方法 ：</p>
<blockquote>
<p>当前线程转入暂停执行的装态<br>如果没有其他等待执行的线程，当前线程就会马上恢复执行<br>会运行优先级相同或更高的线程</p>
</blockquote>

        <h4 id="练习：模拟多人爬山"   >
          <a href="#练习：模拟多人爬山" class="heading-link"><i class="fas fa-link"></i></a><a href="#练习：模拟多人爬山" class="headerlink" title="练习：模拟多人爬山"></a>练习：模拟多人爬山</h4>
      <p>需求说明 ：每个线程代表一个人，可设置每人爬山速度，每爬完100米显示信息 ，爬到终点给出相应提示。</p>
<p><strong>业务类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//模拟爬山</span><br><span class="line">public class ClimbThread extends Thread &#123;</span><br><span class="line">    //爬100米的时长(线程休眠的时长)</span><br><span class="line">    private int time;</span><br><span class="line">    //爬多少个100米</span><br><span class="line">    private  int num;</span><br><span class="line"></span><br><span class="line">    //name:年轻人/老年人  time：爬100米的时长，kilometer山的高度(千米)</span><br><span class="line">    public ClimbThread(String name,int time ,int kilometer)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.time=time;</span><br><span class="line">        this.num = kilometer*1000/100;//根据山的高度计算有多少个100米</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟爬山的过程</span><br><span class="line"></span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(num&gt;0) &#123;</span><br><span class="line">            //模拟爬100米的过程</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(time);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;爬完了100米&quot;);</span><br><span class="line">            num--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;爬到了终点&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClimbThread young  = new ClimbThread(&quot;年轻人&quot;,150,1);</span><br><span class="line">        ClimbThread old  = new ClimbThread(&quot;老年人&quot;,350,1);</span><br><span class="line">        System.out.println(&quot;****************开始爬山****************&quot;);</span><br><span class="line">        young.start();</span><br><span class="line">        old.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="多线程共享数据问题"   >
          <a href="#多线程共享数据问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#多线程共享数据问题" class="headerlink" title="多线程共享数据问题"></a>多线程共享数据问题</h3>
      <p><strong>抢票案例</strong></p>
<p><strong>抢票类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//模拟用户购票</span><br><span class="line">public class TicketThread implements Runnable&#123;</span><br><span class="line">    private int ticket = 10;//记录车票总数</span><br><span class="line">    private int num = 0;//记录用户抢到了第几张票</span><br><span class="line"></span><br><span class="line">    //用户抢票的过程</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //没有余票，跳出循环</span><br><span class="line">            if(ticket&lt;=0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //有余票，则抢票</span><br><span class="line">            ticket--;</span><br><span class="line">            num++;</span><br><span class="line">            //模拟网络延迟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //第二步：显示出票反馈给用户</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;抢到了第&quot;+num+&quot;剩余&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//用户网络抢票</span><br><span class="line">public class TestThread &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new TicketThread();</span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;桃票票&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;快手张&quot;);</span><br><span class="line">        Thread t3 = new Thread(runnable,&quot;黄牛党&quot;);</span><br><span class="line">        System.out.println(&quot;开始抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> <strong>效果图</strong></p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/190267/36/20836/34381/612da62dEc0ca894e/eb3feb77db150468.png" alt="20210831114628.png"></p>
<p>可以从中发现一些问题</p>
<p>1.不是从第1张票开始<br>2.存在多人抢到一张票的情况<br>3.有些票号乜有抢到<br>。。。。。。</p>
<p>这些问题可以说明：当多线程操作同一共享资源时，将引发数据不安全问题</p>

        <h3 id="线程同步"   >
          <a href="#线程同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3>
      <p>前面介绍的线程都是独立的，而且异步执行，也就是说每个线程都包含了运行时所需要的数据或方法，而不需要外部资源或方法，也不必关心其他线程的状态或行为。但是经常有一些同时运行的线程需要共享数据，此时就需要考虑其他线程的状态和行为，否则就不能保证程序运行结果的正确性。</p>
<p> 当两个或多个线程访问同一资源时，需要以某种顺序来确保该资源在某一时刻只能被一个线程使用的方式称为线程同步</p>
<p>采用同步来控制线程的执行有两种方式，即同步方法和同步代码块。这两种方式都使用 synchronized 关键字实现</p>

        <h4 id="使用-synchronized-方法"   >
          <a href="#使用-synchronized-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-synchronized-方法" class="headerlink" title="使用 synchronized 方法"></a>使用 synchronized 方法</h4>
      <p>使用 synchronized 修饰的方法控制对类成员变量的访问。每个类实例对应一把锁，方法一旦执行，就独占该锁，知道方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对应每一个实例，其所有声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。</p>
<p><strong>同步方法的语法格式如下：</strong></p>
<blockquote>
<p>访问修饰符 synchronized 返回类型 方法名{}<br>或者<br>sychronized 访问修饰符 返回类型 方法名{}</p>
</blockquote>
<p><strong>使用 synchronized 方法来解决上面的买票功能</strong></p>
<p><strong>把需要同步的代码提取出来，这里需要同步的就是买票的代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//模拟用户购票--使用 synchronized 同步方法</span><br><span class="line">public class TicketThread1 implements Runnable&#123;</span><br><span class="line">    private int ticket = 10;//记录车票总数</span><br><span class="line">    private int num = 0;//记录用户抢到了第几张票</span><br><span class="line">    boolean flag= false;//记录票是否买完</span><br><span class="line">    //用户抢票的过程</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(!flag)&#123;</span><br><span class="line">            sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void sale()&#123;</span><br><span class="line">        //没有余票，跳出循环</span><br><span class="line">        if(ticket&lt;=0)&#123;</span><br><span class="line">            flag=true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //有余票，则抢票</span><br><span class="line">        ticket--;</span><br><span class="line">        num++;</span><br><span class="line">        //模拟网络延迟</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //第二步：显示出票反馈给用户</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;抢到了第&quot;+num+&quot;剩余&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//用户网络抢票</span><br><span class="line">public class TestThread1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new TicketThread1();</span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;桃票票&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;快手张&quot;);</span><br><span class="line">        Thread t3 = new Thread(runnable,&quot;黄牛党&quot;);</span><br><span class="line">        System.out.println(&quot;开始抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>效果图</strong></p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/203240/17/3969/34896/612dc8b0Ed9da6a2b/6d419307572bbae2.png" alt="20210831141337.png"></p>

        <h4 id="使用-synchronized-代码块"   >
          <a href="#使用-synchronized-代码块" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用-synchronized-代码块" class="headerlink" title="使用 synchronized 代码块"></a>使用 synchronized 代码块</h4>
      <p>代码块和方法的作用一样，语法格式如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">synchronized(syncObject)&#123;</span><br><span class="line">	//需要同步访问控制的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>synchronized 块中的代码必须获得对象 syncObject 的锁才能执行，具体实现机制与同步方法一样。由于可以针对任意代码块，且可任意指定上锁对象，故灵活性较高。</p>
<p><strong>使用 synchronized 代码块修改抢票代码</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//模拟用户购票--使用 synchronized 同步代码块</span><br><span class="line">public class TicketThread2 implements Runnable&#123;</span><br><span class="line">    private int ticket = 10;//记录车票总数</span><br><span class="line">    private int num = 0;//记录用户抢到了第几张票</span><br><span class="line"></span><br><span class="line">    //用户抢票的过程</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            synchronized (this)&#123;</span><br><span class="line">                //没有余票，跳出循环</span><br><span class="line">                if(ticket&lt;=0)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //有余票，则抢票</span><br><span class="line">                ticket--;</span><br><span class="line">                num++;</span><br><span class="line">                //模拟网络延迟</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //第二步：显示出票反馈给用户</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;抢到了第&quot;+num+&quot;剩余&quot;+ticket+&quot;张票&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>测试类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//用户网络抢票</span><br><span class="line">public class TestThread2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new TicketThread2();</span><br><span class="line">        Thread t1 = new Thread(runnable,&quot;桃票票&quot;);</span><br><span class="line">        Thread t2 = new Thread(runnable,&quot;快手张&quot;);</span><br><span class="line">        Thread t3 = new Thread(runnable,&quot;黄牛党&quot;);</span><br><span class="line">        System.out.println(&quot;开始抢票&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>效果图</strong></p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/192269/39/20949/35547/612dcae4Ecdf41bcf/f9568675b32affb0.png" alt="20210831114628.png"></p>

        <h3 id="死锁"   >
          <a href="#死锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3>
      <p>多线程在使用同步机制时，存在“死锁”的潜在危险。如果多个线程都处于等待装态而无法唤醒时，就构成了死锁（Deadlock） ，此时处于等待装态的多个线程占用系统资源，但无法运行，因此不会释放自身的资源。</p>
<p>在编程时应注意死锁问题，避免死锁的有效方法是：线程因某个条件未满足<br>而受阻，不能让其继续占有资源；如果多个对象需要互斥访问，应确定线程获得锁的顺序，并保证整个程序以相反的顺序释放锁。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性-泛型</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[
        <h3 id="泛型"   >
          <a href="#泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3>
      
        <h4 id="认识泛型"   >
          <a href="#认识泛型" class="heading-link"><i class="fas fa-link"></i></a><a href="#认识泛型" class="headerlink" title="认识泛型"></a>认识泛型</h4>
      <p>泛型是<font color="red"> JDK1.5 </font>的新特性，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数，使代码可以应用于多种类型。</p>
<p>简单来说，Java语言引入泛型的好处是安全简单，且所有强制类型转换都是自动和隐式进行的，提高了代码的重用率。</p>
<p>安全指的是加入泛型之后只能存储指定的类型，例如存储一个Student类型的泛型，那么Teacher类型就存不进去。</p>

        <h4 id="泛型的定义"   >
          <a href="#泛型的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型的定义" class="headerlink" title="泛型的定义"></a>泛型的定义</h4>
      <p>将对象的类型作为参数，指定到其他类或者方法上，从而保证类型转换的安全性和稳定性，这就是泛型。泛型的本质就是参数化类型。</p>
<p><strong>参数化类型</strong>：将类型由原来的具体的类型参数化，就像方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用或调用时传入具体的类型（类型实参）。</p>
<p>泛型的定义语法如下:</p>
<blockquote>
<p>类 1 或者接口&lt;类型实参&gt; 对象 = new 类2&lt;类型实参&gt;( );</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>首先，类2 可以是 类1 本身，可以是 类1 的子类，还可以是接口的实现类；<br>其次，类2 的类型实参必须与 类1 的类型实参相同</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">例如：ArrayList &lt;String&gt;  List= new ArrayLIst&lt;String&gt;( );</span><br></pre></td></tr></table></div></figure>


        <h4 id="泛型在集合中的应用"   >
          <a href="#泛型在集合中的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#泛型在集合中的应用" class="headerlink" title="泛型在集合中的应用"></a>泛型在集合中的应用</h4>
      <p>List接口中的 add( )方法参数是Object类型，不管把什么对象放入List接口及其子接口或实现类中，都会被转换为Object类型。在通过get( )方法取出集合中元素时必须进行强制类型转换，不仅繁琐而且容易出现ClassCastException异常。</p>
<p>Map接口中使用put( )方法和get( )方法存取对象时，以及使用Iterator的next( )方法获取元素时存在同样问题。</p>
<p>JDK1.5中通过引入泛型有效地解决了这个问题。JDK1.5中已经改写了集合框架中的所有接口和类，增加了对泛型的支持，也就是泛型集合。</p>
<p>使用泛型集合在创建集合对象时指定集合中元素的类型，从集合中取出元素时无需进行强制类型转换，并且如果把非指定类型对象放入集合，会出现编译错误。</p>
<p>List和ArrayList的泛型形式是</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">List&lt;E&gt;和ArrayList&lt;E&gt;</span><br><span class="line">ArrayList&lt;E&gt;与ArrayList类的常用方法基本一样</span><br></pre></td></tr></table></div></figure>


<p><strong>使用案例来认识泛型</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class NewsMgr &#123;</span><br><span class="line">//对新闻标题的存储即操作（ArrayList）</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//创建新闻标题对象</span><br><span class="line">		NewsTitle title1 = new NewsTitle(1,&quot;故宫&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle title2 = new NewsTitle(1,&quot;长城&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle title3 = new NewsTitle(1,&quot;颐和园&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle title4 = new NewsTitle(1,&quot;北海&quot;,&quot;管理员&quot;);</span><br><span class="line">		NewsTitle title5 = new NewsTitle(1,&quot;天安门&quot;,&quot;管理员&quot;);</span><br><span class="line">		</span><br><span class="line">		//创建集合对象,并且将新闻标题加入到集合中</span><br><span class="line">		ArrayList&lt;NewsTitle&gt;  list = new ArrayList&lt;NewsTitle&gt;();</span><br><span class="line">		//等同于数组中的list[0] = title1;</span><br><span class="line">		list.add(title1);</span><br><span class="line">		list.add(title2);</span><br><span class="line">		list.add(title3);</span><br><span class="line">		list.add(title4);</span><br><span class="line">		list.add(title5);</span><br><span class="line"></span><br><span class="line">		//获取新闻标题的总数</span><br><span class="line">		//ArrayList的size()方法等同于数组的length属性的作用</span><br><span class="line">		System.out.println(&quot;新闻标题一共有&quot;+list.size()+&quot;条。&quot;);</span><br><span class="line">		//逐条打印新闻标题名称</span><br><span class="line">		//方法一：遍历ArrayList元素的位置(下标)</span><br><span class="line">		for(int i=0;i&lt;list.size();i++)&#123;</span><br><span class="line">			NewsTitle title = list.get(i);</span><br><span class="line">			System.out.println(title.getTitle());</span><br><span class="line">		&#125;</span><br><span class="line">		//方法二:增强型for</span><br><span class="line">		System.out.println(&quot;#############################&quot;);</span><br><span class="line">		for (NewsTitle titles : list) &#123;</span><br><span class="line">			NewsTitle title = titles;</span><br><span class="line">			System.out.println(title.getTitle());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> 上面例子通过泛型指定了ArrayList中元素的类型，代码中指定了ArrayList中只能添加 NewsTitle 类型的数据，如果添加了其他类型的数据就会编译错误，这在一定程度上保证了代码的安全性，并且数据添加到集合后不再转换为Object类型，保存的是指定的数据类型，所以在集合中获取数据时也不在需要进型强制类型转换。</p>
<p>同样，Map与HashMap也有他们的泛型形式，即key&lt;K,V&gt;和HashMap&lt;K,V&gt;。</p>
<p>因为他们的每一个元素都包含两个部分，即key和value，所以，在应用泛型时，要同时指定key的类型和value的类型，K表示key的类型也就是键，V表示value的类型也就是值</p>
<p>HashMap&lt;K,V&gt;与HashMap操作数据的方法基本一样，下面来演示一下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class DemoMap &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//创建实体类对象</span><br><span class="line">		Student stu1= new Student(&quot;王五&quot;,&quot;男&quot;);</span><br><span class="line">		Student stu2 = new Student(&quot;王加萨达&quot;,&quot;男&quot;);</span><br><span class="line">		Student stu3= new Student(&quot;李洒我&quot;,&quot;女&quot;);</span><br><span class="line">		Student stu4 = new Student(&quot;李静佳&quot;,&quot;女&quot;);</span><br><span class="line">		</span><br><span class="line">		//声明Map 对象</span><br><span class="line">		Map&lt;String,Student&gt; map = new HashMap&lt;String,Student&gt;();</span><br><span class="line">		//把实体类对象加入到Map中去</span><br><span class="line">		map.put(&quot;Jack&quot;, stu1);</span><br><span class="line">		map.put(&quot;Tom&quot;, stu2);</span><br><span class="line">		map.put(&quot;luxi&quot;, stu3);</span><br><span class="line">		map.put(&quot;Rose&quot;, stu4);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		//输出英文名</span><br><span class="line">		System.out.println(&quot;学生英文名&quot;);</span><br><span class="line">		for (String key : map.keySet()) &#123;</span><br><span class="line">			System.out.println(key);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;---------------------------------------------------&quot;);</span><br><span class="line">		//输出学生详细信息</span><br><span class="line">		for (Student value : map.values()) &#123;</span><br><span class="line">			System.out.println(&quot;姓名:&quot;+value.getName()+&quot; 性别:&quot;+value.getSex());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;---------------------------------------------------&quot;);</span><br><span class="line">		//实现获取特定英文名称对应的学生信息</span><br><span class="line">		Scanner sc = new Scanner(System.in);</span><br><span class="line">		System.out.print(&quot;请输入某位学员的英文名称:&quot;);</span><br><span class="line">		String name = sc.next();</span><br><span class="line">		if(map.containsKey(name))&#123;</span><br><span class="line">			Student student = map.get(name);</span><br><span class="line">			System.out.println(&quot;😢😎😉😉😉😉😉😉😗😍🙄👩🏻&quot;);</span><br><span class="line">			System.out.println(name+&quot;-&quot;+student.getName()+&quot;-&quot;+student.getSex());</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			System.out.println(&quot;没有此学生！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>通过&lt;String,Student&gt;指定了Map集合的数据类型，在使用put( )方法存储数据时，Map集合的key必须为String类型，value必须为Student类型的数据</p>
<p>而在遍历键集的for循环中，变量的key不再是Object</p>
<p>而是String,在遍历值集的for循环中，变量value的类型不再是Object，而是Student</p>
<p>同样，Map.get(key)得到的值也是Student类型数据，不在需要进行强制类型转换</p>
<p>其他集合类也有自己的泛型，用法和ArrayList和HashMap的泛型类似</p>
<p>泛型使集合的使用更方便，也提升了安全性：</p>
<blockquote>
<p>存储数据时进型严格的类型检查，确保只有合适类型的对象才能存储到集合中<br>从集合中检索对象时，减少了强制类型转换。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性-日期类</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    <content><![CDATA[
        <h3 id="日期类"   >
          <a href="#日期类" class="heading-link"><i class="fas fa-link"></i></a><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3>
      <p>Java.util包中提供的和日期相关的类有Date、Calendar类和DateFormat类等。</p>

        <h4 id="Date类"   >
          <a href="#Date类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4>
      <p>Date类对象用来表示日期和时间，该类提供了一系列操作日期和时间各组成部分的方法。Date类中使用最多的是获取系统当前日期和时间，例如</p>
<blockquote>
<p>Date date   = new Date();</p>
</blockquote>
<p>这句代码是使用系统当前时间创建日期对象</p>

        <h4 id="Calendar类"   >
          <a href="#Calendar类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4>
      <p>Calendar类也是同来操作日期和时间的类，它可以看做是Date类的一个增强版。</p>
<p>Calendar类提供了一组方法，允许把一个以毫秒为单位的时间转化成年、月、日、小时、分、秒。可以把Calendar类当做是万年历，默认显示的是当前的时间，也可以查看其他时间。</p>
<p>Calendar类是抽象类，可以通过静态方法getInstance( )获得Calender类的对象，其是这个获取的对象是它的子类对象。</p>
<p>Calendar类提供一些方法和静态字段来操作日历，如</p>
<blockquote>
<p>int get(int field)  返回给定日历字段的值<br>YEAR：表示年<br>MONTH：表示月<br>DAY_OF_MONTH：指示一个月中的某天<br>DAY_OF_WEEK：指示一个星期中的某天</p>
</blockquote>
<p>例：使用Calendar获取日期及星期</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Calendar ca = Calendar.getInstance();</span><br><span class="line">    System.out.println(&quot;今天是：&quot;+ca.get(Calendar.YEAR)+&quot;年&quot;+(ca.get(Calendar.MONTH)+1)+&quot;月&quot;+ca.get(Calendar.DAY_OF_MONTH)+&quot;日&quot;);</span><br><span class="line">    System.out.println(&quot;今天星期&quot;+(ca.get(Calendar.DAY_OF_WEEK)-1));</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>注意：</p>
<blockquote>
<p>MONTH返回的是0到11，所以要在后面+1<br>DAY_OF_WEEK中的sunday表示的是1，所以要 -1</p>
</blockquote>

        <h4 id="DateFormat类"   >
          <a href="#DateFormat类" class="heading-link"><i class="fas fa-link"></i></a><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4>
      <p>它是一个格式化日期的类，在java.text包下，是一个抽象类，提供了多种格式化和解析时间的方法。格式化是指将日期转换成文本，解析是指将文本转换成日期格式。</p>
<p>使用较多的是它的子类SimpleDateFormat，SimpleDateFormat类是一个以语言环境有关的方式来格式化和解析日期的具体类，如“yyyy-MM-dd HH:mm:ss”就是指定的一种日期和时间格式</p>
<p>示例：获取系统当前时间，并使用SimpleDateFormat类格式化日期</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> //获取系统当前时间，并使用SimpleDateFormat格式化当前日期</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Date date = new Date();</span><br><span class="line">    SimpleDateFormat sdf =new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">    String format = sdf.format(date);</span><br><span class="line">    System.out.println(&quot;当前系统时间为:&quot;+format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在示例中，Date date  = new Date();获取Date对象，并初始化为当前时间，<br>SimpleDateFormat类负责把当前日期时间格式化为“yyyy-MM-dd HH:mm:ss”这样的格式</p>
<p><strong>案例1：获取当前时间，使用SimpleDateFormat以“年-月-日”方式显示</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(sdf.format(date));</span><br><span class="line">//SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br></pre></td></tr></table></div></figure>

<p><strong>案例2：计算2021年4月6日是一年中的第几个星期</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">System.out.println(&quot;当前日期为&quot;+sdf.format(date));</span><br><span class="line">ca.set(Calendar.YEAR,2021);</span><br><span class="line">ca.set(Calendar.MONTH,3);</span><br><span class="line">ca.set(Calendar.DAY_OF_MONTH,6);</span><br><span class="line">int week  =  ca.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">System.out.println(&quot;2021年4月6日是一年里的&quot;+week+&quot;周&quot;);</span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性-枚举</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[
        <h3 id="枚举"   >
          <a href="#枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3>
      
        <h4 id="枚举概述"   >
          <a href="#枚举概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#枚举概述" class="headerlink" title="枚举概述"></a>枚举概述</h4>
      <p>从 JavaSE 5.0 开始，Java程序设计语言引入了一种新的类型——枚举( Enum )</p>
<p>枚举是指由一组固定的常量组成的类型。使用关键字<font color="red">enum</font>定义。</p>
<p>定义枚举语法格式如下</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">[Modifier] enum enumName&#123;</span><br><span class="line">	enumContantName1[,enumConstantName2...[;]]</span><br><span class="line">	//[field,method]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>1.Modifier是访问修饰符，如public等<br>2.enum是关键字<br>3.enumContantName1[,ContantName2…[;]]表示枚举常量列表，枚举常来那个之间用逗号隔开。<br>4.//[field，method]表示其他的成员，包括构造方法，置于枚举常量的后面<br>5.在枚举中如果除了定义枚举常量，还定义了其他成员，则枚举常量列表必须以分号结尾</p>
</blockquote>
<p>定义表示性别的枚举，两个枚举常量分别代表“男”和“女”</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public enum Genders&#123;</span><br><span class="line">	Male,Female</span><br><span class="line">	//或 </span><br><span class="line">	男,女</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>使用</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">比如现在有一个学生类</span><br><span class="line">Student stu = new Student();</span><br><span class="line">stu.sex=Genders.男</span><br><span class="line">或者</span><br><span class="line">stu.sex=Genders.Male</span><br></pre></td></tr></table></div></figure>
<p><strong>下面用一个示例来演示枚举的使用</strong></p>
<p>定义一个枚举，其中包括7个枚举常量，代表一周的七天，编程实现查看一周中每天的日程安排。</p>
<p><strong>声明枚举类</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public enum WeekEnum &#123;</span><br><span class="line">    MON,TUE,WED,THU,FRI,SAT,SUN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><strong>测试</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">public class TestWeekEnum &#123;</span><br><span class="line">    public void doWhat(WeekEnum day)&#123;</span><br><span class="line">        switch (day)&#123;</span><br><span class="line">            case MON:      </span><br><span class="line">            case TUE:</span><br><span class="line">            case WED:</span><br><span class="line">            case FRI:</span><br><span class="line">                System.out.println(&quot;工作日&quot;);</span><br><span class="line">            case SAT:</span><br><span class="line">                System.out.println(&quot;休息日，星期六&quot;);</span><br><span class="line">            case SUN:</span><br><span class="line">                System.out.println(&quot;休息日，星期日&quot;);</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;输入的日期不正确！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestWeekEnum we = new TestWeekEnum();</span><br><span class="line">        we.doWhat(WeekEnum.THU);</span><br><span class="line">        WeekEnum sat = WeekEnum.SAT;</span><br><span class="line">        we.doWhat(sat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>枚举第二种写法</p>
<p>在类里面定义枚举</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">//输出学生每个学习阶段的学习目标</span><br><span class="line">public class StudyTraget &#123;</span><br><span class="line">    //定义枚举</span><br><span class="line">    public enum Level&#123;</span><br><span class="line">        L1,L2,L3</span><br><span class="line">    &#125;</span><br><span class="line">    //输出每个阶段的学习目标</span><br><span class="line">    public void showTatget(Level level)&#123;</span><br><span class="line">        switch (level)&#123;</span><br><span class="line">            case L1:</span><br><span class="line">                System.out.println(&quot;学习目标，Java开发工程师&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case L2:</span><br><span class="line">                System.out.println(&quot;学习目标，大数据开发工程师&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case L3:</span><br><span class="line">                System.out.println(&quot;学习目标，大数据挖掘工程师&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StudyTraget traget = new StudyTraget();</span><br><span class="line">        traget.showTatget(Level.L2);</span><br><span class="line">        Level level = Level.L1;</span><br><span class="line">        traget.showTatget(level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>在程序中使用枚举的好处</strong></p>
<blockquote>
<p>1.枚举可以使代码更易于维护，有助于确保所使用的的变量是指定合法的、期望的值。<br>枚举更易于编程时输入，使用枚举赋值，只需要输入枚举名，然后输入一个点，就能将所有的值显示出来。<br>枚举使代码更清晰，允许用描述性的名称表示数据，使用时直观方便。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高级特性-集合介绍</title>
    <url>/2021/09/10/Java%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[
        <h3 id="Java高级特性—集合框架介绍"   >
          <a href="#Java高级特性—集合框架介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java高级特性—集合框架介绍" class="headerlink" title="Java高级特性—集合框架介绍"></a>Java高级特性—集合框架介绍</h3>
      <p>在程序开发中，如果想存储多个数据类型，可以使用数组来实现，但是使用数组存在一些问题：</p>
<blockquote>
<p>1.数组的长度固定不变，不能很好的适应元素动态变化。<br>2.可通过<font color="#00BFFF">&lt;数组名&gt;.length</font>获取数组长度，但却无法直接获取数组中实际存  储的元素个数。<br>3.数组采用在内存中分配连续空间的存储方式存储，根据元素信息查找时效率比较低 ，需要多次查找</p>
</blockquote>
<p>从上面可以看出数组在处理一些问题是存在明显缺陷，针对数组的缺陷，Java提供了比数组更灵活、更实用的集合框架，可大大提高软件的开发效率，并且不同的集合可使用不同的应用场景</p>
<p>Java集合提供了一套性能优良、使用方便的接口和类，它们都位于<font color="#00BFFF"> java**.**util </font>包中，其主要内容及彼此关系如下图所示：<br><img src="https://img14.360buyimg.com/ddimg/jfs/t1/201183/23/825/65373/6110c775E4a73ddce/da52c3258eabd9ce.png" alt="20210809141212.png"><br>从图中可以看出Java集合类主要由Map接口和Collection接口派生而来，其中Collection接口有两个常用子接口：List接口和Set接口，所以通常说Java集合框架由3大类接口构成：Map接口、List接口和Set接口</p>
<p>Collection、Iterator、Map是三个独立的接口</p>
<p>Collections  提供了对集合进行排序、遍历等多种算法实现</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java高级特性</tag>
        <tag>集合介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>你好博客</title>
    <url>/2021/08/01/hello-world/</url>
    <content><![CDATA[<p>欢迎来到<span class="exturl"><a class="exturl__link"   href="https://hexo.io/" >Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>！这是你的第一篇文章。查看<span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/" >文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>以获得更多信息。如果在使用Hexo时遇到任何问题，您可以在<span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/troubleshooting.html" >故障排除</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中找到答案，或者可以在<span class="exturl"><a class="exturl__link"   href="https://github.com/hexojs/hexo/issues" >GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>上询问我。</p>

        <h2 id="快速启动"   >
          <a href="#快速启动" class="heading-link"><i class="fas fa-link"></i></a><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2>
      
        <h3 id="Create-a-new-post"   >
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>更多信息: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/writing.html" >Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="运行服务器"   >
          <a href="#运行服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>更多信息: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/server.html" >服务器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="生成静态文件"   >
          <a href="#生成静态文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>更多信息: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/generating.html" >Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="部署到远程站点"   >
          <a href="#部署到远程站点" class="heading-link"><i class="fas fa-link"></i></a><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>更多信息: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/one-command-deployment.html" >部署</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>初入Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>接口和抽象类的区别</title>
    <url>/2021/09/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>抽象类和接口的比较</strong><br><strong>相同点</strong> </p>
<blockquote>
<ol>
<li>代表系统的抽象层</li>
<li>都不能被实例化</li>
<li>都能包含抽象方法: 用于描述系统提供的服务，不必提供具体实现</li>
</ol>
</blockquote>
<p><strong>不同点</strong></p>
<blockquote>
<ol>
<li>在抽象类中可以为部分普通方法提供默认实现，JDK8之前接口中只能包含抽象方法，JDK8之后接口可包含默认方法</li>
<li>一个类只能继承一个直接的父类，但可以实现多个接口</li>
</ol>
</blockquote>
<p><strong>使用原则</strong></p>
<p>is-a 抽象类; has-a 接口<br>接口做系统与外界交互的窗口<br>    接口提供服务<br>接口本身一旦制定，就不允许随意修改<br>抽象类可完成部分功能实现，还有部分功能可作为系统的扩展点<br>抽象类便于复用，接口便于功能扩展和维护</p>
<p>接口是一种约定：有些接口只有名称</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2021/09/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
